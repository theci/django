생성 모델 폼 구현과 수정 모델 폼 구현이 비슷하듯이 생성 API 구현과 수정 API
구현도 비슷합니다.
수정 모델 폼 구현에서는 수정 대상 레코드를 조회하고 모델 폼 인스턴스 생성 시에 인스턴스
이름의 키워드 인자로 넘겨주면 구현 끝이었죠.
그리고 form.SaveMethod 호출 시에는 포스팅을 생성할 때 이미 작성자 필드가
지정되어 있으니 추가 필드 지정이 필요 없었으니깐요.
커밋 인자 지정 없이 데이터베이스에 저장했었습니다.
수정 API 구현 시에도 수정 대상 레코드를 조회합니다.
그리고 Serializer 인스턴스 생성 시에 instance 이름의 키워드 인자로
넘겨줍니다.
이때에도 포스팅 생성할 때 이미 작성자 필드가 지정되어 있으니 추가 필드 지정이 필요
없으니깐요.
Serializer.save 호출 시에 추가 인자를 지정하지 않고 데이터베이스에
저장합니다. API 뷰에서 수정할 레코드를 조회하고 해당 레코드를 수정할 권한이 있는지
확인하는 로직이 있습니다.
지정 API를 실행할 권한이 있는지 확인할 때에는 Permission 클래스에
HasPermission 메서드를 호출하여 확인하고요.
지정 모델 인스턴스를 수정할 권한이 있는지 확인할 때에는
HasObjectPermission 메서드를 호출하여 확인합니다.
우리가 직접 구현한 PostEdit API를 Django REST Framework에 Update
API View 클래스를 상속받아 클래스 기반 뷰로 구현하신다면 이렇게 구현하실 수
있습니다 Update API View 클래스를 상속받았기에 요청과 패치 요청을 지원합니다.
푼 요청을 받으면 업데이트 메서드를 호출하여 수정 요청을 처리하고요.
푼 요청은 리소스의 전체 수정을 의미하기에 수정 요청 시에 반드시 시리얼라이저에 지정된
모든 필드 값을 전달해 주셔야 요청이 처리됩니다.
패치 요청에서는 파셜 업데이트 메서드를 호출하여 수정 요청을 처리합니다.
패치 요청은 리소스의 부분 수정을 의미하기에 수정 요청 시에 수정할 필드만 지정하셔도
요청이 처리됩니다.
PostCreateAPIView 클래스 코드를 복사해서 PostUpdateAPIView
클래스를 정의해 보겠습니다 상속받은 클래스명과 클래스명, 그리고 생성된 함수명도 바꿔줍니다
업데이트 API 뷰 클래스 코드를 보시면 put 요청에서는 업데이트 메서드를 호출하여
요청을 처리하고요.
패치 요청에서는 partial update 메서드를 호출하여 요청을 처리합니다.
업데이트 메서드 코드를 보시면 관련 내 코드 조회하고 시리얼라이저를 통해 유효성 검사
수행하고요. 유효성 검사에 통과하면 perform update 메서드를 호출하여
데이터베이스에 반영합니다.
perform_update 메서드의 기본 구현에서는 serializer 인스턴스의 save
메서드만 호출합니다 데이터베이스 저장 시에 serializer에 지정된 필드 외에 추가로
저장할 필드는 없으니깐요
performUpdate 메서드를 재정의할 필요는 없겠네요
복사한 코드의 perform_create 메서드는 제거합니다
현재 아이디가 101번인 포스팅이 있고요.
제목은 샘플 제목입니다.
아이디 101번 포스팅에 대해서 수정 요청을 보내보면 500 에러가 발생했습니다.
런 서버 로그를 보시면 PostUpdate API 뷰에 코디셋 설정이 누락되었다고 합니다.
PostCreate API 뷰에서는 레코드 조회 없이 생성만 하니깐요.
코디셋 설정이 필요하지 않은 것이 없고요.
PostUpdate API 뷰에서는 레코드 조회가 필요하니깐 코디셋 설정을 요구하고
있습니다.
PostSerializer의 get_optimized_codiset 정적 메서드로 기본
코디셋을 생성하고 PostUpdateAPIView 클래스의 코디셋 설정에도 추가해줍니다
API 수정 요청을 해보시면 200 응답을 받았고요 ID 101번 포스팅을 조회해 보시면
이처럼 수정된 내역을 확인하실 수 있습니다
푼 요청이니까 Serializer에 지정된 Title 필드와 Content 필드를 모두
지정해야만 하는데요
컨텐츠 필드를 빼고 요청하면 이처럼 유효성 검사에 실패합니다.
그런데 패치 요청에서는 변경된 필드만 보내셔도 이처럼 요청이 처리됩니다.


이번 설명은 Django REST Framework (DRF)에서 생성 API와 수정 API 구현의 유사성을 다루고 있습니다. 구체적으로, 수정 모델 폼과 수정 API 구현에서의 흐름과 차이점, 그리고 실제 코드 구현 방법을 설명합니다. 이를 통해 UpdateAPIView를 사용하여 API 수정 기능을 어떻게 구현할 수 있는지 알 수 있습니다.

1. 생성 API와 수정 API 구현의 유사성
생성 모델 폼과 수정 모델 폼이 비슷한 방식으로 작동하듯, 생성 API와 수정 API도 매우 비슷한 방식으로 구현됩니다.
수정 모델 폼:
수정하려는 레코드를 조회한 뒤, 폼 인스턴스를 생성하면서 instance를 넘겨주면 수정 작업이 완료됩니다.
form.save() 호출 시 이미 필드 값이 지정되어 있기 때문에 추가 필드를 지정할 필요가 없습니다.
수정 API:
수정할 레코드를 조회하고, Serializer 인스턴스를 생성할 때 instance를 지정해 줍니다.
serializer.save()를 호출할 때 추가 인자 없이 데이터를 업데이트합니다.
2. 수정 API 구현 흐름
수정할 레코드를 조회하고, 해당 레코드에 대한 수정 권한이 있는지 확인합니다.
Permission 클래스에서 has_permission() 메서드로 수정 권한을 확인하고, ObjectPermission 클래스에서 has_object_permission() 메서드로 특정 객체에 대한 수정 권한을 확인합니다.
3. UpdateAPIView 클래스를 이용한 수정 API 구현
DRF에서 수정 API는 UpdateAPIView 클래스를 상속받아 쉽게 구현할 수 있습니다. UpdateAPIView는 PUT과 PATCH 요청을 처리할 수 있습니다.
PUT: 리소스의 전체 수정(모든 필드를 전달해야 함).
PATCH: 리소스의 부분 수정(수정할 필드만 전달하면 됨).
4. 수정 API 구현 예시
PostCreateAPIView 클래스를 복사하여 PostUpdateAPIView 클래스를 정의합니다.
클래스명과 메서드명, 그리고 필요한 설정만 수정합니다.
PostUpdateAPIView에서 PUT 요청은 update() 메서드를 호출하여 전체 수정, PATCH 요청은 partial_update() 메서드를 호출하여 부분 수정을 처리합니다.
5. 핵심 메서드 설명
update() 메서드는 요청 데이터를 가져와 유효성 검사를 수행하고, 유효성 검사에 통과하면 perform_update() 메서드를 호출하여 데이터베이스에 반영합니다.
perform_update() 메서드는 기본적으로 serializer.save()만 호출합니다. 이때 추가 필드를 지정하지 않기 때문에 기본적인 save() 호출만으로 수정이 완료됩니다.
perform_create() 메서드는 생성 API에서만 필요하며, 수정 API에서는 제거합니다.
6. 500 에러 발생 원인과 해결
수정 API에서 500 오류가 발생할 수 있는 이유는 코드셋 설정이 누락되었기 때문입니다. PostCreateAPIView에서는 레코드를 조회할 필요가 없지만, PostUpdateAPIView에서는 수정할 레코드를 조회해야 하기 때문에 코드셋 설정이 필요합니다.
이를 해결하기 위해 PostSerializer의 get_optimized_codiset 메서드로 기본 코디셋을 생성하고, PostUpdateAPIView 클래스에서 이 코드셋을 추가해야 합니다.
7. 유효성 검사와 부분 수정
PUT 요청에서는 전체 필드를 전달해야 하며, 일부 필드를 빼고 요청하면 유효성 검사에서 실패합니다.
예: title과 content 필드를 모두 보내야 수정이 가능하지만, content 필드를 빼면 유효성 검사에서 오류가 발생합니다.
PATCH 요청에서는 변경된 필드만 보내면 되므로, 필요한 필드만 포함하여 요청할 수 있습니다. 예를 들어, title만 수정하고 싶다면 title만 보내면 됩니다.
8. 정리
수정 API는 생성 API와 매우 유사하지만, 수정할 레코드를 조회하는 과정과 권한 체크가 추가됩니다.
UpdateAPIView를 상속받아 PUT과 PATCH 요청을 처리하며, 전체 수정과 부분 수정을 구분하여 구현합니다.
perform_update() 메서드에서 추가 필드를 지정하지 않기 때문에, 전체 필드를 전달해야 할 때는 PUT 요청을 사용하고, 부분 수정은 PATCH 요청으로 처리합니다.
코드셋 설정 누락으로 인한 오류를 해결하려면 get_optimized_codiset 메서드를 통해 코드셋을 지정해야 합니다.



