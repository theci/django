파이테스트 장고 플러그인에서는 각 테스트 함수가 실행되기 전에 데이터베이스를
초기화합니다. 이는 테스트 간의 독립성을 유지하고 이전 테스트에서 생성된 데이터가 다음
테스트에 영향을 미치지 않도록 보장합니다.
이를 통해 테스트의 신뢰성과 재현성을 높일 수 있습니다.
게시물 목록 조회 API에서는 비인증 조회가 가능해야 하며 생성한 포스팅의 개수만큼 응답을
받아야만 합니다.
10개의 포스팅을 생성하고요.
비인증 요청으로 포스팅 목록을 조회하고요.
응답 상태 코드는 반드시 200이어야 하며, 응답의 포스팅 개수는 반드시 앞서 생성한
포스팅 개수와 일치해야만 합니다.
pytest에서는 Assert문을 사용하여 이러한 조건들을 검증합니다.
단 하나의 Assert문이라도 거짓 판정을 받는다면 해당 테스트는 실패한 것으로
처리됩니다. 파일 테스트 명령만 실행하면 현재 프로젝트 내에 모든 테스트를 수집해서
실행하고요 이렇게 경로를 지정해서 파일 단위로 테스트를 실행하실 수도 있고 특정 테스트
함수를 지정해서 실행하실 수도 있습니다
테스트 포스트 리스트, 테스트에 대한 설명을 복사해서 적용하겠고요
테스트가 실행되면 10개의 포스트 데이터를 생성해 보겠습니다
PyTest 명령을 수행해 보시면 런타임 에러가 발생하며 데이터베이스 접근을 허용할 수
없으며 데이터베이스 접근을 하려면 pytest.mark.db를 적용하라고 합니다.
PyTest 함수는 디폴트로 데이터베이스 접근이 막혀 있습니다.
테스트 함수에 pytest.mark.db 장식자를 적용하시면 데이터베이스 접근이
허용됩니다.
테스트를 수행해 보시면 Post List 테스트가 수행되었고요 실패 판정입니다
assert 때문이죠 포스팅 목록 초에 API를 호출하려고 하는데요 요청 주소는
url-reverse로 url을 계산해서 지정하려 합니다
프로젝트에 등록된 URL 패턴즈 목록은 이처럼 show_urls 명령을 통해서 확인하실 수
있습니다. API Ver.1 밑에 Post_List 뷰 이름으로 URL
리버스를 수행해서 URL 문자열을 계산하게 비인증 API 요청을 위해 인자로
Unauthenticated API Client만 지정하시면 이 테스트가 실행될 때 해당
이름의 픽스쳐 함수가 자동으로 호출되고요 그 반환 값이 인자로 자동 전달됩니다 지정
URL로 GET 요청을 보내고요 응답을 받습니다
응답 코드는 200이어야 하고요 요청의 포스팅 개수와 응답의 포스팅 개수가 일치해야만
합니다 그런데 테스트를 실행해 보면 개수가 달라서 테스트가 실패합니다 요청의 포스팅 개수는
10이고요 응답의 개수는 2네요
응답 데이터를 보시면 JSON 응답 데이터가 랩핑되어 OK 필드와 Result 필드가
있네요 이 두 필드의 개수를 세어 응답의 개수가 2로 세어졌나 봅니다
이는 해당 API 뷰에서 JSONResponseWrapperMixing 클래스를 적용했기
때문이죠 리절드 키로 참조도록 하여 응답의 포스팅 개수를 다시 세어보면 이제 테스트가
통과됩니다 특정 게시물 조회 API에서는 비인증 조회가 가능해야 하며 기존 포스팅을
조회하면 200 응답을 받고 제목도 조회되어야 합니다
이 테스트가 수행될 때에도 데이터베이스는 비어진 상태니까요.
조회 요청을 위해서는 새 포스팅을 생성해야 합니다.
New Post 픽처를 사용하실 수도 있겠고요.
직접 Post Factory Instance를 생성하여 새로운 포스팅을 생성하실 수도
있겠습니다. 방금 생성한 포스팅을 조회하고요.
조회된 내역과 제목이 일치하는지 검사합니다.
테스트 포스트 리트리브 테스트 테스트 함수의 설명부터 함수 이름까지만 복사하고 나머진 직접 구현해
보겠습니다. 비인증 요청을 위해 비인증 API 클라이언트 픽스처를
사용하겠고요.
새로운 포스팅 생성을 위해 New Post 픽스처를 사용하셔도 되고요.
함수 내에서 직접 PostFactory 인스턴스를 생성하셔도 됩니다.
방금 생성된 포스팅을 조회토록 합니다
GET 요청을 보내어 응답을 받으면 응답 코드는 반드시 200으로 요청이 수락되어
처리되어야 하고요 데이터베이스의 제목과 조회된 제목이 일치해야 합니다
파이테스트 수행 시에 테스트 파일의 경로를 쓰고 콜론 2개 쓰고요 테스트 함수 이름을
지정하여 지정 테스트 함수만 테스트를 수행하실 수 있습니다 수행해 보시면 응답에서
title 키가 없다고 키 에러가 발생합니다
포스팅 조회 API 코드를 보시면 jsonResponseWrapperMix인 클래스를
상속받고 있어 응답 데이터가 랩핑됩니다 응답 데이터에서 result 키로 먼저 조회토록
하시고 테스트를 수행해 보시면 테스트가 통과합니다 생성 API 테스트에서는 인증하지 않은
요청은 403 응답 상태 코드와 함께 거부되어야 하고요.
인증된 요청이며 필요한 값이 모두 지정된 요청에서는 201 응답 상태 코드와 함께 생성된
레코드 내역을 응답 받아야만 합니다.
요청의 제목 내용과 일치하는지 검사합니다.
인증되지 않은 요청은 게시물 생성 요청을 거부하는지 확인하는 테스트 함수의 이름까지
복사합니다 비인증 요청을 위해 unauthenticated API 클라이언트 픽처를
지정하고요 포스팅 생성 주소로 포스트 방식으로 비인증 요청을 보냅니다
시리얼라이저의 유효성 검사 전에 인증과 권한 체크가 먼저 이루어지거든요
지금 테스트로는 403 포비드 응답을 확인하는 것이니 포스트 요청 데이터를 비워두셔도
테스트에는 영향이 없습니다
테스트를 수행해 보시면 테스트가 통과되고요 인증되지 않은 요청은 게시물 생성 요청이
거부되고 있습니다
이번에는 모든 필드 값들이 지정된 인증된 요청은 게시물 생성 요청에 성공하는지 테스트해
보겠습니다 위에 테스트 구현을 복사해서 구현해 보겠습니다.
입력 데이터 타이틀과 컨텐츠 필드가 필요합니다.
Faker Picture를 통해 랜덤 데이터를 생성합니다.
API Client with New User Basic Auth Picture를 통해
인증된 포스트 요청을 보내겠고요.
응답을 받으면 반드시 201 응답이어야 하고요.
요청의 제목과 내용, 그리고 응답의 제목과 내용이 반드시 일치해야만 합니다.
테스트를 수행해 보시면 테스트가 실패하는데요.
오타가 있었네요.
오타 수정하시고 테스트 수행해 보시면 테스트가 통과합니다.
하나의 테스트를 인자만 바꿔 여러 번 실행해야 할 때가 있습니다.
이때 테스트 함수 내에서 방법문을 통해 값을 바꿔가며 테스트를 해보실 수도 있는데요.
이렇게 하면 테스트 결과가 하나로 통합되어 개별 케이스의 성공 실패 여부를 확인할 수
없고요. 실패 시에 어떤 입력 값에서 실패했는지 파악하기 힘들어집니다.
또한 테스트 함수가 복잡해지고 가독성이 떨어집니다.
그에 반해 파이테스트의 parameterize 장식자를 활용하면 테스트 함수를 간결하게
유지하면서도 다양한 입력 값에 대한 테스트를 개별적으로 수행할 수 있습니다.
이 장식자에 전달된 인자 리스트에 따라 테스트가 자동으로 생성되고 각 테스트 케이스의
결과를 개별적으로 확인할 수 있습니다.
이를 통해 어떤 입력 값에서 실패했는지 쉽게 파악할 수 있고요.
테스트 코드의 가독성과 유지 보수성도 향상됩니다.
파라미트라이즈 장식자가 적용된 테스트 함수를 복사합니다.
타이틀 제목이나 컨텐츠 내용 중에 어느 하나라도 누락된 요청을 보내면 상태 코드 400번의
리퀘스트 응답을 받으며 요청이 거부되는지 테스트해 보겠습니다.
파라미트라이즈 장식자를 주석 처리하고요.
반복문을 통해서 수행토록 잠시 변경해 보겠습니다.
함수내에서 테스트 데이터 리스트를 만들어서 테스트를 반복해서 수행하도록 합니다
테스트를 수행해 보시면 테스트 데이터가 3건 있었음에도 이 테스트에 대해서는 단 하나의
테스트로만 수행되었다고 출력됩니다
이 테스트가 실패되도록 두 번째 데이터를 변경하고 다시 테스트를 수행해 보시면 두 번째
데이터에서 테스트가 실패했다는 메시지가 아니라 그냥 이 테스트가 실패했다고만 퉁
쳐서 테스트 결과를 보여줍니다
코드를 되돌려서 파라미터라이즈 장식자를 활용하고요 다시 테스트를 수행해 봅니다
각 타이틀과 컨텐츠 값은 인자로 주입받게 되고요
그럼 지정한 데이터의 개수만큼 개별 테스트로 구동됨을 확인하실 수 있고요
두 번째 데이터만 테스트가 실패하도록 변경해서 다시 테스트를 수행해 보시면 두 번째
데이터에서 테스트가 실패했다고 이렇게 테스트 결과를 보여줍니다
두 번째 테스트 데이터를 원복하고요 다시 테스트를 수행해 보시면 모든 테스트가
통과되었습니다