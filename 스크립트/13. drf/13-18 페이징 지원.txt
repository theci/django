안녕하세요. 이번 시간에는 Django REST 프레임워크의 페이징 지원에 대해서
살펴보겠습니다. 한 테이블에 저장된 레코드 수가 많아질 경우 페이징 방식을 적용하여 전체
레코드를 한번에 전송하는 대신 작은 단위로 나누어 전송하면 사용자에게 빠른 응답을 제공할
수 있습니다.
페이징을 통해 서버의 부담을 줄이고 네트워크 대역폭을 보다 효율적으로 활용할 수 있게
됩니다. Django REST Framework에서는 세 가지 페이징 방식을 지원합니다.
각 방식은 데이터를 요청하는 방식의 차이로 구분합니다.
페이징을 지원할 때 가장 먼저 세팅스의 레스트 프레임워크 설정에서 페이지 사이즈 설정을
해줍니다. 이는 디폴트 페이지 크기로써 다음 3개 페이징 방식에 모두 적용되고요.
각 리스트 요청에서 지정 개수만큼만 조회됩니다.
PageNumberPagination과 LimitOffsetPageNation은 둘 다
오프셋 방식으로 동작하고요.
데이터베이스 쿼리에서 OffsetLimit를 사용합니다.
리밋 오프셋 페이지네이션에서는 데이터베이스 쿼리에 사용될 오프셋 값과 리밋 값을 직접적으로
전달받고요. 페이지 넘버 페이지네이션에서는 페이지 번호를 통해 오프셋 값과 리밋 값을
계산해서 적용합니다.
둘 다 데이터베이스 쿼리에서 Offset을 사용하는데요.
Offset 방식에서는 지정된 개수만큼 레코드를 스캔해야 하기 때문에 테이블 크기가 아주
크고, Offset 값도 아주 클 경우 스캔해야 할 레코드 수가 많아지므로 데이터베이스
조회 속도가 느려질 수도 있습니다만, 중소 규모의 데이터에서는 충분히 빠른 응답 시간을
기대할 수 있습니다.
오프셋 방식의 장점으로는 페이지나 오프셋을 지정해서 원하는 위치의 레코드를 손쉽게 조회할
수 있다는 장점이 있습니다.
Cursor Pagination은 인덱스를 사용하여 필요한 위치부터 레코드를 빠르게 찾을
수 있어 조회 속도가 빠릅니다.
하지만 페이지 번호 대신 커서를 사용하므로 특정 페이지로 직접 이동하는 것은 불가능하고요
그래서 사용자가 원하는 페이지로 바로 건너뛰는 기능을 제공하기는 어렵고요 페이지를
순차적으로만 조회할 수 있습니다
커서 방식의 페이징은 offset 방식에 비해서 구현이 복잡한데요.
하지만 Django REST Framework에서는 이미 완전한 페이징 클래스로서 지원하므로
API 뷰의 클래스 지정만으로 손쉽게 커서 기반 페이징을 안정적으로 지원할 수 있겠죠.
첫 번째로 페이지 넘버, 페이지네이션을 살펴보겠습니다.
settings의 레스트 프레임워크 설정에 페이지 사이즈 설정으로 페이지 크기를 전역으로
설정하고요. Default Pagination Class 설정으로 디폴트 페이징 클래스를 지정하시면 지정
페이징 클래스로 모든 리스트 API 뷰에 페이징 지원이 활성화됩니다.
리스트 조회 요청에서는 쿼리 파라메터 페이지를 통해 페이지 번호를 전달받고요.
페이지 번호와 페이지 사이즈 설정을 통해 오프셋 값과 리밋 값을 계산하여 데이터베이스에서
조회합니다. 목록 조회 API 요청을 해보시면 이처럼 4개 필드로 응답을 받습니다.
result 필드는 조회된 레코드 목록이고요.
count 필드는 총 레코드 개수이고, next 필드는 다음 페이지의 주소이고,
previous 필드는 이전 페이지의 주소입니다.
다음 페이지와 이전 페이지 주소를 제공해 주기에 따로 다음, 이전 페이지 주소를
계산하지 않아도 되기에 편리합니다.
이 4개 필드명을 변경하시거나 필드 구성을 변경하시려면
PageNumberPagination 클래스에서 GetPaginatedResponse
메서드를 재정의해서 구현하실 수 있습니다.
REST framework 설정으로 전역 페이징 설정을 하실 수 있고요.
각 API 뷰마다 Pagination 클래스 속성으로 API마다 다른 Pagination
클래스를 지정하실 수 있습니다.
현재 포스팅 목록 API 응답에서는 전체 포스팅 목록이 출력되고 있고요.
아직 페이지네이션을 적용하지 않았습니다.
settings의 레스트 프레임워크 설정에서 페이지 사이즈 설정과 디폴트 페이지네이션 클래스 설정을
해줍니다. 그럼 리스트 모델 믹싱 클래스를 상속받은 모든 API 뷰에 페이지네이션 처리가
추가됩니다.
응답에서 next 키로 다음 페이지 주소를, previous 키로 이전 페이지 주소도
제공해 주고요.
페이지 코디 파라메터를 통해 지정받은 페이지 단위로 조회가 됩니다.
페이지 값을 크게 늘려 존재하지 않는 페이지 번호를 지정하시면 이렇게 404 Not
Found 응답을 받게 됩니다.
수행되는 SQL 내역을 보시면 이렇게 페이지 번호와 페이지 사이즈 값 기반에서 Limit
값과 Offset 값을 계산하여 조회하고 있음을 확인하실 수 있습니다.
리스트 모델 믹싱 클래스의 리스트 메서드에서 페이지네이트 코디셋 메서드 호출을 통해
페이지네이션 처리가 수행되고 있습니다
각 API 뷰 마다 페이지네이션 클래스 속성을 지정하여 서로 다른 페이지네이션 클래스를
사용하실 수도 있고요
페이지넘버 페이지네이션 클래스에서는 클래스 변수로 PAGE_SIZE가 있고 API
세팅스의 페이지 사이즈 값을 디폴트 값으로 가지고 있습니다
settings의 페이지 사이즈 값은 하드 코딩하지 않고 환경 변수로부터 지정 받을 수 있도록
하겠습니다.
PageNumber, PageNation 클래스의 PageUnderbarSize 속성은
settings의 REST 프레임워크 설정에 PageUnderbarSize 설정이 디폴트로
지정되는데요. 만약 각 API 뷰마다 서로 다른 페이지 크기를 지정하시려면 이렇게 페이지
크기마다 새로운 PageNumber, PageNation 클래스를 만드셔야만 합니다.
혹은 이렇게 새로운 페이지넘버, 페이지네이션 클래스를 생성해주는 팩토리 함수를 만들어서
활용하실 수도 있습니다.
API 뷰마다 사용되는 페이지네이션 옵션이 다를 경우, makePageNation 클래스
함수를 통해 API 뷰 구현과 가깝게 클래스를 생성, 정의하실 수 있어 편리합니다.
이렇게 직접 정의한 PageNation 클래스를 사용하실 수도 있고,
MakePageNation 클래스 팩토리 함수를 통해 생성된 클래스를 사용하실 수도
있습니다. 글로벌 설정된 PageSize 값을 무시하고 커스텀 지정하시려면 이렇게
PageNumber, PageNation 클래스를 상속받으시고 PageSize 클래스 변수를
재정의하셔야 합니다.
새롭게 정의한 Pagination 클래스를 적용해 보시면 이렇게 지정한 개수만큼 조회되고
있습니다. make pagination class 함수를 활용하여 동적으로
PageNumber Pagination 클래스를 생성해 보겠습니다.
미리 제공해 드린 코드를 코어 디렉토리 밑에 pagination.py 파일로 복사해
주세요. 새롭게 생성될 클래스명 문자열을 조합하고 상속받을 부모 클래스를 지정하고요.
클래스의 속성을 사전으로 생성해두고 새로운 클래스를 동적으로 생성하고 반환합니다.
makePageNation 클래스 함수를 호출하시고 원하시는 페이지 사이즈 값을 인자로
넘겨 반환된 클래스를 PageNation 클래스 속성에 지정합니다.
인자로 지정하신 대로 페이지 사이즈가 지정되어 PageNumber, PageNation이
동작함을 확인하실 수 있습니다.
Limit Offset Pagination은 Page Number Pagination과
유사하게 동작합니다.
이 Pagination 방식은 Query 파라메터 Limit과 Offset 값을 직접
데이터베이스 쿼리에 사용합니다.
Limit 파라메터는 한 페이지에 반환할 레코드의 최대 개수를 지정하고, Offset
파라메터는 건너뛸 레코드의 개수를 지정합니다.
만약 Limit 파라메터가 지정되지 않으면 디폴트로 Page Size 설정 값이
사용됩니다.
LimitOffsetPagination 클래스를 사용해 보겠습니다.
이렇게 Pagination 클래스 설정을 변경하는 것만으로 해당 API 뷰의
Pagination 방식이 변경됩니다.
Limit Offset Pagination 클래스에서는 API Settings의 Page
Size 설정이 Default Limit 클래스 변수로 사용되어지고 있습니다.
페이지 새로고침하시면 Limit Offset 방식으로 동작합니다 응답의 Next 주소를
보시면 Limit Query 파라메터와 Offset Query 파라메터로 변경되어 있습니다
Query 파라메터로 지정된 Limit 값과 Offset 값이 데이터베이스 조회에
직접적으로 사용되고요 PageNumberPagination에서는 페이지 크기 단위로만
조회를 했었지만 LimitOffsetPagination에서는 Limit 값과 Offset
값을 페이지 크기뿐만 아니라 원하시는 값으로 지정해서 조회하실 수 있습니다.
그런데 LimitOffsetPageNation의 기본 설정에서는 Limit 파라메타 값
범위에 제한이 없습니다.
즉, 사용자가 매우 큰 값을 Limit 값으로 지정하면 테이블의 모든 레코드를 한 번에
조회할 수 있다는 문제가 있습니다.
이를 사용자가 악의적으로 이용할 경우 서비스의 데이터를 한 번에 대량으로 가져갈 수도
있겠죠. 현재 포스팅 총 개수는 103개인데요.
Limit 값을 103보다 큰 값으로 지정해 봅니다.
그러면 이렇게 한 번에 모든 포스팅이 조회됩니다.
그래서 Limit Offset 페이지네이션을 사용할 때에는 MaxLimit 속성을 꼭
설정하여 Limit 파라미터의 최대 값을 제한하시기를 추천드립니다.
Default Limit 속성과 MaxLimit 속성을 커스텀 하시려면 이렇게 각 설정
값마다 새로운 클래스를 지정하셔야 하는데요.
혹은 make pagination class 팩토리 함수를 보강해서 지정한 클래스 타입에
맞춰 새로운 pagination 클래스를 생성하도록 활용하실 수도 있습니다.
매번 클래스를 정의하지 않아도 팩토리 함수를 통해 원하는 옵션으로 손쉽게
pagination 클래스를 생성하여 활용하실 수 있습니다.
limitOffsetPagination 클래스에는 maxLimit 클래스 변수가 있고요.
default로 none입니다.
getLimit 메서드는 쿼리에 사용할 limit 값을 계산하는 메서드인데요.
__positive int 함수 호출 시에 cutoff 인자로 maxLimit 값을 넘기고
있죠. 구현을 보시면 cutoff 인자의 값이 있을 때 built-in 함수 min을 통해
최대 값을 제한하도록 동작하고 있습니다.
MaxLimit 클래스 변수를 지정해서 Limit 값의 최대 값을 제한할 수 있습니다.
LimitOffsetPagination 클래스를 상속받은 새로운 클래스를 정의하고
MaxLimit 클래스 변수 값을 10으로 지정했습니다.
그리고 이 클래스를 적용합니다.
그럼 요청 주소에서 Limit 값을 만으로 지정했음에도 실제 Limit은 10으로 제한되어
10개의 포스팅이 조회되었음을 확인하실 수 있습니다.
MakePagination 클래스 함수에 LimitOffsetPagination 클래스
지원을 추가하시고요.
동적으로 클래스를 생성해서 활용합니다.
인자로 지정한 대로 LimitOffsetPagination이 잘 동작합니다.
마지막 세 번째로 CursorPagination입니다.
Cursor 기반 페이지네이션에서는 각 페이지의 마지막 레코드 값을 Cursor로 사용하여
다음 페이지를 요청할 때 해당 Cursor 값을 기준으로 데이터를 가져옵니다.
이때 커서로 사용되는 필드는 고유하고 변경 불가능해야 하며 데이터베이스 인덱싱이 되어
있다면 더욱 빠르게 조회할 수 있습니다.
API 뷰에 커서 페이지네이션이 적용되면 오더링 설정에 기본으로 지정된 created
필드를 찾아서 정렬과 조회를 수행합니다.
그런데 만약 모델에 created 필드가 없다면 이처럼 필드 에러 예외가 발생합니다.
커서 페이지네이션 클래스를 상속받은 새로운 클래스를 정의하여 오더링 설정을 이렇게
재정의하실 수 있습니다.
현재 페이지 크기가 5인 상황인데요.
수행된 코디 내역에서 limit 값이 6으로 페이지 크기보다 하나 더 큰 값입니다.
하나 더 추가로 조회된 레코드는 실제 응답에는 포함되지 않고요.
단순히 다음 페이지의 존재 유무를 확인하는 용도로만 사용됩니다.
코리 파라메터 Cursor 값은 Base64 인코딩된 문자열이고요.
Base64 디코딩하시면 이렇게 조회 기준 값을 확인하실 수 있습니다.
Pick 값은 포지션을 의미하고요.
조회 기준이 되는 필드 값이고요.
R 값은 Reverse를 의미하고요.
역순정렬 여부입니다.
포지션에 지정된 값을 기준으로 이어서 다음 레코드와 이전 레코드를 조회합니다.
Cursor Pagination으로 변경해 봅니다.
페이지 새로고침하시면 이렇게 created 필드를 찾지 못해
필드에로 예외가 발생했습니다.
포스트 모델에는 created 필드가 현재 없습니다.
CursorPagination 클래스 코드를 보시면 ordering 클래스 변수의 디폴트
값이 "-created".
이 값을 변경해서 적용하려면 클래스 상속을 해야겠죠.
새로운 CursorPagination 클래스를 만들고 ordering 설정을 변경하고요.
이 클래스를 적용합니다.
그러면 지정한 옵션으로 커서 페이지네이션이 잘 동작합니다 응답의 next 값에 커서 쿼리
파라메타가 있습니다
이 값은 조회 기준 값이고요 오더링 클래스 변수에 지정된 필드에 대해서 커서에 지정된
값으로 조건을 걸고 페이지 사이즈에 지정한 개수만큼 조회를 합니다
커서 파라메타 값은 base64 방식으로 인코딩된 값인데요 직접 디코딩을 해보면요 이렇게
p는 99라는 문자열입니다
현재 페이지의 마지막 id 값이 99 잖아요.
이 마지막 값을 보고 next 주소의 cursor 값이 지정된 것이고요.
다음 페이지로 넘어가서 조회된 SQL 내역을 보시면 현재 페이지의 cursor로 지정된
값인 99가 조회 조건으로 지정되어 활용되고 있음을 확인하실 수 있습니다.
CursorPagination 클래스의 두 가지 설정, PageSize와 Ordering
설정이 필수인데요.
이렇게 새로운 클래스를 정의하실 수도 있겠고요.
MakePagination 클래스에 CursorPagination에 대한 지원을 추가하실
수도 있겠습니다.
매번 클래스를 정의하시지 않아도 팩토리 함수를 통해 원하는 옵션으로 손쉽게
PageNation 클래스를 생성하여 활용하실 수 있습니다.
make-pagination-class 함수에 cursor-pagination-class
지원을 추가합니다
그리고 이 함수를 통해 새로운 cursor-pagination-class를 생성해서
활용하고요 지정된 옵션으로 잘 동작하고 있습니다



Django REST Framework에서 제공하는 페이징 방식에 대해 상세히 설명한 내용을 요약해드리겠습니다.

1. 페이징의 중요성
대량의 데이터를 한 번에 전송하는 대신, 페이징을 통해 작은 단위로 데이터를 나누어 전송함으로써 빠른 응답과 서버 부하 감소, 효율적인 네트워크 사용을 도울 수 있습니다.
2. 지원하는 페이징 방식
Django REST Framework는 세 가지 페이징 방식을 지원합니다:

PageNumberPagination (페이지 번호 기반)
LimitOffsetPagination (오프셋 기반)
CursorPagination (커서 기반)
3. 공통 설정
페이징을 사용할 때 가장 먼저 해야 할 설정은 settings.py의 REST_FRAMEWORK 설정에서 PAGE_SIZE를 설정하는 것입니다. 이 값은 기본 페이지 크기로, 모든 페이징 방식에 적용됩니다.
또한, DEFAULT_PAGINATION_CLASS를 지정하여 디폴트로 사용할 페이징 방식을 설정할 수 있습니다.
4. PageNumberPagination
페이지 번호를 기반으로 데이터를 조회하며, 쿼리 파라미터로 page를 사용해 페이지 번호를 전달합니다.
응답에는 results, count, next, previous 네 가지 필드가 포함됩니다.
장점: 간단하고 직관적.
단점: 테이블 크기가 매우 커질 경우, 많은 레코드를 스캔해야 해서 조회 속도가 느려질 수 있음.
구현: PageNumberPagination 클래스를 사용하고, get_paginated_response 메서드를 오버라이드하면 응답 포맷을 커스터마이징할 수 있습니다.
5. LimitOffsetPagination
쿼리 파라미터로 limit (페이지당 레코드 개수)와 offset (건너뛸 레코드 수)를 사용하여 데이터를 조회합니다.
장점: 페이지 번호 대신 limit과 offset으로 원하는 위치부터 데이터를 가져올 수 있습니다.
단점: 사용자가 너무 큰 limit 값을 지정하면 서버에 과부하를 줄 수 있습니다.
보완: MaxLimit 값을 설정하여, limit 값을 제한할 수 있습니다.
6. CursorPagination
커서를 기반으로 페이지를 조회합니다. 커서는 각 페이지의 마지막 레코드 값을 기준으로 동작하며, Base64 인코딩된 커서 값을 cursor 파라미터로 전달합니다.
장점: 테이블 크기가 매우 클 때도 조회 속도가 빠르며, 인덱스를 활용하여 성능을 최적화할 수 있습니다.
단점: 사용자가 직접 페이지 번호를 지정할 수 없고, 페이지를 순차적으로만 조회할 수 있습니다.
구현: CursorPagination 클래스에서 ordering과 page_size를 설정하여 사용할 수 있습니다.
7. 페이징 방식별 특징 비교
페이징 방식 	|    장점	    |    단점
PageNumberPagination    |	직관적, 페이지 번호로 손쉽게 접근 가능  |	테이블이 클 경우 조회 성능이 떨어질 수 있음
LimitOffsetPagination   |	더 유연한 limit과 offset으로 데이터 범위 지정 가능  |	limit을 너무 크게 설정하면 서버에 부담이 될 수 있음
CursorPagination	큰 데이터셋에서도 성능이 뛰어나고, 인덱스를 활용 가능	페이지 번호로의 직접 접근이 불가능, 순차 조회만 가능
8. 페이지 크기 설정 및 커스터마이징
PAGE_SIZE 설정을 통해 기본 페이지 크기를 지정할 수 있습니다.
각 API 뷰마다 다른 페이지 크기를 설정하려면, Pagination 클래스를 상속하여 커스터마이징하거나 makePagination 팩토리 함수 등을 활용하여 동적으로 클래스를 생성할 수 있습니다.
9. LimitOffsetPagination의 추가 설정
기본적으로 limit에 대한 범위 제한이 없기 때문에, MaxLimit 속성을 사용하여 사용자가 지정할 수 있는 limit의 최대 값을 설정하는 것이 좋습니다.
MaxLimit을 설정하지 않으면, 사용자가 지나치게 큰 limit 값을 설정할 수 있어 서버에 과부하를 줄 수 있습니다.
10. CursorPagination의 추가 설정
ordering 속성으로 커서를 정렬할 기준 필드를 설정할 수 있습니다.
데이터베이스에서 created와 같은 고유한 필드를 기준으로 정렬하고, 커서 값은 Base64로 인코딩되어 전달됩니다.
커서를 기반으로 데이터를 가져오며, 한 페이지에 마지막 레코드를 커서로 사용하여 다음 페이지를 조회합니다.
11. 동적 페이징 클래스 생성
makePagination 팩토리 함수를 사용하여 원하는 페이징 방식과 페이지 크기를 인자로 전달하고, 동적으로 페이지네이션 클래스를 생성하여 사용할 수 있습니다.

정리하자면, Django REST Framework에서는 세 가지 주요 페이징 방식을 제공하며, 각 방식은 데이터 요청 방식과 조회 성능에 따라 다르게 활용됩니다. 
PageNumberPagination은 가장 기본적인 방식이고, LimitOffsetPagination은 더 유연한 방식, CursorPagination은 대규모 데이터셋에서 성능이 뛰어난 방식입니다. 
각 페이징 방식은 적절한 설정을 통해 최적화할 수 있습니다.