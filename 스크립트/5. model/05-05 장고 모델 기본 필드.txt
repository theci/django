안녕하세요. 이번 시간에는 장고 모델 기본 필드에 대해서 살펴보겠습니다.
장고 기본에서 제공해주는 모델 필드를 7가지 분류로 나눠 정리해봤습니다.
각 모델 필드는 데이터베이스에 따라 데이터베이스 타입이 다르게 지정될 수 있고요.
이는 각 데이터베이스에서 지원하는 기능이 제각기 다르기 때문입니다.
각 데이터베이스 타입은 모델 필드 옵션에 따라 크기가 변경될 수 있으며, 모델 필드
클래스를 재정의해서 다른 데이터베이스 타입에 맵핑하실 수도 있습니다.
분류별로 활용 예시를 하나씩 살펴보겠습니다.
AppConfig 클래스는 장고 앱에 메타 데이터를 설정하고, 앱이 시작할 때 필요한
설정을 준비하는 역할을 합니다.
데이터베이스에서는 자동 증가, 정수 필드를 기본 키로 많이 사용합니다.
데이터베이스 테이블에 데이터가 인서트되는 시점에 1부터 1씩 자동 증가된 값이
데이터베이스로부터 자동 할당됩니다.
장고에서는 3가지 Auto Field 타입을 지원합니다.
AppConfig 클래스의 Default Auto Field 설정이 Big Auto
Field로서 장고 3.2부터 8byte 정수 필드로 지정되어 있습니다.
장고 3.2 이전에는 Auto Field가 Default로서 4바이트 정수 필드였어요.
모델 클래스에 기본 키로 지정한 필드가 없을 경우, 아이디 이름의 기본 키가 해당 앱의 앱
컨피그에 Default Auto Field에 지정된 타입으로 기본 키 필드가 자동
추가됩니다. 만약 Default Auto Field 설정이 없다면, 프로젝트 세팅스에
Default Auto Field 설정을 따르며, 이는 4바이트 정수 필드입니다.
2 바이트는 약 3만 개까지, 4 바이트는 20억 개까지, 그리고 8 바이트는 거의 9경
개까지의 데이터를 다룰 수 있습니다.
모델 초기 설계 시에는 Default Auto Field를 사용하시고, 서비스를
운영하시면서 필요에 따라 기본 키의 타입을 바꿔주세요.
모델 클래스에서 ID 필드명으로 기본 키 값을 조회할 수 있으며, 별칭으로서 PK 이름으로
기본 키를 조회하실 수 있습니다.
기본 키가 할당되기 전에 필드 값은 non이며, .save 메서드 호출을 통해
데이터베이스에 저장되면, 데이터베이스로부터 할당받은 자동 증가된 정수 값으로 변경됩니다.
조회 쿼리셋에서 필드명 뒤에 언더바 두 개로 지정한 문법은 필드 문법으로서, 필드 타입별로
지원하는 룩업 키워드가 다릅니다.
Auto Field는 숫자이기에 대소 비교가 가능하며, LT, LTE, GT, GTE
키워드를 통해 작음, 작거나 같음, 큼, 크거나 같음
조건을 지정할 수 있습니다.
Range 키워드를 통해 범위를 지정하고, In 키워드를 통해 멤버십 조건을 지정할 수
있습니다.
데이터베이스에서 지원하는 숫자 데이터 타입에 맞춰 Django 기본에서는 8가지 숫자 모델 필드를
지원하고 필드 특성에 맞춰 각 값에 대한 유효성 검사를 수행합니다.
양수만을 저장하는 경우라면 positive 계열의 필드를 사용하면 모델을 이용한 유효성
검사 및 저장 시에 0 이상의 값들로만 저장됨을 보장받을 수 있습니다.
혹은 Validators 속성을 통해 최소 최대값 범위를 지정하여 원하는 범위로만
저장하도록 제한을 걸 수도 있습니다.
소수점을 지원하는 필드는 FloatField와 DecimalField입니다.
Float Field는 부동소수점 수 필드로서 숫자를 이진수로 표현하기에 소수점 계산에서
오차가 발생할 수 있습니다.
대신 메모리를 효율적으로 사용하면 계산이 빨라요.
일반적인 과학 및 공학 계산에서는 부동소수점이 널리 사용이 됩니다.
그런데 금융에서는 소수점을 오차 없이 계산하는 것이 필요하거든요.
이때에는 고정소수점수 필드인 데시말 필드를 활용해서 정확한 계산을 수행할 수 있습니다.
max_digits 인자와 DecimalPlaces 인자를 통해 소수점의 정밀도를 조정하실 수
있어요. 정확한 계산을 하는 대신 부동소수점에 비해서 계산 속도가 10배에서 50배 이상
느립니다. 숫자 필드는 코리셋에서 Auto Field와 동일한 필드 조회를 수행할 수
있습니다. 장고 기본에서는 문자열 필드로서 Character Field와 Text
Field를 기본 지원하고, Character Field를 확장한 Slug Field,
이메일 필드, url 필드를 추가로 지원합니다.
캐릭터 필드는 길이 제한이 있는 문자열 필드로서 최대 허용 길이 옵션인 max_length
지정이 필수이며 텍스트 필드는 길이 제한이 없는 문자열 필드입니다.
길이 제한이 있는 필드가 처리 속도가 더 빠르며 인덱스 생성에 유리합니다.
슬러그 필드, 이메일 필드, URL 필드 클래스는 캐릭터 필드 클래스를 상속받아 고유
포맷을 검사하는 필드입니다.
데이터베이스 입장에서는 모두 같은 문자열이지만, 장고에서는 필드 특성에 맞게 유효성 검사를
수행합니다. 슬러그 필드는 입력된 문자열이 슬러그 문자열 패턴인지 검사하고요.
이메일 필드는 RFC-3696 그리고 5321에 기반하여 입력된 문자열이 이메일 패턴인지
검사하며, URL 필드의 문자열인지 검사합니다.
이외에도 주민번호 패턴을 검사하는 주민번호 필드, 휴대폰 번호 패턴을 검사하는 폰넘버
필드, 신용카드 번호 패턴을 검사하는 크레딧 카드 넘버 필드 등의 커스텀 필드를 만들 수
있습니다. 이렇게 커스텀 모델 필드를 만들면 코드 가독성 및 재사용성이 높아지고, 데이터
유형을 엄격하게 정의하여 잘못된 유형의 데이터가 입력되는 것을 사전에 방지할 수 있어서
에러 발생의 가능성을 모델 필드 옵션으로 Null True 지정은 데이터베이스에서 값이
없을 수도 있는 Null이 가능한 필드로 지정합니다.
문자열에서 값이 없는 상태를 Null 상태와 빈 문자열 상태, 즉 이 두 가지 유형을 모두
두면, 값이 없는 상태를 조회할 때 Null과 빈 문자열을 모두 체크해야 하는 번거로움이
발생합니다. 문자열 필드에 대해서는 Null을 허용하지 않고, 값이 없는 상태는 빈 문자열로만
저장하기를 권장합니다.
이 지정하면 빈 문자열이 허용합니다.
웹서비스에서 유저가 업로드한 파일을 저장하는 방법에는 크게 두 가지가 있습니다.
첫 번째는 파일 내용을 데이터베이스에 직접 저장하는 것이고, 두 번째는 파일을 파일
시스템에 저장하고, 데이터베이스에는 해당 파일의 경로 문자열만 저장하는 것입니다.
Binary Field를 사용하면 파일 내용을 데이터베이스에 직접 저장할 수 있습니다.
이 방식의 단점은 데이터베이스 크기가 급격히 증가하고, 큰 파일 처리로 인해 데이터베이스
성능이 저하될 수 있으며, 파일 조회 속도가 파일 시스템에서의 조회보다 느릴 수 있습니다.
반면에 파일 필드와 이미지 필드는 파일을 파일 시스템에 저장하고, 저장된 파일의 상대
경로를 데이터베이스에 저장합니다.
이 방식은 데이터베이스 용량을 적게 차지하고 데이터베이스 부하를 줄이는 장점이 있어요.
다만 데이터베이스와 파일 시스템을 별도로 관리해야 하는 복잡성이 있습니다.
하지만 파일 조회가 빠르고 엔진X 웹서버나 CDN과 같은 정적 파일 서빙 서비스와 잘
연동됩니다. 로컬 파일 시스템 외에도 파일 스토리지 API를 통해 아마존 S3, 애저
스토리지, 구글 클라우드 스토리지 같은 클라우드 서비스와 FTP, SFTP를 저장소로
활용하실 수 있습니다.
파일 필드는 모든 포맷의 파일을 허용하며, 이미지 필드는 이미지 파일만을 허용합니다.
유효성 검사 함수를 추가하여 업로드할 수 있는 파일의 확장자를 제한할 수도 있습니다.
ImageField는 파일 필드를 상속받으며, 추가로 이미지 파일의 유효성을 검사합니다.
이를 사용하기 위해서는 Pillow 라이브러리가 필요하며, 설치되어 있지 않으면 서버
구동이나 마이그레이션 단계에서 오디오를 통해 필요성을 알려줍니다.
또한 PDF 파일 필드, 엑셀 파일 필드와 같은 커스텀 필드를 개발하여 코드의 가독성과
재사용성을 높이고 업로드된 파일을 엄격하게 관리할 수 있습니다.
유저의 파일 업로드 요청을 처리할 때 파일 필드나 이미지 필드를 사용하면 많은 이점이
있습니다. 이 필드들을 통해 파일의 유효성 검사, 저장, 조회 등을 손쉽게 처리할 수
있으며 복잡한 파일 관리 작업을 거의 신경 쓰지 않아도 됩니다.
장고에서 파일 업로드 요청을 반드시 파일 필드로만 처리해야 하는 것은 아닙니다.
개발자는 뷰 함수에서 업로드 요청을 받아 직접 파일을 저장할 수 있습니다.
이 과정에서 파일 스토리지 API를 직접 사용해서 다양한 파일 스토리지에 일관된 API로
쉽게 저장하고 조회할 수 있습니다.
파이 스토리지 API는 파이 저장에 대한 추상화된 접근 방식을 제공하여, 다양한 스토리지
옵션과의 호환성을 높여줍니다.
파이 패스 필드는 장고 프로세스가 구동 중인 서버 파이 시스템 상의 경로를 저장할 수 있는
필드입니다. 패스 인자를 지정하고, 매치 인자를 통해 허용할 파일명 패턴을 지정하면, 해당
경로 상의 파일명을 선택하고, 저장할 수 있는 폼필드를 제공받을 수 있습니다.
장고 기본에서 날짜 시간을 저장하는 4개의 필드를 지원합니다.
데이트 필드는 날짜 데이터만을 저장하는 필드입니다.
연, 월, 일 날짜를 저장하며 시간 정보는 포함하지 않습니다.
타임 필드는 시간 데이터만을 저장하는 필드입니다.
오후 3시 45분과 같은 시각을 저장하는데 사용됩니다.
데이트 타임 필드는 날짜와 시간을 함께 저장하는 필드입니다.
이 필드는 연월일 정보와 함께 시분초 정보를 포함합니다.
데이트 타임 필드는 타임존을 지원하기 때문에 다양한 타임존에 정확한 일시를 처리할 수
있습니다. 예를 들어, 2023년 1월 1일 오전 8시 30분 GMT와 같은 날짜와 시간을
함께 저장하는데 적합합니다.
Duration 필드는 시간의 길이를 저장하는 필드입니다.
예를 들어, 2시간 30분, 5일 4시간과 같은 지속 시간을 입력받고 저장하는 데
사용합니다.
DateTime 필드에서 AutoNowAdd 혹은 AutoNowOption은 데이터의 최초
생성 일시와 수정 일시를 추적하는 데에 유용합니다.
대부분의 모델 필드의 예시와 같이 CreatedAt, UpdatedAt 필드를 추가하게 될
것입니다. 불리한 필드는 참거짓 값을 저장하고요.
SQLite, MySQL, PostgreSQL에서는 불 타입으로, Oracle에서는 숫자
타입으로 저장됩니다.
만약 데이터베이스에 대문자 y 또는 대문자 n과 같은 문자열로 참거짓을 저장하고자 할
경우, Django에서는 커스텀 불리언 필드를 만들어 Django 기본의 불리언 필드와
같이 처리하실 수 있습니다.
장고 레벨에서는 여전히 True, False 값으로 동작하고요.
데이터베이스에 저장하거나 쿼리할 때 대문자 Y, 대문자 N 문자열로 변환하여 처리할 수
있습니다.
Generic IP Address 필드는 IP Ver.4 또는 IP Ver.6 형식의 IP
주소를 저장할 수 있는 필드입니다.
PostgreSQL은 IP 주소를 INET 타입으로 저장하고요.
IP 관련 연산을 데이터베이스에서 지원합니다.
다른 데이터베이스 시스템에서는 IP 주소를 문자열 형태로만 저장합니다.
JSON 필드는 JSON 데이터를 저장하고 SQLite에서는 문자열로 저장되고 그 외
데이터베이스에서는 네이티브로 JSON 타입을 지원합니다.
SQLite에서만 JSON 타입 지원이 없지만, 2023년 12월에 SQLite에
JSON-B 타입을 지원하기 시작했다는 소식이 있습니다.
UUID 필드는 범용 고유 식별자 UUID 문자열을 저장하는 필드입니다.
PostgreSQL에서는 네이티브로 UUID 타입을 지원하며 그 외 데이터베이스에서는
문자열로 저장합니다.
예제 코드에서는 default 옵션으로 uuid4 함수를 지정하여 각 인스턴스가 생성될
때마다 고유한 uuid가 자동으로 생성되도록 설정했으며, editable 거짓 옵션을 통해
이 필드가 사용자에 의해 수정되는 것을 방지합니다.
장고는 데이터 모델 간의 관계를 정의할 수 있도록 세 가지 관계 필드 타입을 제공합니다.
이러한 필드들은 장고의 ORM인 모델을 통해 데이터베이스에 저장되는 구조를 추상화하여
개발자가 데이터베이스 코디를 직접 작성하지 않아도 복잡한 데이터 관계를 손쉽게 처리할 수
있도록 도와줍니다.
그 첫 번째로 모델은요.
Many-to-one 관계를 정의할 때 사용됩니다.
예를 들어 여러 개의 댓글이 하나의 게시글에 속할 수 있습니다
넷플릭스의 프로필은 한 유저가 다수의 프로필을 가질 수 있습니다
이때 외래키 필드를 사용해서 관계를 정의할 수 있겠고요
원투원 필드는 1대1 관계를 정의할 때 사용됩니다
예를 들어, 유저 모델과 프로필 모델 간의 일대일 관계를 설정할 수 있으며, 이렇게 하면
사용자마다 하나의 프로필을 가지게 됩니다.
하나의 거대한 모델을 여러 모델로 분할하면 각 모델의 관리가 용이해지고, 데이터베이스의
정규화를 돕는 동시에 유지보수와 확장성이 향상됩니다.
또한 이 방법은 데이터 모델 간의 명확한 구분을 제공하여 애플리케이션의 데이터 구조를 더욱
이해하기 쉽게 만듭니다.
세 번째로 many-to-many 필드를 통해서 many-to-many 관계를 정의합니다.
하나의 인스턴스가 여러 인스턴스와 관계를 맺을 수 있고, 그 반대도 가능할 때 사용합니다.
예를 들어 하나의 게시글에는 여러 개의 태그를 할당할 수 있고, 하나의 태그는 여러
게시글에 사용될 수 있는 거죠.
슬라이드 하단의 코드 예시는 각 관계의 필드를 어떻게 모델에 적용하는지 보여줍니다.
프로필 모델은 유저 모델과 one-to-one 필드로 연결되어 있고, 포스트 모델은
author, 작성자 필드를 통해 유저 모델과 외래키도 연결되며, many-to-many
필드를 사용하여 태그 모델과 many-to-many 관계를 맺고 있습니다.
코멘트 모델도 포스트 모델과 외래키로 연결되어 있어 하나의 게시글에 여러 댓글이 달릴 수
있음을 나타냅니다.
각 모델이 관계를 맺을 때, 장고는 데이터베이스에 외래키 제약 사항을 추가합니다.
이러한 제약사항은 데이터의 무결성을 강화하는데 도움이 되어 데이터베이스를 통한 엄격한
데이터 관리를 가능하게 합니다.
데이터가 연결된 테이블 간의 일관성이 유지되도록 하며, 탐조되는 데이터가 삭제되었을 때,
외래키를 가진 모든 데이터가 적절히 처리되도록 합니다.
그러나 데이터베이스 테이블 파티셔닝이 필요하거나 외래키 제약사항의 오보이드가 문제가 되는
경우, 장고 모델 정의 시에 dbConstraint 옵션을 거짓으로 설정하여 외래키
제약사항을 비활성화할 수 있습니다.
이렇게 하면 모델 마이그레이션 시에 외래키 제약사항이 추가되지 않습니다.
장고의 모델은 여전히 관계를 추적하지만 데이터베이스 레벨에서는 외래키 제약 사항이 적용되지
않아 데이터베이스의 성능과 유연성이 향상될 수 있습니다.
하지만 이 경우 애플리케이션 로직에서 데이터 무결성을 보장해야 하는 책임이 증가하게
됩니다.



1. 자동 증가 필드 (AutoField)
설명: 기본 키로 많이 사용되는 정수형 필드. 자동으로 1씩 증가하는 값을 데이터베이스에서 할당받음.
기본 키 설정: 기본적으로 id 필드가 자동으로 생성됨.
예시: BigAutoField (8바이트), AutoField (4바이트)

2. 숫자 필드 (Numeric Fields)
IntegerField, SmallIntegerField, BigIntegerField: 정수 필드.
PositiveIntegerField: 양의 정수만 허용.
FloatField: 부동소수점 수 필드 (정확성 문제 발생 가능).
DecimalField: 고정소수점 수 필드 (정확한 소수점 계산 필요 시 사용).

3. 문자열 필드 (String Fields)
CharField: 길이가 제한된 문자열 필드 (최대 길이 설정 필수).
TextField: 길이 제한이 없는 텍스트 필드.
SlugField: URL-friendly 문자열.
EmailField, URLField: 이메일과 URL 형식의 문자열 필드.

4. 파일 및 이미지 필드
FileField: 파일을 저장하는 필드.
ImageField: 이미지 파일을 저장하는 필드 (Pillow 라이브러리 필요).
BinaryField: 파일 데이터를 바이너리 형태로 저장하는 필드.

5. 날짜/시간 필드 (Date/Time Fields)
DateField: 날짜만 저장 (연/월/일).
TimeField: 시간만 저장 (시/분/초).
DateTimeField: 날짜와 시간 저장.
DurationField: 시간의 길이 저장 (예: 2시간 30분).
AutoNow, AutoNowAdd: 모델 객체가 생성/수정될 때 자동으로 날짜/시간이 설정됨.

6. 불리언 필드 (Boolean Field)
BooleanField: 참/거짓 값 저장.
Custom Boolean: 커스텀 필드를 만들어 Y/N 등의 값으로 저장할 수도 있음.

7. 기타 필드
GenericIPAddressField: IP 주소 저장 (IPv4/IPv6 지원).
JSONField: JSON 데이터를 저장 (SQLite에서는 문자열로 저장).
UUIDField: 범용 고유 식별자(UUID) 저장.

8. 관계 필드 (Relation Fields)
ForeignKey (Many-to-One): 여러 개의 객체가 하나의 객체와 관계를 맺을 때 사용.
OneToOneField (One-to-One): 두 객체 간 일대일 관계를 설정.
ManyToManyField: 여러 객체 간 다대다 관계 설정.

9. 기타 설정
Null, Blank 옵션: 데이터베이스에서 값이 없을 수 있는 필드를 지정. 문자열의 경우 Null=True는 사용하지 않는 것이 권장됨.
default: 필드의 기본 값을 설정.
editable: 모델에서 필드가 사용자에 의해 수정될 수 있는지 여부를 설정.
validators: 필드 값에 대해 유효성 검사를 추가.

10. 커스텀 필드
장고 모델 필드는 사용자 정의 필드를 통해 새로운 필드를 만들어 사용할 수 있으며, 데이터 유효성 검사 및 관리가 용이해짐.
예시: 주민번호 필드, 휴대폰 번호 필드 등.

11. 파일 업로드 관리
FileField, ImageField를 통해 파일을 데이터베이스 외부 (파일 시스템)에 저장하고, 데이터베이스에는 해당 파일 경로만 저장.

12. 기타 중요한 필드
PathField: 파일 경로를 저장할 수 있는 필드.
ForeignKey에서 db_constraint=False: 외래키 제약을 비활성화하여 데이터베이스의 성능을 개선할 수 있음.

정리
장고의 모델 필드는 데이터베이스의 다양한 데이터를 효율적으로 저장할 수 있도록 다양한 종류가 제공되며, 각 필드는 데이터베이스 타입에 맞춰 최적화되어 사용될 수 있습니다. 
모델 필드들을 적절히 사용하여 데이터베이스 관계를 정의하고, 데이터의 유효성 검사를 통해 애플리케이션의 안정성과 유지보수성을 향상시킬 수 있습니다.