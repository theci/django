안녕하세요 이번 시간에는 커스텀 모델 매니저에 대해서 살펴보겠습니다
포스트 모델에는 Status 필드가 있고요 포스팅의 상태를 초안과 발행으로 구분하고
있습니다 이를 기반으로 여러 뷰 함수에서는 공개된 포스팅, 발행 상태의 포스팅에 대해서만
조회, 수정, 삭제 작업을 수행하며 새로운 포스팅 생성 시에는 기본적으로 발행 상태로
설정하려고 합니다
현재 각 뷰 함수에서 같은 조건을 가진 쿼디셋 코드가 반복적으로 사용되고 있습니다
비록 현재 조회 조건은 단순하지만 이러한 코드의 반복은 유지 보수를 어렵게 만들 수 있으며
향후 더 복잡한 조회 조건이 도입될 때 그 문제는 더욱 커질 수 있습니다
이와 같은 쿼리셋 코드의 반복을 효율적으로 줄이기 위한 방법으로 공통적인 쿼리셋 로직을
커스텀 모델 매니저의 메소드로 구현하는 방법이 있습니다.
이 방법을 사용하면 복잡한 쿼리셋 로직을 모델 매니저 내에 한 번만 정리하고 필요할 때마다
재사용할 수 있습니다.
이렇게 하면 코드의 중복을 줄이고 유지 보수를 용이하게 할 수 있으며 전체 애플리케이션
코드의 일관성을 높일 수 있습니다.
커스텀 모델 매니저를 구현하는 첫 번째 방법은 매니저 클래스를 상속받아
getQuerySet 메서드를 오버라이딩 하는 것입니다.
이를 통해 기본 QuerySet에 추가적인 조회 조건을 포함시킬 수 있습니다.
포스트 모델 클래스에는 published 라는 이름의 클래스 변수로 이 커스텀 모델
매니저를 등록합니다.
모델 매니저인 objects를 덮어 쓰지 않는 것이 중요합니다.
기본 모델 매니저인 Object를 덮어 쓰지 않는 것이 중요합니다.
Object를 덮어 쓰게 되면 Post 모델을 통한 모든 조회가 발행 상태의
Posting으로 제한됩니다.
이는 발행 상태가 아닌 Posting의 조회를 불가능하게 만들 수 있습니다.
따라서 Object가 아닌 다른 이름으로 Custom Model Manager를 등록하는
것이 맞습니다.
Custom Model Manager를 등록하면 기본 Model Manager,
objects가 자동으로 추가되지 않습니다.
기본 조건에 Model Manager를 등록하도록 합니다.
이제 Vue에서는 post.object.all을 사용하여 모든 포스팅을 조회할 수 있으며,
post.published.all 을 사용하면 published, PostManager
클래스의 get-codeset 메서드를 통해 생성된 발행 상태의 조건이 추가된 쿼리셋을
얻을 수 있습니다.
포스팅을 생성할 때에는 post.published.create 함수를 호출하면
published, post-manager 클래스의 create 함수가 생성되고,
status 인자가 없을 경우에 공개 상태로 인자가 지정되어 생성됩니다.
이렇게 뷰에서 복잡한 쿼디셋 로직을 반복 작성 없이 모델 매니저를 통해 간결하고 명확하게
데이터를 관리할 수 있습니다.
블로그의 model.py 파일을 여시고요.
매니저 클래스를 상속받은 PublishedPostManager 클래스를 정의하십니다.
그리고 getQuerySet 메서드를 이렇게 오블라이딩 합니다.
쿼리셋을 받고요 여기에다가 이 매니저만의 조회 조건을 추가해 주겠습니다
QS Filter에서 Status Field가 Post Model의 Status 선택지에서
Published 조건을 이렇게 지정해 주는 거죠
그러면 이 매니저로부터 생성된 코디셋은 항상 이 조건이 추가가 되어 있습니다
Post 모델에 Published라는 이름으로 매니저를 추가해 주고요 모델 클래스에
Custom Model Manager를 추가하면 Object라는 이름의 모델 매니저가 자동
추가되지 않으니까 Object 모델 매니저도 이렇게 추가를 해 주겠습니다
소스 파일 저장하시고 장고 쉘을 구동하시고요
이제 first model 클래스가 있습니다
object.all 하시면 수행된 SQL 코디에서 외열 조건이 없죠
모든 데이터를 조회하는 것이고요 post.published.all 하시면 이렇게 조회
조건에서 발행 상태가 추가가 된 것을 확인을 하실 수 있습니다
이어서 생성을 위해서요 create라는 이 함수를 재정의를 해 주겠습니다
부모에 create를 그대로 호출을 해 줄 텐데 키워드 아규먼트에서 setDefault로
status 인자가 없을 때 이 값을 default로 적용하도록 setDefault 함수를
호출해 주겠고요 그리고 부모에 그대로 인자를 넘겨 주겠습니다
하단의 셀을 끄고, 그리고 다시 들어가시고요
이제 first.objects.create가 있고요 이렇게 실행을 하시면, Status가
D라고 나오죠 즉, 초안으로 들어가게 됩니다
왜냐하면, Status 필드의 Default가 초안이니까요 이제
first.published.create 하시고, title의 제목, content의
내용이라고 하시면 스태터스 필드에 P가 들어가 있음을 확인하실 수 있습니다
커스텀 모델 매니저를 구현하는 두 번째 방법은 쿼리셋 클래스를 상속받아 쿼리셋 메서드를
구현하고 as 매니저 호출 통해 모델 매니저로 변환하여 등록합니다
이 방법은 기본 쿼리셋을 변경하지 않고 메서드 우출로 조회 조건을 추가하므로 Object
이름으로 덮어 써도 괜찮습니다.
이 방법으로 다양한 조회 조건을 가진 쿼리셋 메서드들을 구현하고, 메서드 체이닝을 사용하여
여러 조회 조건을 간결하게 적용할 수 있습니다.
post.objects.all()을 사용하면 모든 포스팅을 조회할 수 있으며,
post.objects.published를 사용하면 발행 상태의 포스팅만 조회할 수
있습니다. 또, 체이닝을 통해 post.objects.published.filter, 맛집과
같은 코드로 발행 상태의 포스팅 중에 제목에 맛집이 포함된 포스팅만을 찾을 수 있습니다.
이러한 체이닝 방식은 복잡한 코디 조건을 명확하고 간결하게 표현할 수 있도록 도와줍니다.
이렇게 커스텀 코디셋과 매니저를 사용함으로써 코디로직을 중복 없이 재사용하고 코드의
가독성을 높일 수 있습니다.
블로그의 모델스 파일에서 포스트 코디셋 이름의 클래스를 추가하고요.
코디셋 클래스를 상속받습니다.
앞서 정의한 매니저 클래스는 삭제하겠고요.
PostModel 클래스에 추가한 2개 클래스 변수로 주석 처리하겠습니다
그리고 Object란 이름으로 PostCodicet.Manager를 통해서
CustomModelManager를 등록합니다
PostModel 클래스의 쿼리셋은 PostCodicet을 통해서 제공을 받게 됩니다
여기에 Filter나 Exclude나 OrderBy나 다양한 코디셋 메서드가 있고요 그
메서드에 추가해서 저는 Published라는 임의의 메서드를 추가해 주려고 합니다
현재 self는 코디셋 객체이니까 self.filter, exclude 등등이 있어요
여기에 StatusField가 post.status 선택지에서 published인 조건을
추가한 코디셋이죠
이 코디셋을 이렇게 반환을 해주고요
이어서 이번에는 draft, 즉 초안인 조건만 보고 싶어요 복사해서 여기도 draft라고
넣어주겠으며 이번에는 이제 검색을 위해서 검색에 대한 query를 받을 수 있죠
여기에는 똑같이 필터에서, 타이틀에서 contents, query가 포함된 것만 이번에는
이제 작성자 필드가 있다면 지금은 아래에 작성자 필드가 없어요
근데 작성자 필드가 있다면 그에 대해서 우리가 이런 식으로 조회 조건을 넣어 주실 수
있습니다
Create 함수에서 Keyword 인자로 PostModel 인스턴스 생성에 사용되는 모델
필드 목록을 받을 텐데 그 목록에서 만약에 Status 인자가 없다면
post.status.published 값으로 default 값을 지정하고요 그리고 부모의
Create를 호출해서 생성을 처리하겠습니다
그러면 구현이 끝났고요 장고 셀을 구동하신 다음에 first.object.all 하시면
이렇게 외열 조건 없이 데이터베이스에 저장된 전체가 조회가 되고요
first.object.published라고 하시면 이렇게 조회 조건으로 발행이 추가가
되었죠
.search에 맛집이라고 넣으시면 외열자들의 앞선 published 조건 플러스 맛집
조건이 이렇게 추가가 된 것을 확인을 하실 수 있습니다



이번 시간에는 커스텀 모델 매니저에 대해 학습하였으며, 이를 통해 쿼리셋을 효율적으로 관리하고 반복되는 코드의 중복을 줄이는 방법을 다뤘습니다. 아래는 주요 개념과 코드 구현을 정리한 내용입니다.

1. 커스텀 모델 매니저란?
커스텀 모델 매니저는 모델의 기본 동작을 확장하여, 복잡한 쿼리 로직을 캡슐화하고 재사용할 수 있는 방법입니다.
이를 사용하면 특정 조건에 맞는 데이터를 쉽게 조회할 수 있으며, 코드의 중복을 줄이고 유지보수를 용이하게 할 수 있습니다.

2. 커스텀 모델 매니저 구현 방법
방법 1: get_queryset() 메서드 오버라이딩
기본 모델 매니저인 objects를 덮어쓰지 않고, 새로운 매니저를 정의하여 특정 조건을 가진 쿼리셋을 제공할 수 있습니다.
get_queryset()을 오버라이딩하여 조건에 맞는 데이터를 반환하도록 합니다.

PublishedPostManager 정의:
get_queryset()을 오버라이딩하여 status가 PUBLISHED인 조건을 추가합니다.
from django.db import models

class PublishedPostManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(status=Post.Status.PUBLISHED)


모델에 매니저 등록:
기본 매니저인 objects를 덮어쓰지 않고, published라는 이름으로 커스텀 모델 매니저를 등록합니다.

class Post(models.Model):
    class Status(models.TextChoices):
        DRAFT = 'D', 'Draft'
        PUBLISHED = 'P', 'Published'

    title = models.CharField(max_length=200)
    content = models.TextField()
    status = models.CharField(max_length=1, choices=Status.choices, default=Status.DRAFT)
    
    published = PublishedPostManager()  # 커스텀 매니저 등록
    objects = models.Manager()  # 기본 모델 매니저도 필요
쿼리셋 사용 예시:
post.objects.all()로 모든 데이터를 조회하고,
post.published.all()로 PUBLISHED 상태인 포스트만 조회할 수 있습니다.
python
코드 복사
# 모든 포스팅 조회
Post.objects.all()

# 발행 상태인 포스팅만 조회
Post.published.all()
포스팅 생성 시 기본 값 설정:
published.create()를 사용하면 status가 기본적으로 PUBLISHED로 설정됩니다.
python
코드 복사
Post.published.create(title="New Post", content="Content of the post")

방법 2: 쿼리셋 클래스를 상속받아 메서드 체이닝 방식으로 구현
두 번째 방법은 쿼리셋 클래스를 상속받아 여러 메서드를 체이닝하여 조건을 명확하게 추가하는 방식입니다.
get_queryset()을 오버라이딩하는 대신, QuerySet 클래스를 상속받아 여러 조건을 메서드 체이닝으로 처리합니다.
PostQuerySet 정의:
QuerySet 클래스를 상속받아 여러 쿼리 메서드를 정의합니다. 예를 들어, published 메서드를 정의하여 status가 PUBLISHED인 포스팅만 조회하도록 합니다.
class PostQuerySet(models.QuerySet):
    def published(self):
        return self.filter(status=Post.Status.PUBLISHED)
    
    def draft(self):
        return self.filter(status=Post.Status.DRAFT)
    
    def search(self, query):
        return self.filter(title__icontains=query) | self.filter(content__icontains=query)

Post 모델에 커스텀 쿼리셋과 매니저 등록:
Post 모델에서 QuerySet을 사용하려면 PostManager를 정의하여 이를 모델에 등록합니다.
class Post(models.Model):
    class Status(models.TextChoices):
        DRAFT = 'D', 'Draft'
        PUBLISHED = 'P', 'Published'

    title = models.CharField(max_length=200)
    content = models.TextField()
    status = models.CharField(max_length=1, choices=Status.choices, default=Status.DRAFT)

    objects = PostQuerySet.as_manager()  # 커스텀 쿼리셋을 매니저로 등록

쿼리셋 사용 예시:
post.objects.published.all()로 발행 상태인 포스팅만 조회할 수 있으며, 체이닝을 통해 다양한 조건을 추가할 수 있습니다.
# 발행 상태인 포스팅 조회
Post.objects.published()

# 발행 상태인 포스팅 중 제목에 '맛집'이 포함된 포스팅만 조회
Post.objects.published().search('맛집')


포스팅 생성 시 기본 값 설정:
create() 메서드에서 status 값을 기본값으로 설정하려면, create() 메서드를 오버라이딩하여 status가 없을 때 기본적으로 PUBLISHED로 설정하도록 합니다.
class PostQuerySet(models.QuerySet):
    def create(self, **kwargs):
        if 'status' not in kwargs:
            kwargs['status'] = Post.Status.PUBLISHED  # 기본 상태를 PUBLISHED로 설정
        return super().create(**kwargs)

3. 요약 및 장점
중복 코드 제거: 커스텀 모델 매니저를 사용하면 여러 뷰에서 반복적으로 사용하는 복잡한 쿼리 로직을 한 번만 정의하고 재사용할 수 있어 코드 중복을 줄일 수 있습니다.
가독성 향상: 체이닝 방식으로 쿼리 조건을 추가하면 복잡한 쿼리를 명확하고 간결하게 표현할 수 있습니다.
유지보수 용이: 쿼리 로직이 모델 매니저에 집중되므로, 나중에 쿼리 조건을 변경할 때 코드의 일관성을 유지하면서 쉽게 수정할 수 있습니다.
기본 모델 매니저와 구분: objects 매니저를 덮어쓰지 않거나, 기본 매니저와 별도로 커스텀 매니저를 등록하여 다양한 조회 방식에 대응할 수 있습니다.
이렇게 커스텀 모델 매니저를 활용하면 복잡한 쿼리셋 로직을 한 곳에서 관리하고, 코드의 재사용성과 가독성을 높이며, 나아가 유지보수를 쉽게 할 수 있습니다.