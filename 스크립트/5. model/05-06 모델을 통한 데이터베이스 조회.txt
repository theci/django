안녕하세요 이번 시간에는 모델을 통한 데이터베이스 조회입니다
쿼리셋은 장고 ORM의 일부로서 데이터베이스에서 데이터를 조회하고 필터링하는 방법을 제공하는 객체이며
파이썬 코드를 사용해 데이터베이스 작업을 간편하게 할 수 있도록 도와줍니다 
모델 클래스를 쿼리셋 클래스의 생성자로 넘겨 쿼리셋 객체를 생성하실 수 있습니다
혹은 모델 클래스의 디폴트 모델 매니저인 objects 속성을 통해 Song 모델의 QuerySet 클래스를 생성할 수도 있습니다.
이 방식이 일반적인 접근입니다.
QuerySet은 지연 평가되는 특성이 있습니다.
데이터를 조회할 준비를 하고, 데이터가 필요한 시점에 게으르게 데이터베이스 조회를 수행합니다.
쿼리셋의 데이터 조회 조건을 지정하여 데이터 검색을 할 수 있으며, 
쿼리셋의 Filter, Exclude, Order By 등의 메서드는 해당 조건이 반영된 쿼리셋 객체를 반환하므로 체이닝을 통해 복잡한 쿼디를 만들 수 있습니다.
아래 필터 호출에서는 랭크 컬럼의 값이 10 이하인 조회 조건을 추가했으며, 
이 조회 조건이 추가된 쿼리셋을 같은 이름의 쿼리셋 객체에 할당했습니다.
파이썬 매니저 쉘 플러스 프린트 SQL 명령으로 실행된 장고 쉘에서는 데이터베이스 조회가 발생하면 수행된 SQL 내역이 화면에 즉시 출력되는데요.
아직 출력된 SQL이 없습니다.
즉, 데이터베이스 조회가 아직 없었다는 거죠
쿼리셋의 지연평가 특성을 이렇게 확인했습니다
쿼리셋에 dance 장르 조회 조건을 추가하고 for 반복문으로 쿼리셋을 순회돕니다
이제 데이터가 필요한 시점이기에 데이터베이스 조회가 발생합니다 수행된 쿼리 내역에서도 rank 컬럼이 10 이하인 조건과 장르 컬럼이 dance인 조건이 서로 end 조건으로
적용되어 있음을 확인하실 수 있습니다
쿼리셋 클래스를 통해 직접 쿼리셋 객체를 생성하실 수도 있지만, 대개 모델 매니저가 생성해 준 쿼리셋 객체를 사용하게 됩니다.
모델 매니저는 모델 클래스의 Object 속성이며, .all 함수 호출을 통해 기본 쿼리셋을 생성합니다.
모델 매니저에서는 쿼리셋을 생성해 주는 것 뿐만 아니라 쿼리셋을 활용하는 각종 유틸리티 메서드로 지원해 주는데요 커스텀
모델 매니저에 대해서는 이후 에피소드에서 살펴보겠습니다
데이터 조회가 발생하는 시점은요 쿼리셋은 데이터를 조회할 준비를 하고 데이터가 필요한 시점에 조회합니다. 조회합니다
모델 클래스의 디폴트 모델 매니저인 Object를 통해서 모델 클래스에 대한 쿼리셋을 생성했습니다
첫 번째 예시로서, 쿼리셋 객체를 프린트 함수로 출력하거나, 파이썬 쉘에서 쿼리셋 객체를 실행하면, 쿼리셋 객체를 평가하는 과정에서 데이터베이스 조회가 발생합니다.
두 번째로, 쿼리셋 객체를 다른 타입으로 변환할 때에도 데이터베이스 조회가 발생하고요.
세 번째로, 쿼리셋 객체를 순회해 놓을 때에도 데이터베이스 조회가 발생합니다.
쿼리셋에서는 집계 함수를 지원해 주는데요
집계 함수는 지원평가되지 않고 함수가 호출될 때 즉시 실행되어 결과를 제공합니다
집계 함수는 데이터베이스의 데이터를 지정 기준으로 요약하고 계산하는 기능을 제공합니다
예를 들어 데이터베이스에 저장된 여러 행의 데이터를 기반으로 평균, 합계, 최대값, 최소값 계산을 데이터베이스에 요청합니다.
쿼리셋의 COUNTER 함수를 통해 쿼리셋 조건에 매칭되는 행의 개수를 요청할 수 있고요.
.aggregate 함수는 조건에 해당하는 행 전체에 대한 집계 연산을 수행하여 단일 결과 값을 반환합니다.
행 전체의 총 개수, 평균 가격, 전체 주문의 총합 등을 계산할 때 사용할 수 있습니다.
쿼리셋의 Annotate 함수는 각 행 또는 객체에 대한 집계 연산을 수행하고 원본 쿼리셋에 추가 정보를 부여합니다 그룹별로 총 개수, 평균 가격, 주문의 총합 등을 계산할
때 사용할 수 있습니다
쿼리셋에서 .values_list 함수는 특정 필드에 대한 값들을 리스트 형태로 반환합니다.
PK, 즉 기본 키만 조회해서 어떤 순서로 조회되는지 확인해 보겠습니다.
데이터베이스의 SELECT 쿼리를 실행할 때 정렬을 지정하지 않으면 데이터가 저장된
물리적인 위치나 데이터베이스의 데이터 저장 메커니즘에 따라 무작위 순서로 데이터가 조회될 수 있습니다. 
정렬 방향을 지정해야만 일관된 순서로 데이터를 조회할 수 있어요
쿼리셋에서는 ORDER BY 함수를 통해 정렬 방향을 지정할 수 있습니다
필드명만을 쓰면 오름차순 정렬이고요
필드명 앞에 하이픈을 붙이면 내림차순 정렬로 쿼리가 생성됩니다
두 번째 코드에서는 PK 필드에 대한 내림차순을 지정했고 세 번째 코드에서는 PK 필드에 대한 오름차순을 지정했습니다
이렇게 지정된 정렬 순서로 데이터를 조회할 수 있습니다
한 모델에 대해 하나의 정렬 방향이 정해지면 그 정렬 방향을 일관되게 사용하게 됩니다
그런데 정렬 방향을 매번 지정하는 것은 매우 번거롭죠
그리고 정렬 순서를 바꾸고자 할 경우에는 해당 코드를 모두 찾아서 수정해줘야 하는 번거로움이 있습니다
장고 모델 클래스의 메타 클래스의 Ordering 옵션을 통해 Default 정렬을 지정할 수 있습니다 
디폴트 정렬을 지정하면 매번 정렬 방향을 지정하지 않아도 일관된 정렬 방향을 얻으실 수 있습니다
그리고 정렬 방향을 바꿔야 할 때는 쿼리셋에 정렬 방향을 지정하시면 디폴트 정렬 옵션은 무시됩니다 참
영리하죠?
쿼리셋에서는 슬라이드 문법으로 조회 범위를 지정할 수 있습니다.
SQL 쿼리의 limit-offset 절에 적용됩니다.
문자열, 리스트 튜플 등에서의 슬라이드 문법과 유사하지만 다르게 동작하는 부분이 있습니다.
첫 번째로 리스트에서는 시작 인덱스를 10, 끝 인덱스를 20, 인덱스 증가량을 1로 지정하면 이렇게 11부터 20까지의 값을 조회할 수 있습니다.
쿼리셋에서도 2와 유사하게 시작 인덱스 10, 끝 인덱스 20을 지정하여 SQL 쿼리에 limit 10, offset 10이 적용되어 조회됩니다.
offset 값은 시작 인덱스의 값이 그대로 전달되고요 limit 값은 끝 인덱스 값에서 시작 인덱스 값을 뺀 값이 그대로 쿼리 적용됩니다
두 번째로 리스트에서는 인덱스 증가량을 키워 해당 증가량만큼 건너뛰어 값을 줘야 할 수 있습니다 
쿼리셋에서도 비슷하게 동작하지만 인덱스 증가량은 데이터베이스 쿼리에는 반영되지 않습니다 
즉, 시작 인덱스, 끝 인덱스 범위의 레코드를 모두 조회한 다음에 인덱스 증가량만큼 건너뛴 모델 인스턴스를 반환합니다
만약 조회 범위를 아주 크게 지정하고 인덱스 증가량도 크게 지정할 경우 애플리케이션에서 사용하지 않을 대량의 불필요한 조회가 발생하게 되죠
그러니 이때에는 조회 조건을 변경할 필요가 있을 것입니다
세 번째로, 리스트에서는 거꾸로 조회를 위해 인덱스 증가량을 음수를 지정할 수 있습니다
이때 시작 인덱스 값이 끝 인덱스 값보다 작으면 음수 인덱스 증가량이 성립되지 않아요
그래서 빈 리스트를 반환합니다
하지만 쿼리셋에서는 시작 인덱스 값과 끝 인덱스 값은 인덱스 증가량 값과는 상관없이 limit, offset 절에 그대로 반영이 되어 레코드를 조회합니다
음수 인덱스 증가량 값은 반환되는 모델 인스턴스의 방향과 그리고 건너뛸 그 간격만 결정합니다 
그래서 "-1"을 지정하면 거꾸로 반환됩니다. 거꾸로 반환이 됩니다
리스트에서 거꾸로 반환하려면 인덱스 증가량을 양수로 지정하고 조회된 목록을 리버스트 함수를 통해 역순으로 순회를 돌 수 있습니다
파이썬 리스트에서는 시작 인덱스 값을 음수로 지정하여 끝을 기준으로 원하는 개수만큼 범위를 지정할 수 있습니다
이를 쿼리셋에 적용하면 ValueError 예외가 발생하며 음수 인덱스는 지원하지 않는다는 오류 메시지를 만나게 됩니다
리스트와 비슷한 결과를 내려면 정렬 방향을 반대로 지정하고 처음 10개를 조회한 다음 파이썬의 리버스트 함수를 통해 역순으로 순회를 돌 수 있겠습니다.
목록 조회는 데이터베이스에서 여러 레코드를 조건에 따라 선택하여 조회하는 방법입니다
이 과정에서 Song 모델을 예로 들면 다음과 같은 다양한 조회 방법을 사용할 수 있습니다
song.objects.all 호출을 통해 Song 모델에 대한 기본 쿼리셋을 생성합니다
이 초기 쿼리셋은 데이터베이스 Song 테이블에 있는 모든 레코드를 대상으로 합니다
필터 메서드를 사용하여 특정 조건을 만족하는 레코드만 조회할 수 있습니다.
조회 조건을 추가한 쿼리셋을 반환하고요.
한 개 이상의 조건들을 지정하며 추가한 조건들은 모두 AND 조합이 됩니다.
예시 코드에서는 장르가 댄스이면서 순위가 10 이하인 곡만 필터링합니다.
SQL 쿼리의 WHERE 절에 적용이 돼요.
exclude 함수를 사용하여 지정 조건의 반대 조건을 만족하는 레코드만 조회합니다.
그 외에는 필터 함수와 동일하게 동작합니다.
예시 코드에서는 좋아요
수가 5만 이하인 곡을 제외하고요.
SQL 쿼리의 WHERE 절에 적용됩니다.
슬라이싱 문법으로 조회 범위를 지정할 수 있습니다.
SQL Query의 LIMIT, OFFSET 절에 적용됩니다.
단건 조회는 데이터베이스에서 특정 한 개의 레코드를 개별적으로 선택해서 조회하는 방법입니다. 
현재 song 모델에 대한 기본 쿼리셋은 PK, 기본 키 필드에 대한 오름차순 정렬이 되어 있습니다
그 첫 번째, 숫자 인덱스를 통한 조회입니다
50 인덱스를를 적용하면 PK 필드를 기준으로 오름차순 정렬된 현재 쿼리셋에서 51번째 레코드를 즉시 조회합니다
해당 인덱스에 레코드가 없으면 인덱스 에러 예외로 처리됩니다
두 번째, 음수 인덱스는 데이터베이스에서 지원하지 않고요 ValueError 예외를 발생합니다 
세 번째로, .get 함수를 통해 현재 쿼리셋에서 조회 조건을 더 추가할 수 있고요 
해당 조회 조건에 한 개의 레코드를 즉시 조회합니다
한 개의 레코드 조회 시에 자주 사용하는 함수입니다.
.get 함수는 지정 조건에 한 개의 레코드를 예상하고 동작합니다.
만약 지정 조건에 조회된 레코드가 없거나 두 개 이상의 레코드가 조회된다면 예외로 처리합니다. 
조회된 레코드가 없으면 doesNotExist 예외를 발생시키며, 두 개 이상이 조회된다면 MultipleObjectsReturned 예외를 발생시킵니다.
get 함수를 사용할 때 주로 does not exist 예외를 처리하게 됩니다.
네 번째로, first 함수와 last 함수는 지정 정렬 방향에서 지정 조건의 레코드를 한 개만 조회하고, 레코드가 없다면 예외를 발생시키지 않고 none을 반환합니다.
이 부분이 get 함수와 다른 동작이고요.
get 함수는 추가 조회 조건을 인자로 받을 수 있지만, first, last 함수는 인자를 지원하지 않습니다.
그리고 first 함수와 last 함수를 호출한 쿼리셀에서 정렬 조건을 지정하지 않았다면 default로 기본 키 field로 정렬 기준을 적용하여 조회합니다.
filter 함수, exclude 함수, get 함수에 지정한 조회 조건들은 모두 논리 & 조합으로 처리됩니다.
OR 조건을 지정하려면 Q 객체로 조건을 지정해야 합니다 필터, Exclude, Get 함수는 Q 객체로 조회 조건을 전달받을 수 있습니다
Q 객체는 비트 연산자 AND, OR, NOT을 지원하고요 각 연산자를 적용한 새로운 Q 객체를 반환합니다
두 개의 Q 객체를 AND 연산자로 묶으면 AND 조합으로 새로운 Q 객체가 생성이 되고요
두 개의 Q 객체를 OR 연산자로 묶으면 OR 조합으로 새로운 Q 객체가 생성되며 한 개의 Q 객체를 NOT 연산자를 지정하면 반대 조건에 새로운 Q 객체가 생성됩니다
비트 연산자와 파이썬의 논리 연산자는 서로 다른 연산자임에 주의하시고요
Q 객체에는 파이썬의 논리 연산자를 사용해서는 안 됩니다
파이썬의 AND 논리 연산자는 앞값을 먼저 평가해서 참 판정을 받으면 뒷값을 평가하고 뒷값을 반환하고요 거짓 판정을 받으면 앞값을 반환합니다
그러니 Q 객체에 적용하면 Q 객체는 참 판정을 받거든요
그럼 비트 연산자와는 다른 결과로서 뒤에 Q 객체가 반환됩니다
파이썬의 OR 논리 연산자는 앞에 값을 먼저 평가하여 거짓 판정을 받으면 뒷값을 평가하고 반환하며 참 판정을 받으면 앞값을 반환합니다
그러니 Q 객체에 적용하면 Q 객체는 참 판정을 받거든요
그럼 비트 연산자와는 다른 결과로서 앞에 Q 객체가 반환됩니다
파이썬의 not 논리 연산자는 논리적 부정을 수행합니다
어떤 값이든 논리 부정을 수행하여 참 혹은 거짓 값을 반환합니다
그러니 Q 객체에 적용하면 false 값이 반환이 됩니다
목록 조회 뷰에서의 일반적인 조회 예시를 살펴보겠습니다
songlist 함수 기반 뷰에서 기본 쿼리셋을 생성하고 검색어가 있다면 필터 함수를 통해 조회 조건을 추가한 쿼리셋을 생성합니다
페이징 처리에서는 범위 조건을 지정하여 페이징 처리를 하실 수 있습니다
물론 이는 예시일 뿐 페이징 처리에서는 Paginator 클래스를 활용하시면 편리합니다.
SongListView 클래스 기반 뷰에서는 쿼리셋 속성으로 기본 쿼리셋을 지정하고 매 뷰 요청 시마다 조회 조건이 변경된다면 getCordiSet 메서드를 재정리하여 동적으로
쿼리셋을 변경할 수 있습니다.
ListView에서는 PaginateBy 속성 지정만으로 페이징 처리가 기본적으로 지원됩니다. 
디테일 뷰에서의 일반적인 조회 예시입니다.
댄스 곡에 한해서 PK를 인자로 받아서 조회합니다.
쿼리셋의 get 함수를 통해 조회할 경우, 지정 PK의 레코드가 없을 경우, does not exist 예외가 발생합니다.
이 예외를 뷰 함수에서 처리하지 않으면 500 응답인 서버 오류로 처리가 됩니다.
지정 레코드가 없는 상황은 데이터가 없거나 조회가 안 되는 것일 뿐 서버 오류인 것은 아닙니다. 
그러니 반드시 does not exist 예외 처리를 하고 404 응답 처리를 하는 것이 맞습니다.
그런데 매번 does not exist 예외에 대한 예외 처리를 하는 것이 번거롭죠
그래서 이를 간결하게 도와주는 유틸리티 함수로 getObjectOr404 쇼클 함수가 있습니다 
첫 번째 방법의 코드와 동일한 처리를 해줍니다
첫 번째 인자로 모델 클래스를 받으면 디폴트 쿼리셋을 생성해서 조회를 수행하며 쿼리셋을 인자로 받으면 그 쿼리셋을 활용하여 조회를 수행합니다
디테일 뷰, 클래스 기반 뷰에서는 내부에서 PK 혹은 Slug에 대해 조회를 수행하는 코드가 이미 구현되어 있습니다
PK 혹은 슬러그 조회가 수행되기 전에 쿼리셋만 만들어주면 됩니다
쿼리셋 속성으로 고정 조건의 쿼리셋을 지정할 수 있고요
뷰 호출 시마다 조회 조건이 변경이 되는 경우 getCoderset 메서드를 재정의해서 구현할 수 있습니다
댄스곡 조회 조건은 고정 조건이기 때문에 쿼리셋 속성 지정만으로 충분합니다
쿼리셋은 기본적으로 모델 단위로 관계 필드를 제외한 모든 필드를 한 번에 조회합니다
데이터가 아주 큰 필드가 있고 그 필드가 현재 뷰에서 사용되지 않을 때 모든 필드를 조회하는 것은 비효율적일 수 있습니다
예를 들어 Songlist 응답에서 가사 필드를 노출하지 않는다고 가정해 보겠습니다
만약 데이터베이스의 가사 데이터가 곡당 100KB라고 한다면 10곡을 조회하는 것만으로
1MB의 데이터베이스 부하와 네트워크 트래픽이 발생하며 메모리 사용량도 증가합니다
이러한 상황에서 쿼리셋의 ONLY 메서드를 사용하면 조회할 필드만 지정할 수 있고요 그리고
DIPPER 메서드를 통해 조회하지 않을 필드를 지정할 수 있습니다
예를 들어 only 메서드로 name 필드만 지정하면 기본 키인 id 필드와 name
필드만 조회됩니다.
생성된 모델 인스턴스에서 .name 속성에 접근할 때에는 이미 조회된 필드이므로 추가
코디가 발생하지 않습니다.
하지만 artistName 같은 나머지 필드들은 처음 코디에서 조회가 되지 않았으므로 이
필드에 처음 접근할 때 추가 코디가 발생합니다.
이 함수들을 잘못 사용할 경우 M++ 문제가 발생할 수 있습니다.
이는 각 모델 인스턴스에 대해 추가적인 쿼리가 필요해져서 전체적으로 많은 수의 데이터베이스
쿼리가 발생하는 상황을 말합니다.
only와 default 메서드를 사용할 때에는 주의가 필요합니다
필요한 필드만 정확히 선택하여 쿼리를 최적화하는 것이 중요하겠고요 과도한 초기 최적화보다는
점진적인 최적화를 권장합니다
애플리케이션의 성능을 모니터링하고 실제 성능 문제가 발생하는 부분에 대해서만 적절히
최적화를 적용하는 것이 효과적이고요 장고 디버그 툴바 같은 도구를 사용해서 실제 수행되는
쿼리를 확인하고 성능 개선의 필요성을 판단하는 것이 좋습니다 레코드의 개수를 셀 목적으로
리스트에 length 함수를 적용하듯이 쿼리셋에 length 함수를 사용하면 지정 조건의
레코드를 모두 조회하고요.
모델 인스턴스를 생성하고 리스트를 구성한 다음에 리스트의 크기를 반환합니다.
레코드의 개수만을 센다면 이는 아주 비효율적인 접근입니다.
쿼리셋에 COUNTER 함수를 호출하면 데이터베이스에게 개수 세기를 요청합니다
데이터베이스에서 레코드의 개수만 계산하고 그 결과를 반환하므로 메모리 사용이 적고 빠른
처리가 가능합니다
아주 큰 데이터베이스 테이블의 경우 두 번째 방법에서도 데이터베이스에서 시간이 많이 소요될
수 있습니다 참고로 아주 큰 데이터베이스 테이블의 경우 두 번째 방법에서도 데이터베이스에서
시간이 많이 소요될 수 있습니다 데이터베이스에 따라 캐싱이나 총 개수에 근사치를 제공하는
방법을 고려해 볼 수도 있겠습니다.
지정 조건의 데이터 유무를 검사할 때는요.
쿼리셋에 불 함수를 적용하면 지정 조건의 데이터를 모두 조회하고 불필요하게 song
인스턴스를 모두 생성한 후에 리스트 크기를 통해 참 혹은 거짓을 반환합니다.
데이터 유무만을 확인하기에는 일반적으로 비효율적인 접근입니다.
쿼리셋에 exist 함수를 호출하면 데이터베이스에게 데이터의 존재 유무 확인을 요청합니다
데이터베이스에서 존재 유무만을 계산하고 그 결과를 반환하므로 메모리 사용이 적고 빠릅니다
사용 예시로써 조회 데이터가 있을 경우에 반복문을 실행하는 장고 템플릿에서 자주 사용하는
패턴입니다 쿼리셋의 if 조건절에서 데이터베이스 조회가 이루어지고 쿼리셋 객체의
__result__cache 속성으로 조회 내역이 캐싱됩니다
캐싱된 내역은 쿼리셋 방법문에서 사용되므로 추가적인 쿼리가 발생하지 않습니다 보다
명시적인 코드로서 if 조건절에서 exist 함수를 호출해서 데이터베이스 상에서 데이터
유무를 먼저 검사하고 데이터가 존재할 경우에만 조회를 수행하도록 합니다
이 두 방법 중 어느 것이 정답이라고 할 순 없습니다
중요한 것은 각 방법의 특징을 이해하고 애플리케이션의 요구 사항과 상황에 맞게 적절히
선택하는 것입니다
예를 들어 데이터가 매우 크거나 조회 비용이 높은 경우에는 Exist 함수를 사용하는 것이
바람직할 수 있겠고요
반면 데이터를 반복적으로 활용하거나 캐싱이 유리한 상황에서는 전체 데이터 조회가 더
효율적일 수도 있습니다



장고 ORM을 통한 데이터베이스 조회
장고의 ORM(Object-Relational Mapping)을 사용하면, 데이터베이스를 SQL을 직접 작성하는 대신 파이썬 코드를 통해 간편하게 다룰 수 있습니다. 
이를 통해 데이터를 조회하고 필터링하는 다양한 방법을 제공합니다.

1. 쿼리셋(QuerySet)
쿼리셋은 데이터베이스 조회를 위한 객체로, 지연 평가(lazy evaluation) 특성을 가집니다. 이는 쿼리셋을 호출해도 실제로 데이터베이스에 접근하지 않고, 
데이터가 실제로 필요할 때에만 조회가 발생하는 방식입니다.

쿼리셋 생성: 모델 클래스의 기본 매니저인 objects를 사용해 쿼리셋을 생성합니다.
python
코드 복사
songs = Song.objects.all()
지연 평가 확인: 쿼리셋을 출력하거나 반복문을 통해 순회하면, 그때 데이터베이스 조회가 발생합니다.


2. 쿼리셋 메서드
쿼리셋은 다양한 메서드를 제공하여 데이터 조회 및 필터링을 할 수 있습니다.

filter: 조건에 맞는 데이터를 반환합니다.
python
코드 복사
songs = Song.objects.filter(genre='dance', rank__lte=10)
exclude: 조건에 맞지 않는 데이터를 반환합니다.
python
코드 복사
songs = Song.objects.exclude(likes__lte=5)
order_by: 데이터를 정렬합니다.
python
코드 복사
songs = Song.objects.order_by('-rank')  # 내림차순 정렬
values_list: 특정 필드의 값만 리스트로 반환합니다.
python
코드 복사
song_ids = Song.objects.values_list('id', flat=True)


3. 집계 함수(aggregation)
쿼리셋에서 집계 함수는 즉시 실행됩니다. aggregate와 annotate를 사용하여 집계를 수행할 수 있습니다.

aggregate: 조건에 맞는 데이터에 대해 요약된 결과를 반환합니다.
python
코드 복사
from django.db.models import Avg, Max
result = Song.objects.aggregate(Avg('price'), Max('rank'))
annotate: 각 항목에 대해 집계 연산을 수행하고 그 결과를 추가합니다.
python
코드 복사
from django.db.models import Count
songs = Song.objects.annotate(num_reviews=Count('reviews'))


4. 슬라이싱 및 범위 지정
쿼리셋은 슬라이싱 문법을 지원하여 SQL의 LIMIT과 OFFSET과 유사한 방식으로 데이터를 조회할 수 있습니다.

슬라이싱: 조회 범위를 지정할 수 있습니다.
python
코드 복사
songs = Song.objects.all()[10:20]  # 10번째부터 20번째까지
인덱스 증가량: 인덱스 증가량은 데이터베이스 쿼리에는 반영되지 않지만, 파이썬 레벨에서만 영향을 미칩니다.


5. 정렬
order_by: 필드를 기준으로 데이터를 정렬할 수 있습니다. 기본적으로 오름차순이며, 내림차순은 '-'을 사용합니다.

python
코드 복사
songs = Song.objects.order_by('name')  # 오름차순
songs = Song.objects.order_by('-name')  # 내림차순
디폴트 정렬: 모델의 Meta 클래스를 사용하여 기본 정렬을 지정할 수 있습니다.

python
코드 복사
class Song(models.Model):
    # 필드 정의...
    
    class Meta:
        ordering = ['name']  # 기본 오름차순 정렬


6. 단건 조회
get: 특정 조건에 맞는 레코드를 하나만 조회합니다. 조건에 맞는 데이터가 없거나 여러 개가 있을 경우 예외가 발생합니다.

python
코드 복사
song = Song.objects.get(id=1)
예외: DoesNotExist 또는 MultipleObjectsReturned

first / last: 조건에 맞는 첫 번째 또는 마지막 레코드를 조회합니다. 데이터가 없으면 None을 반환합니다.

python
코드 복사
song = Song.objects.first()  # 첫 번째 레코드
song = Song.objects.last()   # 마지막 레코드


7. 조건문과 OR 조건
Q 객체: 여러 조건을 논리 연산자(AND, OR, NOT)로 결합할 수 있습니다.
python
코드 복사
from django.db.models import Q
songs = Song.objects.filter(Q(genre='dance') | Q(rank__lte=10))


8. 데이터 조회 최적화
only / defer: 필요한 필드만 조회하거나 특정 필드를 제외하여 불필요한 데이터를 가져오는 것을 방지할 수 있습니다.

python
코드 복사
songs = Song.objects.only('name')  # name 필드만 조회
songs = Song.objects.defer('lyrics')  # lyrics 필드는 제외
exists: 데이터가 존재하는지 여부만 확인할 때 효율적입니다.

python
코드 복사
exists = Song.objects.filter(genre='dance').exists()


9. 페이징 처리
Paginator 클래스를 사용하거나 ListView에서 paginate_by 속성을 사용하여 데이터 조회에 대한 페이징 처리를 할 수 있습니다.

python
코드 복사
from django.core.paginator import Paginator
songs = Song.objects.all()
paginator = Paginator(songs, 10)  # 한 페이지에 10개씩
page_obj = paginator.get_page(1)


10. 기타 유틸리티 함수
get_object_or_404: 특정 객체를 조회하고, 없으면 404 오류를 발생시킵니다.
python
코드 복사
from django.shortcuts import get_object_or_404
song = get_object_or_404(Song, id=1)

요약
장고 ORM을 통해 다양한 방식으로 데이터베이스 조회를 할 수 있으며, QuerySet을 사용해 데이터를 필터링하고, 정렬하며, 집계 및 페이징을 처리할 수 있습니다. 
ORM의 지연 평가 특성을 이용해 효율적인 쿼리 작성이 가능하며, only, defer, exists 등을 활용해 성능을 최적화할 수 있습니다. 
Q 객체를 이용한 복잡한 조건 조합이나, get, first, last와 같은 단건 조회 방식도 유용하게 사용할 수 있습니다.