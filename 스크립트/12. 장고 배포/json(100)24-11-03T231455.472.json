안녕하세요 이번 시간에는 Nginx 웹서버를 경유해서 장고로 요청을 전달하는 방법에 대해서
살펴보겠습니다 앞서 서비스 아키텍처 시간에 살펴본 다이어그램입니다
엔진엑스 웹서버는 만능 스위스칼처럼 다양한 용도로 사용할 수 있습니다
클라이언트로부터의 요청을 엔진엑스 웹서버가 가장 앞단에서 받아서 정적 파일 URL 의
요청이면 해당 경로의 파일을 읽어서 응답합니다.
장고 서버로 요청을 전달하지 않습니다.
정적 파일 서빙은 엔진엑스가 효과적으로 잘 처리하는 작업 중 하나입니다.
이미지, CSS, JavaScript 파일 등을 빠르게 서빙하여 웹페이지 로딩 속도를 높일
수 있습니다. 두 번째로 정적 파일 URL의 요청이 아닌 그 외의 요청이라면 뒷단의
장고 서버로 요청을 전달하고 그 응답을 받아서 다시 클라이언트에게 전달하는 역할을
하게 하려 합니다.
클라이언트와 장고 서버 간의 중간자 역할을 하는 거죠.
이를 Reverse Proxy라고 합니다.
뒷단의 장고 서버가 여러 대라면 Nginx가 로드 밸런서 역할을 해서 부하를 분산시킬 수
있습니다. 세 번째로 서비스에서 사용할 도메인이 있다면 HTTPS 지원을 위한 SSL
TLS 암호화를 엔진X 단에서 처리하여 뒷단의 장고 서버는 HTTPS 요청을 처리하지 않고
http 요청만을 처리하면 되기에 서버의 부담을 줄일 수 있습니다
네번째로 Nginx 딴에서 메모리, memcached, redis 캐싱을 수행하여 장고
서버의 부담을 줄일 수도 있습니다
게다가 엔진엑스는 Lua 스크립트 언어로 엔진엑스 기능을 확장할 수도 있습니다.
이처럼 엔진엑스 웹서버는 웹 서비스 아키텍처에서 중추적인 역할을 수행하는 매우 강력하고
유용한 소프트웨어입니다.
이 중 첫 번째에 정적 파일 서빙과 두 번째에 Reverse Proxy 기능을 설정해 보겠습니다.
현재 장고 서비스는 Gunicorn, 시스템D를 통해 8080 포트를 통해 구동되고 있습니다.
80번 포트에서는 구동 중인 서비스는 없습니다.
Nginx 웹서버를 설치하겠고요.
디폴트로 80번 포트로 구동됩니다.
방화벽에서는 80번 포트가 열려있기에 웹브라우저로 IP로 접속하시면 엔진X 기본 웹페이지를
확인하실 수 있습니다.
엔진X의 기본 설정 파일은 루트의
etc/nginx/sites-enabled/default 경로인데요.
기본 설정 파일이 주석 포함해서 91줄로 긴 편입니다.
기본 설정 파일은 모두 지우고, 간결하게 접속하면 헬로우 엔진X 응답을 하도록 설정을
변경해주고 동작을 확인해 보겠습니다.
Nginx 설정 파일 문법에 대한 검증은 루트 권한으로 Nginx 명령에서 "-t 옵션을 주어
수행하실 수 있구요.
시스템 컨트롤 리로드 Nginx 명령으로 Nginx 재시작 없이 설정만 다시 읽어 드리도록
하실 수 있습니다.
그러면 처리 중인 연결은 그대로 처리하고 새로운 연결에 대해서만 새 설정을 적용합니다.
이에 반해 리스타트 명령은 Nginx를 재시작합니다.
재시작하면 처리 중인 연결도 중단되는데요.
메모리 누수 등 등의 이슈를 해결하실 수도 있습니다.
Nginx 웹서버를 설치합니다.
기본 설정 파일은 Nginx 엔진X Site Enabled Default 경로입니다.
총 라인 수는 90함줄이고요.
웹 브라우저로 IP로 접속해 보시면 이렇게 엔진X 기본 웰컴 페이지가 뜹니다.
200 Hello Nginx 응답만을 받도록 엔진X 설정을 변경해 보겠습니다.
현재 리액토리에서 엔진X 설정 파일을 생성하시고요.
이 설정 파일을 옮겨야 할 텐데요.
etc/nginx/sites-enabled 경로의 default 파일을 보시면,
etc/nginx/sites-available 경로의 default 파일에 대한 심볼릭
링크임을 확인하실 수 있습니다.
텍스트 파일이 아니라 링크 파일입니다. Nginx에서는 각 설정들을 Site Available
경로에 생성하고 사용할 설정들은 Site Enabled 경로에 심볼릭 링크를 만드는
방식으로 동작합니다
그러니 파일을 덮어 쓰시려면 sites-available 디렉토리의 디폴트 경로에 덮어
쓰시는 것이 맞습니다
이렇게 덮어쓰기 했고요.
파일이 잘 옮겨졌습니다.
설정 파일의 문법을 체크해보니 문법 오류는 없다고 합니다.
nginx 설정을 다시 읽어드리고요.
웹페이지 새로고침하시면 응답이 웹페이지 화면에 보여지지 않고 다운로드가 됩니다.
nginx 설정을 수정하여 컨텐트 타입 헤더에 텍스트, html을 추가해줍니다.
설정을 다시 읽어드리고요.
웹페이지 새로고침하시면 화면에 Hello Nginx가 잘 보여집니다.
NGINX에 Reverse Proxy 설정을 하여 모든 요청을 Django 서버로 전달해
보겠습니다.
Proxy Set 헤더 지시자를 통해서 Django 서버로 요청을 전달할 때 헤더를
추가하실 수 있습니다.
원래 요청의 호스트 헤더로 추가로 전달하고요.
원래 요청의 프로토콜을 Exported Proto-Header로 전달합니다.
서비스를 HTTPS로 서비스할 경우, Django 서버로는 여전히 HTTP 프로토콜로
요청을 전달하게 되는데요.
두 프로토콜이 달라서 CSRF 토큰 검증 오류가 발생합니다.
이전에 ngrok을 활용할 때 그랬죠.
그런데 exported proto 헤더로 원래 요청의 프로토콜을 전달하면 장고 딴에서 원래
요청의 프로토콜을 알 수 있기에 더 이상 CSRF 토큰 검증 오류가 발생하지 않습니다.
CSRF Trusted Origins 설정을 하지 않아도 됩니다.
장고 서버 입장에서는 엔진엑스 웹서버로 웹 요청을 보내는 클라이언트니까요.
모든 요청이 엔진엑스를 통해서 전달받으니 클라이언트의 IP를 조회하면 항상 엔진엑스 사설
IP로 조회됩니다.
하지만 X-Real IP 헤더로 실제 클라이언트의 IP를 전달하면 장고 서버에서 실제
클라이언트의 IP를 알 수 있게 됩니다.
그리고 HTTP 요청이 NGINX 외에도 여러 proxy server를 거칠 수도
있는데요. 이때에는 X-Forwarded-For 헤더에 거쳐온 proxy server의 주소를 목록으로
지정하면 Django 서버단에서 어떤 proxy server를 거쳐왔는지 인지할 수 있게
됩니다. proxy path 지시자로 요청을 전달할 백엔드를 지정하고요.
HTTP 프로토콜로 Django 서비스 서버 그룹을 지정했습니다.
지금은 그룹 내에 서버를 한 개만 지정했는데요.
여러 개의 서버를 지정할 수 있고요.
그러면 엔진엑스에서는 요청을 분산 처리해 줍니다.
로드 밸런서의 역할을 하는 거죠.
요청 순서 알고리즘을 지정할 수도 있고요.
서버 간의 요청 비율도 지정할 수 있습니다.
마지막으로 장고 응답의 Location 응답 헤더를 수정하지 않고 그대로 전달하도록
설정합니다. 기존 엔진엑스 설정 파일을 새 설정으로 덮어 쓰겠습니다.
현재 디렉토리에서 복사한 설정으로 새 파일을 생성하고요.
명령 히스토리에서 파일을 이동시켰던 mv 명령, move 명령이 있었죠.
그 명령의 번호가 저는 287번이네요.
느낌표 287 명령을 실행해서 해당 명령을 다시 수행합니다.
파일 덮어쓰기가 잘 되었고요.
문법 검사해 보시면 문법 검사도 통과합니다.
설정을 다시 읽어드린 후에 웹브라우저로 접속해 보시면 이렇게 웹페이지가 잘 뜹니다.
현재 에러 상황은 아니고요.
정상 동작하는 상황이 맞습니다.
어드밈 페이지로도 접속이 잘 됩니다.
Nginx를 경유해서 Django 서버로부터 웹페이지 응답은 잘 받았지만 CSS 파일,
Javascript 파일의 static 파일에 대한 서빙을 Django 웹서버에서 지원하지
않아서 웹페이지의 스타일이 적용이 안 된 상황일 뿐입니다
static 서빙에 대해서는 이후 영상에서 살펴보겠습니다 유저로부터 요청을 받을 때 무한대
용량의 요청을 받아서는 안 됩니다
불필요하게 서버의 리소스를 낭비하기 때문인데요.
Nginx에서는 요청 바디의 최대 허용 크기가 기본로 1MB로 설정되어 있습니다.
이 크기를 초과한 요청은 413 Request Entity Too Large 응답으로 에러 응답을
합니다. 업로드를 허용할 최대 용량을 서비스에 맞춰 적절히 지정해 주세요.