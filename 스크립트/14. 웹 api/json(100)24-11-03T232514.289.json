안녕하세요. 이번 시간에는 Django 웹 프레임워크와 함께 Next.js
애플리케이션에서 세션 인증을 활용한 API 요청에 대해서 살펴보겠습니다.
Next.js는 React 기반의 풀 스택 웹 프레임워크로서 CSR 렌더링과 SSR
렌더링을 모두 지원하는 하이브리드 렌더링 방식을 채택하고 있습니다.
즉, API 요청이 웹브라우저를 통해 발생할 수도 있고요.
이때에는 CORS 정책에 영향을 받습니다.
앞선 강의에서 살펴봤었던 케이스입니다.
Next.js 애플리케이션의 주소와 장고 서비스의 주소를 맞춰주시고 CORS 설정만
해주시면 패치 요청만으로 세션 인증을 활용하실 수 있습니다.
그리고 Next.js 서버단에서 API 요청을 할 수도 있습니다.
GetServerSideProps 함수는 Next.js 서버에서 HTTP 조청을 받았을 때
응답을 준비하는 과정에서 호출됩니다.
이때에는 웹브라우저가 아닌 서버단에서 수행되므로 CORS 정책에 영향을 받지 않고요.
웹브라우저처럼 쿠키 자동 전송도 없습니다.
하지만 웹브라우저로부터의 요청을 통해 수행된 상태니까요.
웹브라우저 요청에서 Session ID 쿠키가 포함된 쿠키 내역이 있습니다.
이 쿠키를 그대로 API 요청에 활용하시면 Session 인증을 그대로 활용하실 수 있게
됩니다. 이 코드가 이번 수업의 핵심입니다.
Next.js 서버를 독립적으로 사용하지 않고, Django 위주의 웹페이지 구성에서
Next.js 처리가 필요한 요청만 Next.js 서버에 위임하는 상황으로 아키텍처를
만들어 봤습니다.
Next.js 서버는 Node.js로 구동되는 웹서버입니다.
웹브라우저에서 수행될 React 컴포넌트, JavaScript 코드를 응답하기도 하고요.
서버단에서 React 코드로 렌더링된 HTML 응답을 하기도 합니다.
Next.js 서버로 요청을 전달해주는 중개 서버를 장고 서버를 사용하실 수도 있고요
리버스 프록시 서버를 사용하실 수도 있습니다
Next.js 서버에서 요청을 받으면 서버 사이드 렌더링 방식이나 클라이언트 사이드 렌더링
방식으로 동작할 수 있는데요 클라이언트 사이드 렌더링 방식의 자바스크립트 HTTP 요청에서
세션 인증 활용은 앞선 수업에서 많이 살펴봤었죠
서비스에 맞춰 도메인을 결정하시고, 그에 맞춰 CORS 정책만 신경 써주시면 됩니다.
서버 사이드 렌더링으로 동작할 때에는 Next.js 서버에서 Django 서버로 직접
HTTP 요청을 보냅니다.
브라우저 요청이 아니기에 요청 헤더, 요청 쿠키는 모두 비워져 있는 상황인데요.
이때 브라우저로부터의 요청의 쿠키를 그대로 API 요청에 담아서 요청하면 그 쿠키에는
Session ID 쿠키가 있기에 그대로 Session 인증을 활용하실 수 있게 됩니다.
이렇게 Session 인증을 활용하면 API 인증이 엄청 간결해지죠
Nginx와 같은 Reverse proxy 서버를 두는 방식은 Django 서비스를 통해
만들어지는 웹페이지와 Next.js 서비스를 통해 만들어지는 웹페이지는 서로 독립적입니다
두 웹페이지의 레이아웃을 맞추려면 같은 레이아웃을 Django 템플릿과 Next.js
레이아웃에 각각 적용해 줘야만 합니다.
Django 서버를 경유해서 Next.js 서버로 요청을 전달할 때에는 Django
Next.js 라이브러리를 사용하시면 편리합니다.
Django 서버를 경유함으로 Next.js로의 접근을 Django를 통해 온전히 통제할
수 있게 됩니다.
그리고 Next.js HTML 응답에 Django 템플릿으로 구성한 페이지 레이아웃을
적용하실 수 있습니다.
Next.js 프로젝트를 생성해 보겠습니다.
Node.js는 강의 초반에 개발 환경 설정에서 설치를 했었습니다.
Node.js가 설치되어 있다면 Node 명령과 npx 명령이 지원됩니다.
Node.js가 없으신 분들은 윈도우에서 이렇게 winget install 명령으로
설치하실 수 있습니다.
npx create-next-app 명령을 통해 이렇게 지정된 이름으로 현재 경로에
Next.js 프로젝트를 생성합니다 본 수업은 Next.js 버전 14 기준으로
제작되었으니 여러분도 버전 14로 프로젝트를 생성해 주세요
디폴트 옵션으로 프로젝트를 생성하겠습니다 생성된 프로젝트 디렉토리로 이동하신 후에 npm
run dev 명령으로 Next.js 개발 서버를 구동하실 수 있습니다
npm run dev 명령은 packages.json 파일의 script 항목에 명시된
명령입니다.
디폴트로 3000번 포트로 구동되고요.
앞서 3000번 포트에서 구동했던 다른 서버들은 먼저 종료하신 후에 서버를 실행시켜
주세요. 웹브라우저를 실행시켜 주시고 http://localhost:3000 주소에
접속하시면 이렇게 Next.js 페이지를 확인하실 수 있습니다.
노드 명령과 npx 명령의 동작을 확인합니다.
npx create-next-app 명령을 통해 14 버전의 Next.js 프로젝트를
현재 디렉토리에 생성합니다.
default 옵션으로 생성하겠고요.
엔터 엔터 엔터 했습니다.
기존에 3000번 포트로 띄워두신 웹서버가 있다면 지금 꺼주시고요.
생성된 mynextjs 폴더로 이동합니다.
package.json 파일에 보시면 scripts 항목에 dev 명령이 정의되어
있습니다. npm run dev 명령으로 해당 명령을 수행합니다.
그럼 nextjs 개발 서버가 localhost 3000번 포트에서 구동됩니다.
웹브라우저로 http://localhost:3000 페이지에 접속하시면 Next.js 서버가
응답해준 웰컴 페이지를 확인하실 수 있습니다.
Next.js 프로젝트 내에 페이지스의 블로그에 index.js 경로에
React 컴포넌트 소스 코드를 이와 같이 생성합니다.
별도의 라우팅 설정 없이도 페이지 이스 디렉토리에 React 컴포넌트를 정의하는 것만으로
자동으로 라우팅이 설정됩니다.
이 방식이 페이지 이스 라우팅이며 파일 시스템 기반으로 동작합니다.
아직 React를 배우지 않으셨기에 이 코드가 낯서실 텐데요.
메시지 이름의 상태 값에 저장된 문자열을 렌더링하고요
메시지 값이 변경되면 이에 리액트, 즉 상태 값 변경에 반응하여 컴포넌트가 자동으로
재렌더링 되고요 변경된 메시지 값으로 화면이 보여집니다
리턴문 안의 태그는 JavaScript 문법이 아니라 JSX 문법입니다.
React에 대해서는 뒤에서 배울 것이고요.
지금은 웹브라우저로 http://localhost:3000의 블로그 주소로 접속하시면
Next.js에서 이 요청을 처리하여 React 컴포넌트 JavaScript 코드로
응답하고요. 이 코드가 웹브라우저로 다운로드되어 웹브라우저에서 수행된다는 것만 아시면
됩니다.
Next.js 프로젝트를 편하신 에디터로 열어주세요.
파이참 프로페셔널에서는 자바스크립트 프로젝트로 지원하기에 저는 파이참 프로페셔널로
열었습니다.
npm run dev 명령으로 개발 서버를 다시 실행시켜 주겠습니다.
Next.js 루트 경로에서 페이지스 밑에 블로그에 index.javascript 경로에
WhoAmIPage React 컴포넌트를 정의합니다.
src 폴더가 아니라 루트 경로의 생성함에에 주의해 주세요 제공해
드린 소스 코드를 복사합니다 메시지 상태 값은 초기 값으로 noMessage 문자열이고요
setMessage 함수로 상태 값을 변경합니다
메시지 상태 값을 렌더링하도록 구현되어 있습니다
별도의 라우팅 정의 없이도 페이지스 라우터가 동작할 것입니다.
http://localhost3000의 블로그 페이지에 접속해 주세요.
방금 페이지스 폴더를 만들었기에 Next.js 서버에서 페이지스 라우터가 아직 동작하지
않은 듯하고요.
개발 서버를 수동으로 재시작시켜 주시고 다시 접속해 보시면 이렇게
WhoAmIPageConfront로 렌더링된 화면을 확인하실 수 있습니다.
브라우저를 통해 API 요청을 해 보겠습니다
React 컴포넌트 내에서 useEffect hook을 사용하시고 첫 번째 인자로 함수,
두 번째 인자로 빔 배열을 지정하시면 첫 번째 인자로 지정된 함수는 해당 컴포넌트가
초기화될 때 딱 한 번만 실행됩니다
딱 한 번 실행되면서 API를 호출하고 그 응답을 화면에 보여주려 합니다
WhoAmIPage 컴포넌트의 코드는 웹브라우저 단에서 수행됩니다.
그러니 패치 API도 웹브라우저 단에서 수행됩니다.
패치 함수 호출이 브라우저 단에서 이루어지는지 서버 단에서 이루어지는지를 이해하는 것이
이번 수업의 포인트입니다.
실행해 보면 패치 요청에서 타이베러 예외가 발생했습니다.
CORS 정책 위반으로 패치 요청이 중단되었습니다.
Django 서버의 주소는 http://localhost:8000 이고요.
현재 웹페이지 주소는 http://localhost:3000 이니까요.
출처가 달라서 이 요청을 허용하려면 Django 서버의 허락인 CORS 정책 변경이
필요합니다.
웹브라우저 단에서 API 요청을 해보겠습니다.
React 컴포넌트에서 컴포넌트 초기화 시에 단 1회만 호출되도록 함수를 정의하고요.
그 함수 내에서 패치 API를 config 없이 호출합니다.
만약 API 호출에 성공해서 응답을 받으면 응답 텍스트를 메시지 상태 값에 반영합니다.
메시지 상태 값이 변경되면 자동으로 후에 마이 페이지 컴포넌트가 재렌더링되어 화면에 변경된
메시지 상태 값이 보여질 것입니다.
그런데 페이지를 새로고침해 보시면 파이베러 예배가 발생했습니다.
블라우저 개발자 도구의 탭을 보시면 패치 API 호출 시에 출처가 달라서 CORS 정책에
위배되어 해당 요청이 중단되었습니다.
이는 장고 서버의 허락, 즉 CORS 정책 변경으로 API 호출을 허용할 수 있지만
CORS 정책을 변경하진 않겠고요.
뒤에서 아키텍처 변경으로 블라우저에서의 API 호출이 성공하도록 할 것입니다.
이번에는 GetServerSideProps 이름의 함수를 정의하고 그 함수 내에서 API
요청을 해 보겠습니다.
Next.js에서는 이 이름의 함수는 Next.js 서버가 요청을 받고 응답을 생성할 때
서버 단에서 호출됩니다.
브라우저가 아닌 서버 단에서 호출되기에 CORS 정책에 영향을 받지 않습니다.
이 함수의 반환 값에서 props 키로 반환한 값은 아래 React 컴포넌트의 속성 값으로
자동 주입됩니다.
실행해 보면 패치 API는 정상 동작하여 장고 서버로부터 응답을 받았습니다.
응답의 상태 코드는 401이고요.
서버 단에서의 패치 요청에서는 브라우저 내에서의 패치 요청과 다릅니다.
브라우저 내에서의 패치 요청에서는 요청 헤더에 쿠키 헤더가 자동 설정되지만 서버 단에서는
요청 헤더는 비어져 있습니다.
그래서 API 서버로 요청 시에 요청 헤더에 쿠키 헤더가 없어서 세션 인증이 실패되어
401 응답을 받은 상황입니다.
GetServerSideProps 함수는 Next.js에서 약속된 함수입니다
이 함수를 구현하시면 Next.js에서 요청 처리 중에 브라우저가 아닌 서버 단에서 자동
호출됩니다 서버 단에서 패치 API를 통해 API를 호출하겠고요
그 응답을 컴포넌트 속성 값으로 전달하겠습니다
props 키로 반환된 값은 컴포넌트 속성 값으로 자동 주입됩니다.
getServerSideProps 함수를 복사하고요.
메시지 상태 값은 제거하고 메시지 속성 값을 렌더링도록 합니다.
페이지 새로고침하시면 상태 코드 401로서 API 호출에 성공했음을 확인하실 수 있습니다.
브라우저 개발자 로그의 네트워크 탭을 보시면 HTTP 요청 내역이 없죠.
클라이언트 단이 아닌 서버 단에서 API 호출이 되었으니깐요.
그런데 서버단에서 패치 API 호출 시에 Session ID 쿠키 헤더가 없어서
Session 인증에 실패하여 401 응답을 받았고요 만약 Session ID 쿠키를
전달할 수 있으면 Session 인증도 성공하고 200 응답을 받을 수 있을 것입니다
Next.js 서버에서 HTTP 로컬호스트 3000 주소를 통해서 요청을 받았고요
로컬호스트의 3000 주소는 로컬호스트의 8000 주소와 호스트는 같은데 포트 번호만
다르죠 쿠키는 호스트가 같은 경우에는 공유됩니다 그러니 별도의 CORS 설정 없이도
Next.js로의 http://localhost 3000 주소의 요청 헤더에는
Session ID 쿠키 값이 들어 있습니다
그러니 Next.js 서버단에서 API 호출할 때 요청으로 받은 쿠키 헤더를 API 호출의
요청 헤더에 담아서 호출하신다면 이렇게 Session 인증에 성공하시게 됩니다
Next.js 서버 로그에 보시면 이렇게 요청 헤더에 Session ID 쿠키가 있음을
확인하실 수 있습니다
Next.js 서버에서 요청을 받았을 때 요청 헤더에 쿠키 헤더가 있고요
여기에 Session ID 쿠키가 있습니다
이 쿠키를 그대로 API 호출 시에 요청 헤더에 담아서 전송합니다
그러면 이렇게 Session 인증에 성공하여 200 응답을 받았고요 로그인 유저명도 잘
출력됨을 확인하실 수 있습니다