안녕하세요. 이번 시간에는 웹 프론트엔드 자바스크립트에서 API 서버로 HTTP 호출을
할 때 사용하는 주요 인증 방법을 소개하겠습니다.
Django 기본에서는 Session 인증을 지원하고요.
사용자가 유저명 암호로 인증하면 Django는 Session을 생성하고 해당
Session의 고유한 식별자를 Session ID 이름의 쿠키에 자동으로 저장합니다.
폼 전송 등의 웹블라우저를 통해 Django 서버로 전송되는 모든 HTTP 요청에는
Session ID 쿠키가 자동으로 포함되어 전송됩니다.
Django 서버는 이 쿠키를 사용하여 매 요청마다 Session 인증을 수행합니다.
자바스크립트에서는 Patch API를 사용하여 HTTP 요청을 보내고 응답을 받습니다.
자바스크립트에서 Patch API는 웹블라우저의 동일 출처 정책을 따름으로 프로토콜,
도메인, 포트가 모두 같은 현재 웹페이지와 동일한 출처의 서버로만 HTTP 요청을 보낼 수
있고요. Session ID 쿠키가 자동으로 포함되어 전송되므로 이처럼 별도의 인증 처리
없이도 Session 인증이 이루어집니다.
이때 자바스크립트 코드에서는 인증에 대해서 신경 쓸 부분이 전혀 없습니다.
이는 바닐라 자바스크립트뿐만 아니라 React, Vue, Svelte 등의 라이브러리에서도
동일하게 적용됩니다.
현재 http://localhost8000의 블로그 주소의 요청을 처리하는 Vue는 아직
Django에서는 구현되어 있지 않습니다.
미리 제공해 드린 소스 코드를 활용하겠습니다
블로그의 urs 파일에 블로그의 index.html 템플릿을 활용하여 응답하는 뷰 함수를
하나 추가합니다
블로그의 템플릿에 블로그의 index.html 경로에 템플릿 파일을 복사하는데요
이 템플릿에서는 http://localhost8000의 블로그의 WhoMI 주소로
자바스크립트로 HTTP 요청을 보내고 응답을 받으면 응답의 상태 코드와 응답 텍스트를
화면에 보여줍니다.
블로그의 WhoMI 요청을 처리하는 뷰는 이어서 구현하겠습니다.
블로그의 뷰스파이 파일에 whoami_view 함수를 복사합니다.
요청의 유저가 인증된 상황이면 상태 코드 200 응답을 하고요.
인증된 상황이 아니라면 상태 코드 401 응답을 합니다.
그리고 유저명이 있다면 유저명으로 응답하고, 없다면 anonymous 유저명으로
응답합니다. 비인증 상황에서 유저 네임 속성은 빈 문자열입니다.
WhoAmI 뷰 함수에 대한 URL 패턴도 등록해 줍니다.
http://localhost:8000의 블로그의 후에마이 페이지에 접속하시면 현재 로그인
상황이기에 제 로그인 유저명이 출력되고 있습니다.
Anonymous로 출력되신다면 지금 장고 로그인 페이지에서 로그인해 주세요.
http://localhost:8000의 블로그 페이지에 접속하시면 자바스크립트를 통해
블로그의 WhoAmI 페이지로 HTTP 요청을 보내어 지고요.
이때 정상적으로 세션 인증 처리가 되어 200 응답을 받았고 제 로그인 유저명으로 이렇게
응답도 받았습니다.
브라우저 개발자 도구를 여시고 탭에서 블로그의 WhoAmI 요청 내역을 보시면 요청
헤더에서 쿠키 헤더가 있고 세션 아이디 값이 자동 전송되었음을 확인하실 수 있습니다.
쿠키로 세션 아이디 값이 자동 전송되었기에 세션 인증 처리가 된 것이고요.
자바스크립트로 패치 API로 HTTP 요청을 보내는 웹페이지와 HTTP 요청을 받는
웹페이지 간의 주소가 서로 다를 경우 쿠키로 세션 아이디 값이 자동으로 전송이 안 됩니다.
이에 대해서는 차근차근 살펴보겠습니다.
세션 인증은 웹 서비스에서 가장 널리 사용되어지는 인증 방법이고요 대부분의 웹
프레임워크에서 안전하게 사용할 수 있습니다 유저가 유저명 암호로 인증을 요청하면 유저
데이터베이스를 통해 유저를 조회하고요 인증을 수행합니다
인증에 성공하면 이미 아이디의 세션을 세션 저장소에 생성합니다.
Django 기본에서는 데이터베이스를 세션 저장소로 사용하지만, 보다 빠른 세션 저장 및
조회를 위해서 Redis를 세션 저장소로 사용하실 수도 있습니다.
생성된 세션의 아이디를 쿠키에 설정하고요.
Session ID는 32글자의 랜덤 문자열로써 Session 식별자일 뿐 어떠한 데이터도
담고 있진 않습니다.
Session ID 쿠키는 http only 플래그가 설정되어 있기 때문에 자바스크립트를
통해 이 Session ID 쿠키를 읽을 순 없습니다.
이는 크로스 사이트 스크립팅 공격과 같은 방법으로 Session ID 쿠키를 탈취하는 것을
방어합니다. 장고 웹페이지나 장고 웹페이지와 동일한 줄처의 웹 프론트엔드 페이지에서 패치
API를 통한 HTTP 요청에서 자동으로 Session ID 쿠키가 서버로 같이 전송됩니다
이때 HTTPS 프로토콜을 사용하여 통신할 경우 전송되는 데이터가 암호화됩니다
그래서 설사 공격자가 네트워크 트래픽을 가로챈다 하더라도 암호화된 데이터를 해독할 수
없으므로 Session ID 쿠키를 안전하게 보호할 수 있습니다.
그럼 장고단에서는 Session ID 쿠키의 값으로 Session 저장소에서
Session을 조회해서 Session 인증을 수행합니다.
JSON 웹토큰은 디지털 서명을 사용하여 토큰의 무결성을 보장하는 기술로써 위조 방지를
위해 사용됩니다
JSON 웹토큰은 서명된 토큰의 데이터를 저장하는데 JSON 웹토큰 값만 있으면 저장된
데이터는 쉽게 확인할 수 있습니다
하지만 서명 검증을 통해 토큰의 무결성을 보장하기 때문에 저장된 데이터의 변조는
불가능합니다 오오스 구글 인증 후에는 인증 데이터를 전송하기 위해 JSON 웹토큰을
사용하기도 합니다.
이때 JSON 웹토큰은 매우 짧은 유효기간을 가지도록 설정됩니다.
JSON 웹토큰을 인증 데이터 전송을 위한 용도로 사용하므로 장기간 유지할 필요가 없기
때문입니다. 짧은 유효기간을 설정함으로써 토큰의 보완성을 높일 수 있습니다.
세션 인증에서는 유저가 유저명 암호로 인증한 후에 세션을 생성하고 생성된 세션의 아이디를
쿠키에 저장하는데요.
JWT 웹토큰 인증에서는 유저가 유저명 암호로 인증한 후에 만료 시간을 지정하여 JWT
웹토큰을 생성하고 브라우저로 내려줍니다.
JWT 웹토큰이 만료되면 해당 토큰은 더 이상 사용할 수 없습니다.
JSON 웹토큰을 브라우저의 메모리 혹은 쿠키 혹은 로컬 스토리지에 저장하고 매 API
요청마다 JSON 웹토큰을 요청에 담아서 인증을 수행합니다.
서버에서는 데이터베이스 조회 없이 JSON 웹토큰 값만으로 변조 여부를 파악하고 인증을
수행할 수 있는데요.
이는 JSON 웹토큰에 이미 사용자 인증이 필요한 모든 정보가 포함되어 있기 때문에 가능한
것입니다.
데이터베이스 조회 없이 인증을 수행할 수 있다는 점이 재해선 웹토큰 인증의 가장 큰
장점입니다. 그런데 JWT 웹토큰 값만으로 인증을 수행하기에 JWT 웹토큰 값이 탈취되면
공격자가 해당 토큰을 사용하여 토큰 사용자인 것처럼 행세할 수 있습니다.
세션 인증에서도 해킹이 의심되는 계정에 대해서는 서버에서 해당 세션을 만료시킬 수 있는데요. 
JSON 웹토큰에서는 이미 발급된 JSON 웹토큰에 대해서 지정된 유효기간 전에는 강제로 만료시킬 수 없습니다.
만약 강제로 만료시키려면 매 JWT 웹토큰 인증 시마다 강제 만료된 JWT 웹토큰 인지를 검사해야 하는데요.
그러면 데이터베이스 조회 없이 인증이 가능하다는 JWT 웹토큰의 장점이 사라지게 됩니다.
그래서 JSON 웹토큰의 만료 시간을 짧게 주어 탈취되더라도 그 피해를 최소화시키는 선택을 합니다. 
만료 시간을 짧게 준 만큼 토큰을 자주 갱신해야 하기에 그만큼 서버에 부하가 많이 걸리고 수동 갱신에서는 유저가 자주 로그인을 해야 하는 번거로움이 있고요.
JSON 웹토큰 자동 갱신을 위해 Refresh 토큰을 두면 갱신 프로세스를 설계해야 하고 구현해야만 합니다.
이에 대한 표준화된 아키텍처가 없고 케이스 바이 케이스입니다.
Session 인증은 Django 기본에서 탄탄하게 지원해주는 기술입니다.
이러한 이유로 React 싱글 페이지 애플리케이션이나 Next.js 애플리케이션을 개발하시더라도 API 인증에서는 최우선 순위로 Session 인증을 활용하시기를 적극 추천드립니다.
JSON 웹토큰 인증도 좋은 인증 방법이지만 단순 API 인증에 사용하는 것은 득보다 실이 많고 공수가 많이 들어간다고 생각합니다.



1. Django Session 인증
사용자가 유저명과 암호로 인증 요청을 보내면 Django는 세션을 생성합니다.
세션 고유 식별자(Session ID)를 쿠키에 저장하여 클라이언트에 반환합니다.
이후 모든 HTTP 요청에는 자동으로 쿠키(Session ID)가 포함되어 Django 서버로 전송되며, 이 쿠키를 사용해 세션 인증을 수행합니다.
장점: Django 서버와 동일 출처에서 자바스크립트 코드로 HTTP 요청을 보낼 때 Session ID 쿠키가 자동으로 전송되어 인증이 편리하게 처리됩니다.
주의사항: 서로 다른 출처의 웹 페이지와는 자동으로 쿠키가 전송되지 않으므로 별도의 설정이 필요합니다.

2. JavaScript에서 HTTP 요청 전송과 동일 출처 정책
JavaScript의 fetch API는 동일 출처 정책(Same-Origin Policy)을 따릅니다.
즉, 현재 웹 페이지와 동일한 프로토콜, 도메인, 포트로만 요청을 보낼 수 있습니다.
세션 인증을 사용할 경우, JavaScript는 별도 인증 처리가 필요 없으며, Django와 동일 출처일 때 자동으로 세션 ID 쿠키가 서버에 전송됩니다.

3. Django 서버 구성
Django 서버에서는 WhoAmI라는 뷰를 구성하여 현재 로그인된 유저 정보를 확인할 수 있도록 합니다.
유저가 인증된 상태이면 status 200 응답을, 비인증 상태이면 status 401을 반환합니다.
인증된 유저라면 유저명을 응답에 포함시키고, 비인증된 유저는 anonymous로 응답합니다.

4. Session ID 보안 조치
Session ID는 httpOnly 플래그가 설정되어 JavaScript로 읽을 수 없습니다. 이를 통해 XSS와 같은 공격을 방어합니다.
HTTPS를 사용하여 세션 ID를 암호화된 상태로 전송하면 Session ID가 더욱 안전하게 보호됩니다.

5. JSON Web Token (JWT) 인증
JWT 구성과 서명: JWT는 서명된 데이터를 포함하며, 디지털 서명 덕분에 무결성을 보장할 수 있습니다. 유저의 인증 정보가 토큰에 포함되어 있기 때문에 데이터베이스 조회 없이 토큰 자체만으로 인증이 가능합니다.
만료 시간과 갱신: JSON 웹토큰은 짧은 만료 시간을 가지며, 만료되면 더 이상 사용할 수 없습니다.
JWT 단점: 토큰이 탈취될 경우 이를 방지할 수 없으며, 서버에서 강제로 만료할 수도 없습니다. 이를 극복하려면 인증 시마다 DB에서 검증을 해야 하므로 서버 부하가 증가할 수 있습니다.
6. Session 인증과 JWT 인증의 비교
Session 인증: Django 기본 제공 기능이며, 추가적인 구현이 필요하지 않습니다. 특히 API 인증에 적합하고, Django, React, Next.js 등 다양한 프레임워크와 쉽게 연동 가능합니다.
JWT 인증: 장점도 있지만 만료 시마다 갱신이 필요하고, 보안 문제가 발생할 가능성이 있어 단순 API 인증에는 적합하지 않을 수 있습니다.
7. 권장사항
Django 기반 애플리케이션에서는 Session 인증이 더 안정적이고 구현이 간편합니다.
React, Next.js와 같은 SPA에서의 인증에도 Session 인증을 최우선으로 사용하는 것이 좋습니다.