이번에는 Reverse Proxy 서버를 통해 Django 서버와 웹 프론트엔드 서버를
같은 출처에서 서비스해 보겠습니다.
Reverse Proxy로 전달된 요청을 요청 URL로 분기하여 Django 서버와 웹
프론트엔드 서버로 요청을 전달하고, 그 응답을 받아서 다시 웹브라우저에게 전달해 줍니다.
장고 서버와 웹 프론트엔드 서버가 서로 다른 서버로 운영되고 있지만 웹블라우저 입장에서는
리버스 프록시 서버만 보이기에 동일 출처로 판단합니다
혹은 장고 서버에서 리버스 프록시 역할을 추가하도록 구성하실 수도 있습니다
Nginx 도커 컨테이너로 실습을 해 보겠습니다
config에 nginx.conf 경로에 nginx 설정 파일을 먼저 생성합니다.
HTTP for Docker를 서비스하는 웹서버는 80 포트로 구동되니깐요.
Docker 컨테이너 내에서 Nginx 웹서버를 80번 포트로 구동토록 합니다.
이 Nginx 웹서버가 받는 요청 URL이 API 혹은 Admin, Blog, DJ,
Static, 미디어로 시작하는 요청은 Django 서버인 8,000 포트로 요청을
전달하고요. 그 외의 요청 URL은 3,000번 포트로 웹 프론트엔드 서버로 요청을
전달합니다.
proxy2 Django 설정과 proxy2 Front 설정은 요청 주소를 제외하고는
동일한 Reverse proxy 설정을 가지고 있습니다.
Nginx를 도커 컨테이너가 아니라 리눅스 머신에서 직접 구동하실 경우에는 플록시 패스
설정에서 주소를 127.0.0.1로 변경해 주세요.
방금 생성한 Nginx 설정 파일을 도커 컨테이너 구동 시에 마운트 시킵니다.
이 명령들은 한 줄 명령이고요.
가독성을 위해 한 줄을 여러 줄로 쓴 것 뿐입니다.
한 줄로 쭉 이어 쓰셔도 됩니다.
사용하시는 쉘에 따라 줄 바꾼 문자와 현재 경로를 얻는 명령이 다릅니다
각자 환경에 맞는 명령으로 구동해 주세요
도커 런 명령으로 8080 포트에서 Nginx 컨테이너를 구동합니다
8080 포트 외에 다른 포트 번호를 사용하실 수도 있습니다
nginx.conf 파일을 config 폴더 아래에 복사해 줍니다
저는 현재 맥 환경이라서 shell 명령으로 docker run 명령을 수행하겠습니다.
현재 경로에 config 폴더에 nginx.conf 파일을 새롭게 생성되는 docker
컨테이너에 etc에 nginx.conf.d에 default.conf 위치에 마운트 시켜
nginx의 알파인 docker 이미지로 docker 컨테이너를 생성, 구동합니다.
8080 포트로 들어오는 요청을 컨테이너 내부에 80번 포트로 전달하여 요청을 처리합니다
현재 머신에 엔진X 알파인 도커 이미지가 없다면 먼저 다운을 받고요 이렇게 엔진X 도커
컨테이너가 구동되었습니다
도커 컨테이너를 중단시키려면 를 입력하시면 됩니다
웹브라우저로 http://localhost:8080 주소로 접속하시면 이 요청이 3000번
포트로 전달되어 처리되고 있습니다.
이제 같은 출처에서 서비스되기에 CORS 설정이 더 이상 필요 없습니다.
그리고 같은 호스트로 요청을 보내는 것이기에 호스트명을 생략하셔도 됩니다.
Credentials Include 설정조차 쓰지 않으셔도 패치 요청 시에 쿠키가 자동
전송되고 세션 인증이 정상 처리됩니다.
Settings의 CORS 관련 설정들을 모두 주석 처리하겠습니다.
HTML 폴더의 csrapicall.html 파일에서도 config 설정을 비우겠고요.
http://localhost8080의 csrapicall.html 페이지를 열어보시면
현재 요청이 실패하고 있습니다.
브라우저 개발자 도구의 콘솔 탭을 열어보시면 CORS 정책 위반으로 요청이 거부되었습니다.
http://localhost8080 주소에서 http://localhost:8000
주소로 요청을 보냈으니 서로 다른 출처잖아요.
그러면 CORS 설정이 필요합니다.
우리는 같은 출처로 서비스에서 CORS 설정이 필요 없도록 하려는 것이고요.
그러면 요청을 8080 포트로 보내야 합니다.
요청 주소에서 프로토콜과 호스트를 제거합니다.
그러면 현재 웹페이지에 프로토콜과 호스트로 요청이 전달되고요.
페이지 새로고침하시면 CORS 설정 없이도 HTTP 요청이 잘 처리되고 세션 인증도
수행됨을 확인하실 수 있습니다.