안녕하세요. 이번 시간에는 웹 프론트엔드에서 API 요청 시 Session 인증을
활용하는 방법에 대해서 살펴보겠습니다.
Vanilla, JavaScript를 사용하여 API 요청을 다루는 방법을 설명하지만, 이
내용들은 React나 Vue, Svelte와 같은 UI 라이브러리 내에서도 동일하게 적용할
수 있습니다.
웹브라우저의 보안 정책으로서 다른 출처, 즉, 프로토콜, 도메인, 포트 번호 중 어느
하나라도 다른 주소로 HTTP 요청을 보낼 경우 CORS 정책에 의해 웹브라우저에서 해당
요청을 중단시킵니다.
http://localhost:8000 주소에서 장고 개발 서버가 서비스되고 있고요.
앞선 강의에서 구현했던 http://localhost:8000 블로그의 Who Am I
페이지에 접속하면 세션 인증이 동작하여 로그인 유저명이 출력됩니다.
http://localhost:8000의 블로그 주소로 접속하시면 이 템플릿으로 응답을
하는데요
자바스크립트로 fetch 요청을 하는 웹페이지 주소와 요청을 받는 주소가 같은 출처이기 때문에
패치 요청을 보낼 수 있고 세션 인증도 동작합니다
이 HTML 코드의 응답을 장고 개발 서버와 다른 주소인
http://localhost3000 주소를 보시면 포트 번호가 다르죠
이에 다른 출처가 됩니다
http://localhost3000 주소의 페이지에서 서비스하고 이 페이지에서
http://localhost8000 주소의 블로그의 Who Am I 페이지로 HTTP
요청을 보내면 지정 서버로 요청이 보내지고 웹브라우저가 응답은 받지만 다른 출처 위기에
CORS 정책을 위반하여 웹브라우저가 예외를 발생시키며 해당 패치 API 호출을
중단시킵니다.
CORS 정책은 오로지 웹브라우저만의 보안 정책입니다.
그래서 웹브라우저를 통하지 않는 서버 간의 요청에서는 CORS 정책이 없습니다.
http://localhost:8000의 블로그 페이지에서 자바스크립트를 통해
http://localhost:8000 블로그의 후엠아이 주소로 http 요청이 보내지고
정상적으로 세션 인증이 수행되어 200 응답을 받았었습니다.
이 요청에서 Session ID 쿠키도 자동으로 전달이 되었었죠
블로그의 index.html 템플릿 코드를 그대로 복사해서 HTML 폴더의
csr-api-call.html 경로로 복사하겠습니다
이 HTML 파일을 Django를 통해 서빙하진 않겠고요
파이썬 정적 서버를 활용해서 3000번 포트에서 서빙하겠습니다
http://localhost:3000의 csrapicall.html 페이지를 열어주세요.
그럼 에러 응답이 확인됩니다.
http://localhost8000의 블로그 페이지의 HTML 코드와 같은 HTML
페이지인데요.
http://localhost3000 페이지에서는 patch API 요청이 실패하고
있습니다. 브라우저 개발자 도구의 콘솔 탭을 열어주시고요.
에러 로그가 있는데 읽어봅시다.
http://localhost:3000 출처에서 http://localhost8000의
블로그의 주소로 패치 HTTP 요청을 했는데 CORS 정책을 위반하여 패치 API 호출을
강제로 중단시켰다고 합니다.
이를 허용하려면 http://localhost:8000의 Blog의 WhoAmI 요청에
응답해서 Access Control Allow Origin 응답 헤더가 필요하다고 합니다.
http://localhost:8000의 Blog의 WhoAmI 주소로 http 요청도
들어갔고요.
브라우저에서 응답도 받았습니다.
세션 인증에는 실패하여 401 응답을 받았네요
그런데 CORS 정책 위반으로 브라우저에서 패치 API 호출을 강제로 중단시켰고요 그래서
예외가 발생하여 여기 catch 코드가 동작한 상황입니다
요청 헤더를 보시면 쿠키 요청 헤더도 없죠?
패치 API로 HTTP 요청을 보낸 웹페이지와 HTTP 요청을 받는 웹페이지의 주소가
달라서 발생한 상황입니다.
Django 서버와 웹 프론트엔드 서버에 어떤 주소를 지정하고 배포하느냐에 따라 4가지
경우의 수가 있습니다.
각 4가지 경우의 수를 간략히 살펴보고 각 상황에 대해서 실습을 해보겠습니다.
첫 번째로, 장고 서버와 웹 프론트엔드 서버를 같은 호스트와 포트에서 동시에 운영하는
것입니다. 요청 URL을 통해서 장고 서버로의 요청과 웹 프론트엔드 서버로의 요청을
분기하여 처리하는 방식입니다.
Nginx 웹 서버를 Reverse Proxy 역할로 중간에 두기도 하고요.
장고 서버를 경유해서 웹 프론트엔드 서버로 요청을 전달하기도 합니다.
장고와 웹 프론트엔드 서버가 서로 다른 서버이지만 웹블라우저가 보기에는 같은 프로토콜,
같은 도메인, 같은 포트를 가지는 동일 출처이기에 CORS 설정이 필요 없습니다 장고
웹페이지의 쿠키가 웹 프론트엔드 서버의 페이지에 기본으로 공유가 되고요 별도 인증 과정
없이 패치 요청만으로 쿠키가 자동 전송되어 세션 인증이 처리됩니다
두 번째로, 장고 서버와 웹 프론트엔드 서버를 같은 호스트를 사용하되 다른 포트에서
운영하는 것입니다
주로 개발 환경에서 하나의 물리 서버에서 다른 포트로 서버를 띄우는 상황이 이에 해당됩니다
Localhost 8000 주소와 Localhost 3000 주소와 같은 상황 말이죠.
이 경우 포트 번호가 다르기 때문에 요청을 받는 Django 서버 측에서 CORS 설정을
하여 HTTP Localhost 3000 주소로부터의 HTTP 요청을 허용해 줘야만
HTTP Localhost 3000 주소의 웹페이지에서 HTTP 요청을 보내고 그 응답을
받을 수 있습니다.
Django 서버에서는 CORS 정책 설정을 위해서 Django CORS Headers
라이브러리를 활용하시면 편리합니다.
프로토콜과 호스트는 같고 포트 번호만 다른 상황이기에 Django 웹페이지의 쿠키는 기본
공유됩니다.
JavaScript를 통해 패치 요청을 보낼 때 Credential Include 설정을
적용하면 해당 도메인의 쿠키가 자동 전송되어 세션 인증이 처리됩니다.
세 번째로, Django 서버와 웹 프론트엔드 서버를 같은 루트 도메인으로 운영하는
것입니다 서브 도메인이 다르기 때문에 다른 출처이고요
HTTP 요청을 받기 위해서는 Django 서버에서 CORS 설정이 필요합니다
서브 도메인이 달라서 장고 웹 페이지의 쿠키가 기본 공유되지 않는데요
장고 설정에서 session-cookie-domain 설정으로 루트 도메인을 지정하면 그
루트 도메인에 한해서 그 루트 도메인의 모든 웹 페이지에 쿠키가 공유됩니다
자바스크립트 패치 요청을 보낼 때 credentials-include 설정을 적용하면 해당
도메인의 쿠키가 자동 전송되어 세션 인증이 처리됩니다
마지막 네 번째로, Django 서버와 웹 프론트엔드 서버의 도메인이 전혀 다른
상황입니다. 도메인이 달라 다른 출처이기에, HTTP 요청을 받기 위해서는 Django
서버에서 CORS 설정이 필요합니다.
Django 서버의 쿠키를 도메인이 다른 웹 프론트엔드 페이지에 공유할 수는 없습니다.
Session 인증 외에, JSON 웹 토큰 등의 다른 인증 방법 검토가 필요한 상황입니다.
장고 서버와 웹 프론트엔드 서버가 하나의 서비스로 운영하는 경우가 99%일 텐데요.
서로 도메인을 맞춰 1번 상황이나 3번 상황으로 운영하시어 Session 인증을 활용하시길
적극 권장 드립니다.