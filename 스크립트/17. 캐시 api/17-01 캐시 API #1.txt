안녕하세요. 이번 시간에는 Django에서의 캐시 지원에 대해서 살펴보겠습니다.
캐싱은 어떤 함수나 요청을 처리함에 있어 매번 계산이나 요청을 하지 않고, 같은 계산,
같은 요청에 대해 이미 계산되었거나 응답 받은 결과를 메모리 혹은 디스크에 저장하여
재사용하는 기술을 말합니다.
데이터베이스는 대개 디스크에 데이터를 저장하고요,
캐싱은 대개 메모리에 데이터를 저장합니다.
메모리는 디스크보다 10배에서 40배 이상 빠른 데이터 입출력 속도를 가집니다.
데이터베이스 조회 내역을 캐싱했을 때 캐시에 올바르게 데이터가 캐싱되어 있다면 캐싱을 통해
서버 응답 속도를 크게 향상시킬 수 있습니다.
하지만 캐싱을 잘못 사용하면 데이터베이스에서 변경된 내역이 캐시에 반영되지 않는 데이터
일관성 문제가 생길 수 있고요.
민감한 데이터가 캐시에 저장될 경우 보안 문제가 생길 수도 있습니다.
캐싱은 모든 애플리케이션 계층에 적용할 수 있습니다.
React 등의 프론트엔드 계층에서 메모리의 API 서버 응답을 캐싱할 수 있고요.
HTTP 캐싱 헤더를 활용하여 웹블라우저나 CDN 서버, 엔진엑스 서버단에서 캐싱을 적용할
수도 있겠고요.
장고와 같은 애플리케이션 서버에서 HTML 응답, API 응답, 데이터베이스 조회 내역을
메모리나 memcached 서버 혹은 Redis 서버 등 빠른 입출력 속도를 가지는
스토리지에 저장하고 이를 활용할 수 있습니다.
본 영상에서는 Django에서 지원하는 두 가지 캐싱 방법에 대해서 간략히 살펴보겠습니다.
메모이제이션은 함수의 계산 결과를 메모리에 저장하여 반복 계산을 방지하는 기법을 뜻합니다.
피보나치 수열에서 35번째 값을 재귀 함수로 구현해봤습니다.
피보나치 수열은 반복문을 활용해서 계산하면 훨씬 효율적이지만 메모이제이션 예시를 위해 제기
함수로 구현해봤습니다.
35번째 수열 값을 3번 계산하면 매번 약 3.2초가 걸렸고요.
피보나치 함수는 무려 약 3000만 번씩이나 호출되었습니다.
그런데 여기에 메모리제이션 기법과 장식자 문법을 적용하면 함수 호출 횟수가 비약적으로 줄어
첫 번째 호출에서는 36번이지만 두 번째 호출부터는 같은 수의 계산이기에 함수 호출 없이
메모리에 저장된 값을 읽어 반환했습니다.
메모리제이션은 함수 계산 결과를 메모리에만 저장하는데요.
우리가 사용할 수 있는 저장 공간은 디스크나 캐시 서버 등 다양하죠.
장고의 캐시 API를 활용하면 일관된 단 하나의 API로 메모리, 디스크,
memcached, redis 등의 캐시 백엔드를 사용하실 수 있습니다.
이렇게 Cache API를 사용하고요.
각 Cache 백엔드에 대한 설정은 프로젝트 세팅스의 Caches 설정에 합니다.
Django 프로젝트 기본에는 디폴트 Cache 백엔드로서 로컬 메모리 Cache 백엔드가
설정되어 있습니다.
첫 번째 예시 코드를 실습해 보겠습니다.
재기 함수로만 구현된 피보나치 수열입니다.
세 번의 실행 모두 35번째 피보나치 수열을 계산하는데요 매번 3.3초가 걸렸고 함수 호출
횟수는 모두 3천만 번입니다
이번에는 메모이제이션을 적용한 코드입니다 실행해 보시면 계산 결과는 같은데요 실행이 금세
끝났네요 첫 번째 실행에서는 호출 횟수가 36번으로 호출 횟수와 수행 시간이 비약적으로
줄었습니다 세 번째 예시 코드는 Django의 Cache API를 사용하고요 디폴트로
로컬 메모리 캐시 백엔드를 사용합니다.
앞선 메모리제이션과 마찬가지로 로컬 메모리는 현재 프로세스에서만 값을 사용할 수 있고요.
다른 프로세스나 다른 서버와는 값을 공유할 수 없는데요.
Django에 캐시 API를 사용하니까 설정하기에 따라 다른 서버와 피보나치 수열 계산
결과를 공유할 수 있습니다.
장고 기본에서는 로컬 메모리, memcached, redis, 데이터베이스, 파일 시스템
등의 다양한 캐시 백엔드를 지원합니다.
로컬 메모리에 캐싱하면 프로세스나 서버를 넘어 캐시를 공유할 수는 없지만 서버가 단일
프로세스이거나 프로세스 서버 간의 캐시 공유가 필요 없다면 로컬 메모리 캐시 백엔드를
사용하시면 좋습니다.
왜냐하면 별도의 인프라 관리가 필요 없기 때문입니다.
memcached는 캐싱 전문 서버니깐요.
여러 프로세스, 여러 서버에 걸쳐 캐싱 내역을 공유할 필요가 있을 때 사용합니다.
PurePython으로 구현된 PyMemCache 라이브러리의 Cache 백엔드와 C로
구현된 PyLibMC 라이브러리의 Cache 백엔드가 지원됩니다.
memcached 외에도 Redis를 Cache 백엔드로 사용하실 수 있습니다.
Redis 라이브러리 기반의 Cache 백엔드와 Django Redis 라이브러리 기반의
Cache 백엔드가 지원되는데요.
Django Redis 라이브러리에서는 Django 기본에서 지원해주는 Cache API
외에도 Redis만의 기능을 활용하는 다양한 기능을 지원해주니 Redis Cache
백엔드를 사용하신다면 Django Redis 라이브러리 사용을 추천드립니다.
장고에서는 멀티 데이터베이스를 지원하듯이 멀티 캐시를 지원합니다.
다양한 백엔드의 캐시를 원하시는 구성으로 설정하신 뒤에 캐시 이름 지정만으로 해당 캐시
백엔드를 사용하실 수 있습니다.
장고의 Cache, Low Level API를 표로 정리해 봤습니다.
참고하시고요. 주로 Set과 Get API를 활용해서 Cache를 저장하고 꺼내시게
되고요. 여러 값을 저장하고 꺼내실 때에는 Set Many API와 Get Many
API를 활용하시면 보다 빠른 입출력이 가능해집니다.
장고 기본에서는 두 개의 고수준 캐싱 API를 지원합니다.
첫 번째로 뷰 반환 값을 캐싱하는 캐시 페이지 장식자입니다.
첫 번째 인자는 만료 시간을 초 단위로 지정하고요.
캐싱 키는 요청 URL과 현재 요청의 랭기지 코드, 현재 요청의 타임존이 사용됩니다.
즉, 같은 URL, 같은 언어, 같은 타임존 설정에서는 요청 유저가 다른 유저라 할지라도
같은 응답을 받게 됩니다.
이는 요청의 모든 유저에게 같은 응답을 하는 이벤트 페이지에 적합합니다.
유저별로 다른 응답이 있다면 절대 사용하셔서는 안 되고요.
특정 유저의 컨텐츠가 캐싱되어 다른 유저에게 제공될 수 있습니다.
HTML에서 유저별로 다른 부분이 있다면 기본 HTML에서는 같은 응답을 하되
자바스크립트를 통해 유저별로 다른 컨텐츠를 웹 페이지에서 갱신하는 방향으로 구현해 보실 수
있습니다. 두 번째로 템플릿 내에서 지정 블록을 캐싱하는 태그입니다.
한 템플릿 내에서 유저별로 혹은 요청별로 다른 컨텐츠가 있다면 태그를 활용해 보세요.
캐싱할 부분만 태그로 감싸시면 됩니다.
첫 번째 인자는 만료 시간을 초 단위로 지정하고요.
두 번째 인자는 fragment 인자인데요.
캐싱 식별자입니다.
이 두 번째 인자는 변수처럼 보이지만 문자열로 사용됨에 주의해주세요.
세 번째 인자부터는 원하시는 개수만큼 인자를 지정하실 수 있고요.
변수를 사용하실 수 있습니다.
캐시 페이지 장식자는 뷰 함수에 적용하고요 응답의 상태 코드가 200이라면 그 응답을
캐싱합니다 블로그 앱의 인덱스 뷰를 포스트 목록을 템플릿을 통해 반환토록 변경합니다
부모 템플릿도 변경하고요 데이터베이스에서 포스팅 목록을 조회하여 HTML로 응답합니다
로클로스트8000의 블로그 주소에서 뷰 응답을 확인하실 수 있고요.
페이지 새로고침을 해보면 매번 같은 응답이고요.
매번 3개의 데이터베이스 쿼리가 수행되어 이 HTML 응답이 만들어졌습니다.
인덱스 뷰 함수에 캐시페이지 장식자를 적용하고요.
만료 시간은 600초, 즉 10분으로 지정합니다.
페이지 새로고침에 보시면 3개의 캐시 API가 호출되었다고 합니다.
현재 요청에 대한 캐시 키가 있고요.
이 캐시 키로 캐시 내역을 조회하고요.
캐시 백엔드에 저장된 캐시가 없으니 인덱스 뷰를 호추하여 HTML 응답을 만들고요.
생성된 HTML 응답을 지정 캐시 키로 캐시 백엔드에 저장하고 HTML 응답을
클라이언트에게 돌려줍니다.
페이지 새로고침하면 이번에는 두 개의 Cache API가 호출되었고요.
수행된 데이터베이스 코디는 없습니다.
데이터베이스 조회 없이 이 HTML 응답을 받게 되었습니다.
10분 뒤에는 지정 Cache가 자동으로 제거되고요.
10분 뒤에 요청해서는 다시 데이터베이스에 코디하여 HTML 응답이 만들어지고요.
그 HTML 응답이 다시 Cache 백엔드에 저장됩니다.
혹은 캐시 백엔드에 직접 접속해서 해당 캐시를 삭제한 경우에도 각 뷰가 호출되고 다시 캐시
데이터가 쌓일 것입니다.
캐시 키, 문자열에서 이 부분은 고정된 문자열이고요.
16진수 32글자 문자열은 요청 URL을 MD5 해싱한 문자열이고, KOKR은 현재 요청의
언어코드 설정이고요.
UTC는 현재 요청의 타임존 설정입니다.
캐싱키에는 코리 파라메타를 포함한 URL이 기본으로 사용되고요 프로젝트 설정에
use-i18n 설정이 켜져 있다면 현재 요청의 언어 코드가 캐싱키에 추가로 사용되고요
디폴트로 켜져 있습니다
그리고 프로젝트 세팅스에 use-tz 설정이 켜져 있다면 현재 요청의 타임존 설정이
캐싱키에 추가로 사용됩니다
디폴트로 켜져 있습니다
캐싱되기 전에는 이렇게 데이터베이스 조회가 이루어지지만 캐싱된 내역으로 응답을 할 때에는 이렇게
데이터베이스 조회 없이 캐싱된 응답 내역으로 응답을 받게 됩니다.
그런데 캐시페이지 장식자 쓰실 때 주의하실 점이 있습니다.
캐시키로 요청 URL 문자열이 그대로 사용되는데요.
Query 파라메타 포함하여 MD5로 해싱된 문자열이 해싱 키에 사용됩니다 요청 URL의
Query 파라메타에서 같은 Query 파라메타인데 순서가 바뀌면 다른 Cache 키로
생성되어 다른 Cache로 저장됩니다
이는 비효율적인 것이 아니라 오히려 효율적인 접근입니다.
요청 URL을 캐시키로 사용하는 것은 HTTP에서 각기 다른 요청을 구분하고 캐시된 결과를
정확히 반환하기 위한 중요한 메커니즘입니다.
웹블라우저, CDN, 프록시 서버에서도 요청 URL을 키로 사용하여 캐싱을 수행합니다.
이는 네트워크 전반에서 일관된 캐싱 전략을 유지하게 하여 캐시된 콘텐츠를 빠르고 효율적으로
제공할 수 있게 합니다.


이번 시간에는 Django에서의 캐시 지원에 대해 살펴보았습니다. 캐시는 반복적인 계산이나 요청을 메모리나 디스크에 저장하여 재사용하는 기술입니다. 데이터베이스는 디스크에 저장되지만, 캐시는 빠른 입출력 속도를 가진 메모리에 데이터를 저장합니다. 이를 통해 서버 응답 속도를 크게 향상시킬 수 있습니다. 하지만 잘못 사용하면 데이터 일관성 문제가 발생할 수 있고, 민감한 데이터가 캐시에 저장될 경우 보안 문제가 생길 수 있습니다.

캐싱은 프론트엔드, 서버, 애플리케이션 계층 모두에서 적용될 수 있습니다. Django에서는 HTML 응답, API 응답, 데이터베이스 조회 내역 등을 메모리나 캐시 서버(예: memcached, Redis)에 저장하여 효율적으로 처리할 수 있습니다.

Django에서 지원하는 주요 캐시 방법:

1. 메모이제이션: 함수의 계산 결과를 메모리에 저장해 반복 계산을 방지하는 기법. 예시로 피보나치 수열을 계산하는 방식에서 메모이제이션을 활용하여 성능을 크게 향상시킬 수 있습니다.
2. Django 캐시 API: Django에서는 Cache API를 통해 다양한 캐시 백엔드를 설정할 수 있습니다. 기본적으로 로컬 메모리를 사용하지만, memcached나 Redis 등 다른 백엔드를 설정할 수도 있습니다.
3. 캐시 페이지 장식자: 뷰 함수의 반환값을 캐싱하는 방법으로, 동일한 요청에 대해 반복된 계산을 방지합니다.
4. 캐시 태그: 템플릿에서 특정 블록만 캐시하는 방법으로, 동적인 부분은 제외하고 정적인 부분만 캐시할 수 있습니다.
캐시 설정에서는 캐시 키를 URL 및 요청 정보(언어 코드, 타임존 등)에 따라 생성하며, 이를 통해 요청 URL에 따라 정확히 캐시된 데이터를 제공합니다.

주의사항:

캐시 키는 요청 URL의 Query 파라메타 순서에 민감하므로, 순서가 바뀌면 다른 캐시 키로 처리됩니다.
캐시 설정 시 데이터베이스 조회를 줄여주지만, 캐시 만료 시간 등을 잘 설정해야 합니다.
이러한 방법들을 통해 Django에서 캐싱을 잘 활용하면 서버 성능을 크게 향상시킬 수 있습니다.