자 이번에는 데이터베이스를 활용을 해 보겠습니다
먼저 song 이라는 이름의 모델 클래스를 만들 거고요
모델 클래스를 만든 다음에 이 모델 클래스에 맵핑이 되는 데이터베이스 테이블을 장고의
마이그레이션 기능을 활용을 해서 만들어 보겠습니다
그래서 앞서 정의한 데이터 클래스인 song을 필드 정의분만 변경을 하겠습니다
이렇게 변경을 하시고 나서 make migrations app 이름 그리고
sqlmigrate app 이름에 방금 이 명령으로 0001__initial.py가 생성이
되는데 이 파일명을 그대로 쓰시면 방금 생성된 마이그레이션 파일을 수행하면은 데이터베이스에
어떤 SQL이 수행이 되는지, 아직 수행된 건 아니에요.
어떤 SQL을 수행하는지 볼 수 있거든요.
크레딧 테이블입니다.
이때 보여질 때 현재 데이터베이스에 설정되어 있는 데이터베이스가 현재 Settings에
Databases라는 설정에 데이터베이스 설정을 하는데 거기에 SQLite가 설정되어
있으면 SQLite SQL 코드가 보여지고요 MySQL이면 MySQL 코드,
PostgreSQL이면 PostgreSQL 그 DB 엔진에 맞춰서 출력이 됩니다
그리고 SQL 확인한 다음에 Migrate 명령을 내리시면 해당 Migration이 적용이
되었다 적용이 되면 현재 Django 프로젝트가 받아보고 있는 데이터베이스에 이 SQL이
수행이 된 거고요
Show Migrations 명령을 통해서 해당 Migration 내역이 적용된 상황임을
확인할 수 있습니다
코드도 하단의 링크를 통해서 제공을 해드리고 있습니다
Models.02.py 파일이 되겠구요
그리고 파이참에서 오른쪽에 이 데이터베이스 버튼을 클릭을 하시면 현재 장고 프로젝트에
연결된 데이터베이스 목록을 보실 수 있는데 프로젝트에서 현재 우리 데이터베이스가 있어요
이 파일을 더블 클릭하시면요 해당 데이터베이스와 연결을 만드실 수 있습니다
DB 만드는 게 아니에요
연결을 생성하는 겁니다
이렇게 목록을 펼쳐요 펼치면은 이제 테이블 목록이 0으로 나오시면은 새로 고침
이렇게 한번 해주세요 이제 이 db.sqlite3라는 데이터베이스에 생성되어 있는 테이블
목록입니다. 여기에 테이블을
더 추가하려고 합니다.
핫트랙에 모델 파일을 여신 다음에 현재 송 코드죠.
여기에서 모델 필드만 이 부분을 이렇게 바꿔줍니다.
db.sqlite3의 모델을 임포트합니다.
송에 멜론 언더바 UID가 있는데 여기에 코드를 조금 바꿔주셔야 돼요
멜론 디테일에 UID를 여기를 이렇게 바꿔주시고 그리고 하단에 보면 여기도 멜론 UID
두개를 바꿔주세요 이제 새로운 터미널을 클릭을 해서 여실 수 있어요 혹은 해당 터미널에
우클릭하시면 이렇게 터미널을 스플릿 할 수 있는 기능도 제공을 해 줄 겁니다
그래서 편하신 방법을 쓰시면 되고 저는 runserver 이제 터미너를 꼭 같이 켜두거든요
왜냐하면 서버 구동 중에 오류가 발생하면 이 런서버에 오류 메시지가 뜨기 때문에 오류
상황을 빠르게 파악할 수 있기 때문입니다
자 새롭게 터미너를 여셨으면 여기에서도 이제 가상환경 활성화 여부를 확인하시는 거예요 확인하시는 거에요
저는 왜냐하면 가상환경이 잘 활성화가 안됐네요
수동으로 활성화를 해주고요
아 제가 이렇게 필드 정의를 해두고 데이터 클래스를 정의를 안 지었어요
모델스의 모델을 상속을 받아야 되는데 그쵸 얘를 빼야 됩니다
빼시고 그리고 여기도 필요 없으니까 지우겠습니다.
모델로 바꾸고 나서 이렇게 마이그레이션 파일이 생성이 되었습니다.
SQL 마이그레이트 명령으로 핫트랙 앱에 있는 0.0.0.1 initial 이라는 파일이
수행이 되면 어떤 SQL이 수행되는지 확인을 하기 위해서 명령 내려보시면 이렇게 내역이
보여지죠.
CREATE TABLE 테이블명은 hottrack_underbar_song 이라는
이름이구요 ID라는 필드로 생성되고 등등등이 있습니다
LIKE COUNT라는 필드에 대해서 positive integer 필드라고 썼는데
데이터베이스의 제약사항으로 이렇게 LIKE COUNT는 항상 0 이상이어야 된다는
제약사항도 알아서 추가를 해주고 있네요
참 좋습니다 자 이제 python-manage.py migrate에 hottrack 이라고
쓰시고요 엔터를 입력하시면 방금 해당 마이그레이션이 적용이 되었구요
이제 이 테이블 내역에서 새로고침을 하시면은 이렇게
hottrack-underbar-song 이라는 테이블이 추가가 되었음을 확인하실 수
있어요 펼치시고 펼치시면은 앞서 확인하셨던 이 내역으로 생성이 되어 있습니다
현재 핫트랙 언더바 송이라는 테이블을 더블 클릭해보시면 이 테이블에는 아무런 데이터도
없습니다 커스텀 관리 명령을 통해서 데이터베이스에다가 앞서 사용했던 json 파이들의
내역을 db에다가 한번 넣어볼게요
넣으면 이런 모습이 될 테고 manage.py load_melon_songs라는
이름에 커스텀 명령을 추가할 거에요
이 명령을 추가하려면 우리 앱에서 매니지먼트 밑에 원하는 파일명을 쓰시면 이 파일명을 이
명령 이름으로 사용을 하는 것입니다
그래서 어떤 앱에 있는 이 커스텀 관리 명령을 사용하려면 이 앱이 장고 프로젝트에
Installed Apps에 등록이 되어야만 사용을 할 수 있습니다
그리고 이 명령을 구현할 때에는 항상 BaseCommand라는 클래스를 상속을 받구요
help를 통해서 도우마를 추가하고 handle이라는 메서드를 통해서 이 명령이 수행되었을
때 수행될 코드를 나열하면 됩니다.
핸들 메소드 안에서 명령이 수행이 되면 해당 URL로부터 JSON 스트링을 읽어서
SongList를 만들죠.
현재의 Song 클래스는 Model 클래스입니다.
이 코드를 통해서 Model 클래스의 인스턴스로 이루어진 List를 만든 거죠.
장고에서는 모델 인스턴스에 대해서 점 세이브 메서드를 호출하면 데이터베이스로 저장을 할 수
있는데요 현재 곡이 총 100곡인데요 100개의 송 인스턴스에 대해서 점 세이브 메서드를
호출하면 순서대로 100개의 인서트 쿼드가 날아가는데 그렇게 하기보다는
song.object.bulk_create를 활용하시면요
여기에 model instance list를 지정하시고 배치 사이즈에다가 원하는 사이즈를
지정하잖아요
지정하면은 해당 크기만큼 인서트 쿼드를 모아서 이 배치 사이즈 단위도 한 번에 DB에다가
실행을 합니다 DB 성능에 따라서 숫자를 천이든 만이든 키우실 수 있겠구요
이렇게 하시면 보다 빠르게 인서트를 하실 수 있겠구요
그리고 옵션으로 Ignore Conflicts True 라는 옵션을 주시면은 혹시 키 중복
같은 거 있잖아요
그런 게 발생해서 충돌이 발생하더라도 무시하겠다라고 하시면은 이 옵션을 넣어 주시면
되겠습니다 이후에 데이터베이스에 있는 이 레코드 개수를 조회하게 되면 총 100개라고
이렇게 출력이 됩니다
이 명령도 제가 준비해놓은 코드가 있습니다
로드 언더바 멜론 언더바 송수점 파일이 있죠
이 파일을 생성을 해줄텐데 경로 잘 보시고 잘 생성해주세요
핫트랙 앱에서 파일에서 이렇게 생성을 해주시면은 앱 이동 밑에 매니지먼트 밑에 커맨드 밑에
로드 언더바 멜론송스.파이입니다.
해당 코드를 이렇게 복사를 해볼게요
python manage.py --help 라고 입력을 해보시면 현재 장고 프로젝트에서
사용할 수 있는 장고 관리 명령의 목록을 보실 수 있습니다
이 중에 핫트랙 앱에서도 load underbar melon underbar songs
라는 명령이 지원됨을 확인하실 수 있죠
load underbar melon underbar songs 구요
여기도 help 을 입력해 보시면 이렇게 추가로 설명도 이런 헬프 도움말도 보실 수 있게
됩니다 한번 실행을 해 볼게요
빼고 실행을 해 주시면 이렇게 총 100개를 로딩했고 100개를 저장했다고 하죠 리스트만
만들고 나서 리스트의 크기를 봤구요 출력을 해봤고 db에 저장하고 나서 개수도 봤습니다
데이터베이스에 가서 테이블명 클릭해보시면 이렇게 총 100개가 로딩이 되었음을 확인하실 수
있습니다. 이제 indexView함수에서도 매번 indexView함수가 호출을 낼 때마다
외부 데이터를 로딩하는 것이 아니라 현장 서비스 안에 있는 데이터베이스에 저장된 데이터를
조회하도록 하면은 좀 더 효율적이겠죠
이제 장고 모델을 통해서 object.all 하시면은 쿼리셋 타입의 객체이구요
이 쿼리셋이 있고 아직 데이터베이스에다가 셀렉트 코디 한 거 아닙니다
검색어가 있을 경우에 이 코디셋에서 필터죠 리스트는 필터가 없어요
코디셋이니까 필터가 있는 거고 여기에서 Q를 통해서 오아 조건 또는 조건이죠
그래서 네임이라는 필드에 코디가 포함되어 있거나 아티스트 네임이라는 필드에 언더버 두
개입니다 코디가 포함되어 있거나 앨범네임에 코디가 포함되어 있거나 라는 이런 조건을
부여하는 것이죠
그리고 song_qs라는 이 코디색 객체를 song underbar list라는 이름으로
넘겨 주겠습니다 자 view 함수를 이렇게 열어 보겠구요
자 이제 이 코드가 필요가 없는 거죠
이 코드도 필요가 없습니다
그쵸 그러면 이제 song_qs는 제가 song.object.all이고 type은
querySet이라는 타입이라고 말씀을 드렸죠?
검색어에서 song_qs는 song_qs.filter라고 써주겠고요 다음에 q에서 네임은
이렇게 query라고 써주고 q객체도 models에 q를 해주시고요
자, 저장하시면 이렇게 song.qs가 만들어졌고 이제 이렇게 넘겨주겠습니다
view에서 queryset라고 짓는 것은 이 이름만 봐도 코디셋임을 인지하려고 쓴 거고요
템플릿단에서 song_list라고 쓴 것은 장고의 여러 라이벌리들이 코디셋을 참조할 때에도
언더바 리스트로 참조하는 경우가 많기 때문에 그런 라이벌리들과 좀 맞춰주려고 언더바 리스트로
사용을 했습니다
이렇게 하시고 새로 고침해보시면 페이지가 동일하게 동작하지만 이제는 IndexView가
호출이 될 때 외부 데이터 로딩 없이 서비스 안에 있는 데이터를 조회해서 보여주기 때문에
보다 안정적인 서비스 제공이 가능해진 것이죠