HTMX 라이브러리는 45KB의 작은 용량을 가지고 있습니다.
자바스크립트 지원도 있지만, 대개의 HTML 마크업만으로 서버로 원하는 시점에 HTTP
요청을 보내고, 그 응답을 지정 요소로 업데이트하는 방식으로 동작합니다.
HX GET 속성 외에도 HX POST, PUT, PATCH, DELETE 등을
지원하고요. 각 이름의 요청을 서버로 전송합니다.
포스트 요청을 보내려면 폼 태그를 구성하거나 자바스크립트 코드를 썼어야 했죠.
딜리트 요청은 자바스크립트를 썼어야 했는데 이렇게 HTML 마크업만으로 손쉽게 원하는
방식의 요청을 보낼 수 있습니다.
HX Trigger는 HTTP 요청을 실행하는 조건이고요.
다양한 조건을 지원하며 여러 조건을 섞을 수도 있습니다.
Change들을 지정하여 대상 요소의 값 변경에 반응할 수도 있고요.
Rebuild를 지정하여 대상 요소가 화면에 보여질 때 반응할 수도 있습니다.
한 페이지에 많은 수의 이미지가 있을 때 그냥 태그에 src 속성만 지정하면 그 이미지들이
화면에 보여지지 않아도 브라우저에서 모두 로딩해 버리거든요.
특히 쇼핑몰 상세 페이지나 웹툰은 이미지가 세로로 수십 개 이상의 고화질 이미지가 있는데
유저가 페이지를 스크롤하지 않았음에도 이미지를 보지 않았음에도 이미지가 로딩되면 불필요한
리소스 낭비이죠.
이때 레이지, 게으르게 이미지를 로딩하면 되는데요.
HTMX를 사용하면 별도의 라이브러리를 사용하지 않아도 리빌드 트릭을 통해 손쉽게 구현할
수 있습니다.
hx-target으로 HTTP 응답을 반영할 대상 요소를 지정합니다.
this는 hx-target이 지정된 요소 자신을 의미하고요.
멀리 떨어진 요소는 CSS 셀렉터를 직접 지정하실 수도 있고, Closist와 CSS
셀렉터를 조합해서 조상 요소 중에 가장 근접한 요소를 지정할 수도 있습니다.
hx-swap으로 HTTP 응답을 대상 요소에 적용하는 방법을 지정합니다.
Default로는 innerHTML로 동작하고요.
이에 대해서는 다음 슬라이드에서 이어서 설명하겠습니다.
이미 태그의 1페이지가 로딩된 상황이라고 가정해 보겠습니다.
2페이지 로딩 버튼을 클릭하여 2페이지의 태그 목록을 로딩하려 합니다.
2페이지 요청에 대한 서버 응답으로 레이아웃 없이 이렇게 2페이지 컨텐츠만 응답을 주도록
구성했다고 가정해 보겠습니다.
htmx에서는 서버에서 받은 그대로 대상 요소에 반영할 뿐이니까요.
hx-swap 설정에 맞춰 서버에서 적절히 HTML 마크업을 구성해 주어야 합니다.
htmx는 클라이언트 라이벌리일 뿐이니까요.
다양한 언어, 플레임워크의 서버와 연계할 수 있습니다.
HTMX 요청에서는 요청 헤더에 HxRequest 헤더의 소문자로 문자열 True 값이
전달됩니다.
Django에서는 이 헤더를 확인하여 현재 요청이 HTMX를 통한 요청인지 알 수
있습니다. HTML 요청일 때에는 레이아웃 없이 컨텐츠만 응답하고요.
HTML 요청이 아닐 때에는 레이아웃과 함께 전체 레이아웃으로 응답하도록 하는 거죠.
hxswapinnerhtml 속성을 지정하면 지정 요소의 내용을 덮었습니다.
그러니 기존 1페이지 내용은 제거되고 2페이지 내용으로 대체되는 거죠.
Outer HTML 속성으로 지정하면 지정 요소 자체를 덮었습니다.
지정 요소가 제거되는 거죠.
이 경우에는 이 페이지 컨텐츠를 감싸는 div 태그가 없으니 페이지 레이아웃이 깨지겠네요.
서버에서 div까지 랩핑하여 응답을 주면 레이아웃이 깨지지 않을 것입니다.
before-begin 속성에서는 지정 요소 이전에 추가하고요.
before-end 속성을 지정하면 지정 요소의 내용 끝에 추가합니다.
페이스북이나 트위터 등 다양한 소셜 미디어에서 많이 사용하는 방식이죠.
before-begin 속성은 지정 요소의 내용 처음에 추가합니다.
before-end 속성은 지정 요소 다음에 추가하고요.
delete 속성은 서버 응답을 지정 요소에 반영하지 않고요.
지정 요소를 그냥 삭제합니다.
삭제 기능 구현에 적합합니다.
논속성은 요청을 보낼 뿐 지정 요소에 대해서는 아무런 작업을 수행하지 않습니다.