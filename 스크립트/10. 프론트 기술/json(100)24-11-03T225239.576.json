<<<<<<< HEAD
function 키워드로 정의된 함수는 호이스팅 되기에 함수 정의부 위에서 호출할 수 있습니다. var 키워드로 함수를 정의할 수 있는데요.
=======
function 키워드로 정의된 함수는 호이스팅 되기에 함수 정의부 위에서 호출할 수 있습니다. 
var 키워드로 함수를 정의할 수 있는데요.
>>>>>>> c753b33e5a2263a502dd7d3e57bc41ae23fae5ce
var로 정의된 hello1 변수는 호이스팅 되지만, 함수 정의부 위에서는 undefined 상태로 참조가 되고요.
해당 변수에 함수가 할당되는 시점에 함수가 정의됩니다.
그러니 함수 정의부 상단에서는 함수를 호출할 수 없습니다.
바가 아닌 ret이나 const로 함수를 정의하면 호이스팅 되지 않기에 함수 정의부 상단에서는 그 함수를 호출할 수 없습니다.
함수 정의부 상단에서 함수를 호출하려면 이렇게 레퍼런스 에러가 발생합니다.
호이스팅 메커니즘은 자바스크립트 특유의 동작 방식인데요.
코드의 가독성과 예측 가능성 측면에서 혼란을 초대할 수도 있습니다.
변수와 함수가 실제 작성된 위치와 다른 위치에서 실행되거나 접근 가능해지기 때문입니다.
React와 같은 현대적인 자바스크립트 라이브러리와 프레임워크를 사용할 때에는 const나 let을 통해 블록 스코프를 활용한 개발이 일반적입니다.
이는 함수와 변수가 선언된 블록 내에서만 유효하게 하여 코드의 가독성을 향상시키고 예측 가능한 동작을 보장하는 데 도움을 줍니다.
파이썬에서 함수를 구현하는 문법은 이렇게 딱 두 개 뿐입니다.
hello1과 hello2 함수는 같은 동작을 합니다.
<<<<<<< HEAD
자바스크립트에서 이렇게 거의 동일한 동작을 하는 함수를 여섯 가지 버전으로 만들어봤습니다. 
=======
자바스크립트에서 이렇게 거의 동일한 동작을 하는 함수를 여섯 가지 버전으로 만들어 봤습니다. 
>>>>>>> c753b33e5a2263a502dd7d3e57bc41ae23fae5ce
hello1 이름이 지정된 함수를 이렇게 정의를 해 봤고요.
위 파이썬처럼 익명 함수를 만들어서 변수에 대입하여 함수를 정의할 수도 있습니다.
펑션 키워드 없이 화살표로 익명함수를 만드실 수도 있습니다.
이를 화살표 함수, 에러 함수이라고 부릅니다.
<<<<<<< HEAD
화살함수에서는 함수 정의 시에 중관로도 쓰지 않고 표현식을 이어서 사용하면 리턴문을 쓰지않아도 그 값을 반환합니다.
=======
화살함수에서는 함수 정의 시에 중관로도 쓰지 않고 표현식을 이어서 사용하면 리턴문을 쓰지 않아도 그 값을 반환합니다.
>>>>>>> c753b33e5a2263a502dd7d3e57bc41ae23fae5ce
이 부분은 파이썬의 익명함수와 비슷하죠?
인자가 하나인 경우에는 이렇게 구현하겠죠?
화살 함수에서 인자가 하나인 경우에는 인자에서 소관로를 생략할 수 있습니다.
두 개의 숫자 인자를 받는 함수를 여섯 개 만들어 봤습니다.
mysum1 함수는 인자 1, 2를 받으면 3을 반환하고요.
mysum2 함수는 1, 2 인자를 받으면 이렇게 객체를 반환합니다.
mysum3 함수도 mysum4 함수도 객체를 반환합니다.
mysum5 함수는 조금 헷갈립니다.
어떤 값을 반환할까요?
undefined가 출력될 것입니다.
mysum5의 중괄호는 이렇게 함수블럭을 정의하는 목적으로 사용되었고요.
객체 생성 문법으로 사용되진 않았습니다.
그러니 반환 값이 없는 함수가 된 것이고요.
그러니 반환 값이 undefined가 된 상황입니다.
<<<<<<< HEAD
mysum6 함수는 we, mysum2, mysum3, mysum4 함수처럼 객체를반환합니다. 
=======
mysum6 함수는 we, mysum2, mysum3, mysum4 함수처럼 객체를 반환합니다. 
>>>>>>> c753b33e5a2263a502dd7d3e57bc41ae23fae5ce
화살 함수에서 return문 없이 객체를 반환하고자 하실 때에는 필히 중괄호를 소괄호로 감싸 주셔야 합니다.
자바스크립트를 개발하시면서 자주 보시게 될 코드이니 꼭 기억해 주세요.
객체에서 이렇게 function 키워드로 함수를 정의하면 포인트원 함수 내에서는 this가 현재 탐 객체를 가리키게 됩니다.
그런데 print1 함수 내에서 다시 function 키워드로 함수를 생성하시면 그 함수 내에서는 this가 변경됩니다.
그러니 dis.name을 출력해 보면 이렇게 undefined가 출력이 돼요.
함수 내에서 다시 function 키워드로 함수를 정리했는데 바깥 scope에 this를 참고하고자 하실 경우 이렇게 dis를 별도 변수에 저장해서 참조하실 수 있습니다.
이어서 소개할 화살 함수가 없던 시절에는 많이 사용하던 방법입니다.
this가 탐 객체를 가리키기에 this.name으로 이름이 정상 출력됩니다.
<<<<<<< HEAD
function 키워드로 정의된 함수에 bind 함수를 적용하면 함수 내에의 dis 값을 원하는 값으로 지정할 수 있습니다.
=======
function 키워드로 정의된 함수에 bind 함수를 적용하면 함수 내에의 this 값을 원하는 값으로 지정할 수 있습니다.
>>>>>>> c753b33e5a2263a502dd7d3e57bc41ae23fae5ce
이 방법도 이어서 소개할 화살 함수가 없던 시절에는 많이 사용되던 방법이었습니다.
dis가 탐 객체를 가리키기에 dis.name으로 이름이 정상 출력됩니다.
화살함수에서는 외부 스코프의 dis를 상속받습니다.
그러니 화살함수를 여러 번 중첩하더라도 dis가 동일한 대상, 즉 탐객체를 가리키게 됩니다. 
<<<<<<< HEAD
dis가 탐객체를 그대로 가리키고 있기에 dis.name으로 이름이 정상출력됩니다. 
=======
dis가 탐객체를 그대로 가리키고 있기에 dis.name으로 이름이 정상 출력됩니다. 
>>>>>>> c753b33e5a2263a502dd7d3e57bc41ae23fae5ce
화살 함수에서의 디스가 변경되지 않는 특성은 개발자가 보다 명확하고 예측 가능한 코드를 작성할 수 있도록 도와줍니다.
이로 인해 디스 바인딩에 관련된 일반적인 실수를 피할 수 있고요.
특히 모던 자바스크립트 애플리케이션 개발에서 함수를 보다 효율적으로 사용할 수 있게 됩니다. 
파이썬과 자바스크립트에서는 함수 인자에서 디폴트 인자를 지원하는데요.
두 언어 간의 동작이 조금 다릅니다.
자바스크립트 함수의 디폴트 인자로 지정한 표현식이나 함수 호출은 함수가 정의되는 시점에 호출되지 않고요.
디폴트 값이 필요한 시점에 표현식이 평가되고 함수가 호출됩니다.
<<<<<<< HEAD
자바스크립트에서 hello 함수를 이렇게 다섯 번 호출하는데 첫 호출에서는 age 인자를 지정했지만, 
두 번째, 세 번째, 네 번째, 다섯 번째 호출에서는 age 인자를 지정하지 않았습니다. 
그럼 default 값이 필요한 상황은 총 네 번 발생하죠.
=======
자바스크립트에서 hello 함수를 이렇게 다섯 번 호출하는데 첫 호출에서는 age 인자를 지정했지만, 두 번째, 세 번째, 네 번째, 다섯 번째 호출에서는 age 인자를 지정하지
않았습니다. 그럼 default 값이 필요한 상황은 총 네 번 발생하죠.
>>>>>>> c753b33e5a2263a502dd7d3e57bc41ae23fae5ce
그러니 실행해 보면 디폴트 값으로 지정한 getDefaultAge 함수 호출은 이렇게 총 4회 발생했습니다.
그런데 파이썬을 실행해 보면 함수 호출이 시작되는 시점에서 딱 1회 호출됩니다.
자바스크립트와 파이썬의 디폴트 인자 지정 문법이 같지만 파이썬에서 디폴트 값에 지정한 함수 호출은 hello1 함수가 정의되는 시점에 호출되고요.
그 반환 값인 10으로 디폴트 값이 지정됩니다.
두 언어 간의 동작이 전혀 다르죠?
파이썬에서도 자바스크립트처럼 디폴트 값이 필요한 시점에 함수가 호출이 되려면 어떻게 해야 할까요? 
첫 번째 방법으로 해당 인자의 디폴트 값을 non으로 지정하고요.
함수가 호출되고 나서 그 인자 값이 non이라면 함수를 호출해서 값을 변경하는 방법입니다.
그러면 이렇게 총 4회의 getDefaultAge 함수가 호출이 되죠.
혹은 default 인자로 함수 반환 값을 넘기지 않고 함수 객체를 전달하는 것입니다.
함수 객체를 넘겼을 뿐 함수를 호출한 상황은 아니죠.
그리고 hello3 함수가 호출이 되면 age 인자가 호출 가능한지 검사하고 호출 가능하다면 호출하여 그 반환 값으로 값을 변경하는 방법입니다.
이 방법도 getDefaultAge 함수가 총 4번 호출이 됩니다.
이 방법은 장고 내에서 디폴트 값을 지정하는 거의 모든 곳에서 활용됩니다.
값이 아닌 인자가 없는 함수를 디폴트 값으로 지정하면 디폴트 값이 필요한 시점에 호출하여 그 반환 값을 디폴트 값으로 활용합니다.
파이썬 함수에서는 위치 인자와 키워드 인자가 있습니다.
위치 인자는 함수를 호출할 때 각 인자를 순서, 즉 인덱스로 구별하기 때문에 지정하는 인자의 순서가 바뀌면 전달받는 인자가 달라집니다.
포인트 펄슨 함수 호출 시에 Tom, Ship, Seoul 순서로 인자를 지정하면 순서대로 Name 인자, Age 인자, Legend 인자의 값이 담깁니다.
그런데 10, 함, 서울 순서로 인자를 지정하면 10은 name 인자의 값이 담기게 되죠.
위치 인자는 순서, 즉 인덱스로 각 인자를 구별하기 때문입니다.
그런데 위치 인자는 순서가 아닌 인자의 이름으로 각 인자를 구별합니다.
함수 호출 시에 인자의 이름을 같이 지정합니다.
그러면 순서가 바뀌어도 전달받는 인자는 동일합니다.
자바스크립트에서는 위치 인자만 지원하고 키워드 인자를 지원하지 않습니다.
객체 비구조화 문법으로 키워드 인자를 흉내 내고요.
printperson2, printperson3 함수는 실제 인자 한 개를 받는 상황입니다.
fs.readDirectory 함수는 비동기적으로 디렉토리 내에 파일 목록을 줘야 합니다.
이는 함수 호출이 코드의 실행 흐름을 차단하지 않고 즉시 다음 코드로 넘어가게 합니다.
파일 목록 조회가 완료되면 지정된 콜백 함수가 호출되어 결과를 처리합니다.
여기에서는 조회된 파일 목록이 파일즈 매개 변수로 전달이 되네요.
자바스크립트는 웹페이지의 비동기적인 이벤트를 효율적으로 처리하기 위해서 설계되었습니다.
사용자 입력, 네트워크 요청, 파일 IOP, 파일 입출력 등이 해당되며 이러한 비동기적 작업의 완료를 처리하기 위해 콜백 함수가 필수적이었습니다
<<<<<<< HEAD
그런데 여러 비동기 작업을 순차적으로 처리하는 과정에서 콜백 함수를 중첩하게 되고요
=======
그런데 여러 비동기 작업을 순차적으로 처리하는 과정에서 콜백 함수를 중첩하게 되고요 
>>>>>>> c753b33e5a2263a502dd7d3e57bc41ae23fae5ce
이러한 중첩은 코드의 들여쓰기 수준을 깊게 만들어 코드의 가독성과 유지 보수성을 크게 저하시킵니다
이러한 문제를 해결하기 위해 프라미스가 도입되었습니다. 프라미스는 비동기 작업을 추상화하여 최종 성공 또는 실패를 나타내는 객체입니다.
DEM 메서드를 통해 해결, Resolve 콜백을 연결하고 Catch 메서드를 통해 거부, Reject 콜백을 연결합니다.
중첩된 콜백 대신에 체인 형태로 비동기 작업을 구성할 수도 있기에 콜백 방식에 비해 코드의 가독성과 관리성이 향상되었습니다.
async await는 프라미스 객체를 더욱 간결하고 동기 코드와 유사한 방식으로 작성할 수 있도록 도와줍니다.
async 함수는 항상 프라미스 객체를 관한하고요.
함수 내부에서 await 키워드를 사용하여 프라미스의 해결, 리졸브 콜백을 기다릴 수 있습니다. 
이 방식은 프라미스 체인보다 더 직관적이고 선형적인 코드 구조를 가능하게 하여 비동기 코드의 가독성을 대폭 향상시켜 주었습니다.
리액트 개발에서는 콜백 방식의 코드는 거의 사용하지 않으실 테고요.
가끔 프라이미스 방식을 쓰시고 주로 async await 코드를 작성하시게 될 겁니다.
파이썬에서도 파이썬 3.7부터 도입된 async I/O을 통해 async 함수를 지원합니다.
자바스크립트의 async 함수와 문법적으로 많이 닮았습니다.