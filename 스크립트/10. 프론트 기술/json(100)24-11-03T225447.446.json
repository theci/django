안녕하세요. 이번 시간에는 모델 폼 컴포넌트를 만들어 보겠습니다.
앞서 태그 입력 폼을 모델로 구현했었죠.
태그 입력 폼을 구성하는 코드와 모델 UI를 구성하는 코드가 뒤섞여 있었는데요.
모델 UI를 모델 폼 컴포넌트로 구현하여 모델 폼 코드의 가독성과 재사용성을 높여
보겠습니다.
django-components 라이브러리 통해 개발된 컴포넌트는 이렇게 컴포넌트 템플릿 태그를 통해
컴포넌트 이름 지정만으로 사용하실 수 있고 의존성 있는 CSS와 JavaScript 태그는
최상위 부모 템플릿에서만 1회 포함시켜 주시면 됩니다.
그럼 등록된 컴포넌트에 모든 CSS와 JavaScript 태그가 추가되고요.
Bootstrap 라이브러리는 테마를 적용하는 등 변경될 수 있으니 컴포넌트의 의존성으로
직접 추가하진 않겠고요.
최상위 부모 템플릿에서 추가하는 방식으로 진행합니다.
모델 폼 컴포넌트에서는 모델의 타이틀과 바디 영역을 커스텀 지정할 수 있어야 할 텐데요.
장고 템플릿에서는 템플릿 상속에서 부모 템플릿에서 block 템플릿 태그로 block을
정의하면 자식 템플릿에서는 부모가 정의한 block을 block 템플릿 태그로 재정의할 수
있잖아요. 그처럼 장고 컴포넌트 라이브러리에서는 컴포넌트 구현 시에 슬롯 템플릿 태그로
슬롯을 정의하면 컴포넌트를 사용할 때에는 태그로 슬롯 영역의 내용을 채울 수 있습니다.
이렇게 컴포넌트를 사용할 때, 타이틀과 바디 내용을 지정할 수 있는 거죠.
모델폼 컴포넌트를 하나 구현합니다.
모델폼 이름의 폴더를 하나 생성하고, 여기에 모델폼.py.html.js 파일을 생성합니다.
파이썬 파일에서는 django-components 라이브러리의 컴포넌트 클래스를 상속받은 modal
form 클래스를 정의하고 템플릿 경로와 의존성 있는 자바스크립트 파일의 경로를
지정합니다.
observe node-insertion.js 파일은 곧 살펴볼게요.
블로그의 _태그 form.html 코드에 modal form 코드만 복사해서 템플릿
코드에 옮겨주고요.
modal의 title과 body 영역은 제거하고 템플릿 태그로 슬롯을 생성해줍니다.
그러면 이 컴포넌트를 사용하는 측에서 템플릿 태그를 통해 이 슬롯의 내용을 채울 수
있습니다. 특정 슬롯의 채워짐 여부는 템플릿 태그를 통해 확인할 수 있습니다.
자바스크립트 코드를 통해 modal 창을 띄워 줘야 하는데요 우리가 부모 템플릿에서
Django 컨퍼런스에 의존성 있는 자바스크립트를 웹페이지 끝에서 딱 1회만 수행되도록
구성할 것이거든요
htmx 응답에서는 css, 자바스크립트 없이 html 응답만 할 것입니다
그런데 hello world 컨퍼런스처럼 도큐먼트의 코디 셀렉터 올 함수를 통해 관련
요소를 탐색하는 방식은 페이지를 처음 로딩할 때에만 단 1회만 동작합니다
그러니 htmx처럼 페이지 로딩 이후에 로딩되는 htmx 응답에서의 modal form
component 요소에 대해서는 이 코드가 반응하지 않습니다
페이지 로딩 시에만 1회 수행되는 자바스크립트에서 페이지 로딩 이후에 로딩되는 DOM
요소에 반응하려면 어떻게 해야 할까요?
ObserveNodeInsertion이라는 함수를 하나 구현했습니다
이 함수의 첫 번째 인자로 찍혀볼 DOM 요소의 CSS 셀렉터를 지정하고요 해당 요소에
추가가 감지되었을 때 호출될 함수를 두 번째 인자로 지정했습니다
ObserveNodeInsertion 함수는 MutationObserver API를 통해
구현했고요.
MutationObserver API는 웹페이지의 DOM 변경을 감지할 수 있습니다.
ObserveNodeInsertion.js 파일은 별도 파일로 저장하고, 모델 폼
컴포넌트의 의존성으로 추가해 둡니다.
이제 Observe Node Insertion 함수를 통해 HTMX를 통해 로딩되는 모델
폼 컴포넌트 요소에 대해서도 반응할 수 있게 됩니다.
새로운 모델 폼 컴포넌트 요소가 탐지되면 모델 창으로 띄우고요.
모델 창 요소 내에 Submit 버튼이 있으면 클릭 시에 폼 요소를 찾아서 Submit
이벤트를 전달합니다.
서브밋 이벤트 발생은 htmx 라이벌리를 활용한다면 htmx의 트리거 함수를 활용할 수
있구요 혹은 커스텀 이벤트를 통해서도 동일하게 이벤트를 발생시킬 수 있습니다
블로그의 태그스 주소에서 구현했던 모달폼 구현을 컴포넌트로 재구현해 보겠습니다
src/django 컴포넌트 디렉토리 아래에 modal-form 디렉토리를 생성하고
modal-form.html 파일도 생성하고요 같은 이름의 파이썬 파일과 자바스크립트
파일도 빔 파일로 생성합니다
파이썬 파일에서는 컴포넌트 클래스를 상속받은 modal_form 컴포넌트 클래스를
정의하고요 레지스터, 장식자를 통해 컴포넌트를 등록하고 컴포넌트의 이름도 부여해줍니다
이 이름으로 이 컴포넌트가 지정되어 사용되어질 것입니다
이 컴포넌트에서 사용할 html 템플릿 경로와 자바스크립트 경로도 지정해 줍니다.
블로그의 템플릿에서 모달 폼 HTML과 자바스크립트 파일을 잘라내고요.
모델 폼 컴포넌트를 사용하도록 합니다.
컴포넌트 템플릿 태그 사용을 위해서는 태그를 로드하고요.
이제 언더바 태그 폼점 HTML 템플릿 코드가 엄청 간결해졌죠?
컴포넌트의 HTML 템플릿에 방금 잘라낸 코드를 붙여넣고요.
모달 폼 컴포넌트 클래스 이름을 관련 CSS와 자바스크립트 파일에서 참조할 수 있도록
식별자로서 추가합니다.
자바스크립트 코드는 잘라내어 별도 자바스크립트 파일로 옮기고요.
static, directory 아래의 파일들은 장고 템플릿 파일이 아니라 파일 그
자체가 웹브라우저로 전송되는 단순 파일들입니다.
그러니 주석에서 장고 템플릿 주석 문법은 사용할 수 없고요.
현재 자바스크립트 파일이니 자바스크립트 주석 문법으로 변경합니다.
종전에는 자바스크립트 코드 내에서 장고 템플릿 주석 문법으로 주석을 쓴 이유는
장고 템플릿 주석 문법으로 주석을 쓰면 템플릿 코드 내에서는 개발자가 주석을 확인할
수 있지만 유저에게 내려진 응답에서는 이 장고 템플릿 주석이 빠져서 전송되거든요
개발자만 볼 수 있는 주석인 거죠
그래서 저는 장고 템플릿 내에서는 HTML 코드이든, 자바스크립트 코드이든, CSS
코드이든 주석을 Django 템플릿 주석 문법으로 씁니다
컴포넌트의 HTML 템플릿에서는 타이틀과 바디 영역은 일단 텍스트로 써 주시고요
자바스크립트 코드를 먼저 연동하여 모델 폼을 띄운 후에 Slot 템플릿 태그를 사용하여
타이틀과 바디 영역을 변경할 수 있도록 지원하겠습니다
헬로월드 컴포넌트의 자바스크립트 코드대로 QuerySelectorAll 함수를 통해
클래스명으로 컴포넌트 요소를 탐색하도록 해보겠습니다
블로그에 base.html 최상위 부모 템플릿에서 등록된 컴포넌트의 CSS와
자바스크립트 로딩을 위해 component-tags를 로드하고
component-css-dependencies 템플릿 태그를 통해 등록된 모든 컴포넌트의
CSS를 로드하고 component-js-dependencies 템플릿 태그를 통해 등록된
모든 컴포넌트의 자바스크립트를 로드합니다
웹페이지 새로고침하시면 새 태그 버튼을 클릭하지 않았음에도 브라우저 콘솔창에 모델 폼
컴포넌트의 자바스크립트 수행내역이 출력됩니다.
모델 폼 컴포넌트 이름의 요소를 찾지 못했다고 빈 리스트가 출력되고 있습니다.
새 태그 버튼을 클릭해 보시면 화면에 변화가 없고 콘솔창에 추가 메시지도 없습니다.
Django 컴포넌트 라이브러리를 사용하는 컴포넌트에서는 컴포넌트의 자바스크립트는 웹페이지 초기
로딩 시에 딱 1회만, 딱 한 번만 수행됩니다.
페이지 초기 로딩 이후에 서버로부터 htmx 응답을 받아오지만, htmx 응답으로 추가된
요소에 대해서는 이 자바스크립트 코드가 수행되지 않습니다.
src의 django 컴포넌트 디렉토리에
observe-node-insertion.javascript 파일을 생성하고요 모델 폼
컴포넌트의 자바스크립트 의존에도 추가해 줍니다
그럼 최상위 부모 템플릿에 component-js-dependencies 템플릿 태그를 통해
자동 지정되어 로딩 되겠죠
모델폰 컴포넌트의 자바스크립트 코드에서 observe-node-insertion 함수를
사용하도록 변경합니다 두번째 인자로 지정한 콜백함수는 모델 폼 컴포넌트 클래스명을 가지는
요소가 새롭게 탐지되면 자동 호출될 것입니다
웹페이지 새로고침하면 콘솔창에 출력되는 내용이 없죠
아직 모델폼 컴포넌트 클래스명을 가지는 요소가 웹페이지 내에 없는 것이고요
새 태그 버튼을 클릭하시면 그 즉시 모델 폼 컴포넌트 클래스명을 가지는 요소가 탐지되어
콘솔창에 출력됨을 확인하실 수 있습니다
이제 부트스트랩 모델 API를 활용해서 모델로 띄워주기만 하면 됩니다
콜백 함수의 인자로 전달받은 모델 폼 요소에 대해서 모델 폼을 띄우도록 코드를 변경합니다
페이지 새로고침하시고 새 태그 버튼 클릭하시면 이렇게 모델 창이 잘 뜨고요 모델 폼
컴포넌트를 통해 수행된 결과입니다
모델을 껐다가 여러 번 다시 띄워봐도 잘 동작합니다.
모델폼에서 저장 버튼을 클릭하면 콘솔 창에 에러가 뜨죠?
null 대상에 대해서 DispatchEvent 메서드를 참조할 수 없다는 에러입니다.
현재 모델 폼에는 아직 폼 요소가 없거든요.
그러니 이 폼 EL 값은 null입니다.
코드를 방어적으로 개선해 보겠습니다.
컴포넌트 사용에 따라서 Submit 버튼 요소가 없을 수도 있고요.
폼 요소가 없을 수도 있습니다.
이를 방어적으로 확인하는 코드를 추가해 봅니다.
Submit 버튼 요소가 있으면 클릭 이벤트 핸들러를 추가하고요.
Form 요소가 있을 때에만 Form 요소에 Submit 이벤트를 전달합니다.
HTMX 라이브러리가 로딩된 상태에서는 htmx 라이벌리를 통해 Submit 이벤트를
전달하고요.
HTMX 라이브러리가 없더라도 기본 API로 커스텀 이벤트를 통해 동일하게 Submit
이벤트를 전달할 수 있습니다
그리고 Submit 버튼 요소가 없으면 경고 메시지를 띄워 주겠습니다
이제 폼 요소가 없는 상황에서도 저장 버튼 클릭 시에 에러 메시지 없이 모델 폼이 잘
동작합니다. 이제 모델 폼에서 타이틀과 바디 영역을 커스텀 할 수 있도록 지원해
보겠습니다.
Slot 템플릿 태그로 Slot을 정의합니다.
Django 템플릿 태그 중에 Block과 사용법이 비슷합니다.
컴포넌트를 사용하는 측에서는 필 템플릿 태그로 지정 이름의 슬롯의 내용을 채울 수
있습니다. 모델 타이틀 슬롯과 모델 바디 슬롯을 태그 폼 구성에 맞춰 채워줍니다.
새 태그 폼도 띄워보시고 수정 폼도 띄워보세요.
상황에 맞게 모델 폼이 잘 뜨고요.
그리고 폼 저장도 잘 됩니다.
마지막으로 모델 폼 컴포넌트에서 리프레쉬 태그 리스트 이벤트에 대한 리스너가 등록되어
있는데요. 리프레쉬 태그 리스트 이벤트는 태그 폼과 관련된 이벤트죠.
모델 폼 컴포넌트에서 리프레쉬 태그 리스트에 대한 이벤트를 처리하는 것은 적절하지
않습니다. 모델 폼 컴포넌트 요소에는 커스텀 이벤트로 하이드 이벤트를 처리할 수 있도록
이벤트 리스너를 등록하고요.
하이드 이벤트를 받으면 모델을 숨기도록 합니다.
그리고 태그 폼 템플릿에서 refresh 태그 리스트 이벤트를 받으면 태그에 대한
modal form 요소에 대해서 hide 이벤트를 발생하도록 합니다.
동작을 확인해 보시면 잘 동작합니다.
modal form 컴포넌트의 자바스크립트에서 좀 더 방어적으로 이미 Bootstrap
modal이 적용된 요소라면 중복해서 modal을 적용하지 않도록 하겠습니다.
Bootstrap.Modal.getInstance API를 통해서 지정 요소에 적용된
modal 인스턴스를 획득할 수 있고요.
이를 통해 modal 적용 여부를 확인할 수 있습니다.
모달이 아직 적용이 안 된 요소인 경우에만 모달을 적용합니다.
모달 폼 컴포넌트에 원하시는 속성 값을 다양하게 지정할 수 있는데요.
id 속성 값을 예로 하나 추가해 보겠습니다.
컴포넌트 템플릿 태그 출시에 id 속성 값을 추가하면 이것만으로는 컴포넌트에 반영되지
않죠. 컴포넌트 파이썬 값은 클래스에서 getContextData 메서드를 재정의하고 속성
값을 인자로 받아서 컨텍스트 데이터로 반영될 수 있도록 사전 객체로 반환해 주셔야 합니다
그럼 컴포넌트의 HTML 템플릿에서 이제 id 속성 값을 참조할 수 있고요
id 값이 있을 때에만 태그에 id 속성 값이 반영되도록 합니다
웹페이지 새로고침하시고 모달 폼을 띄워 속성을 확인해 보시면 이렇게 id 속성 값을
확인하실 수 있습니다


1. 모델 폼 컴포넌트 구현 계획
모델 폼을 Django 컴포넌트로 구현하여 코드의 가독성과 재사용성을 높임.
타이틀과 바디 영역을 커스텀할 수 있도록 슬롯(Slot)을 사용.
컴포넌트의 자바스크립트와 CSS 의존성을 최상위 부모 템플릿에서 한 번만 포함시키도록 설정.
2. 컴포넌트 파일 구조
modal-form 폴더 생성 후, 다음 파일들 생성:
modal-form.py: Django 컴포넌트 클래스 정의.
modal-form.html: 모델 폼의 HTML 템플릿.
modal-form.js: 모델 폼과 관련된 자바스크립트 코드.
3. 파이썬 클래스 정의
modal-form.py에서 Django 컴포넌트 클래스를 정의하고, 템플릿 경로와 자바스크립트 경로 지정.
슬롯을 사용하여 타이틀과 바디 영역을 유동적으로 지정할 수 있도록 구현.
4. HTML 템플릿 구현
modal-form.html에서는 modal의 타이틀과 바디 부분을 슬롯으로 정의.
modal-form.js는 페이지 로딩 시 한 번만 실행되며, MutationObserver를 사용하여 htmx 응답으로 로딩된 모델 폼에 반응하도록 구현.
5. JavaScript 코드 (ObserveNodeInsertion)
MutationObserver API를 사용하여 페이지 로딩 이후 동적으로 추가된 DOM 요소를 탐지.
모델 폼이 새로 추가될 때마다 모델을 띄우고, Submit 버튼 클릭 시 이벤트 전송.
6. Bootstrap Modal API 활용
Bootstrap.Modal.getInstance로 모달이 이미 적용된 요소에 대해서 중복 적용을 방지.
모델 폼이 띄워지고, 폼 제출 시 htmx나 커스텀 이벤트로 Submit이 전송됨.
7. 부모 템플릿 설정
최상위 부모 템플릿에서 component-css-dependencies와 component-js-dependencies를 통해 CSS와 자바스크립트 파일을 로드.
observe-node-insertion.js를 별도로 로딩하여 htmx 응답으로 로딩되는 요소에 반응하도록 설정.
8. 보안 및 예외 처리
null 값에 대해 방어적인 코드를 추가하여 폼 요소나 Submit 버튼이 없을 때에도 오류 없이 동작하도록 개선.
Submit 버튼과 폼 요소가 없을 때 경고 메시지를 띄우고, Submit 이벤트를 방어적으로 처리.
9. 커스텀 속성 추가
컴포넌트에 id 속성을 추가하여, HTML 템플릿에서 id 값을 사용하도록 구현.
getContextData 메서드를 재정의하여 속성 값을 컨텍스트 데이터로 반영.
10. 동작 확인 및 테스트
웹 페이지 새로 고침 후, 새 태그 폼을 클릭하여 모델 폼이 잘 동작하는지 확인.
폼 제출 시 에러 없이 저장이 잘 되며, 모달 폼의 타이틀과 바디를 커스텀하여 설정할 수 있음.
이렇게 모델 폼 컴포넌트는 슬롯을 사용하여 유연한 타이틀과 바디 영역을 설정하고, 자바스크립트를 통해 동적으로 DOM을 처리하며, 폼 제출을 안전하게 처리할 수 있습니다.