새로 고친 버튼을 클릭하면 지정 주소의 서버에서 HTML 컨텐츠를 가져와서 지정 요소에 업데이트하는 예시입니다.
외부 라이브러리 없이 기본 HTML, JavaScript, CSS로 한 땀 한 땀 구현했고요. 
새로 고친 버튼에 클릭 이벤트에 대한 이벤트 리스너드 추가해서 버튼이 클릭되면 해당 함수가 호출됩니다.
그 함수에서는 패치 API로 블로그의 태그스 주소로 요청을 보내고요.
응답에 전체 HTML을 태그 리스트 컨테이너 요소에 그대로 적용하고 Show Class까지 추가하면 컨텐츠가 보여지며 투명도 애니메이션도 적용됩니다.
간단해 보이는 기능이지만 다른 사람이 이 코드를 봤을 때 바로 이 동작을 예상하기는 어렵습니다. 
각기 떨어져 있는 HTML, CSS, JavaScript 코드들을 연결해서 읽어야 하기 때문이죠.
블로그의 테스트 페이지에서 예시를 구현해 보겠습니다.
블로그의 test.html 템플릿을 사용하는 테스트 뷰를 구현하고, URF 패턴에도 등록해줍니다.
test.html 템플릿에는 HTML, CSS 코드만 먼저 복사해 주고요.
JavaScript 코드는 조금씩 살펴보겠습니다.
CSS 파일에서는 id가 태그 리스트 컨테이너인 요소에 Transition 전환 효과를 주려 하는데요.
투명도에 대해서 300ms 시간 동안 전환되고 초기 값은 0으로 지정했습니다.
투명도 0은 완전 투명한 상태로서 화면에 보이지 않는 상태입니다.
isInOut은 Transition 타이밍 함수입니다.
투명도 수치가 트랜지션 시작할 때와 끝날 때는 천천히 변경되고, 중간에는 빠르게 변경됩니다.
쇼클래스가 적용되면 투명도가 1로 지정될 텐데요.
앞서 지정한 트랜지션이 동작되어 300ms의 시간 동안, 시작할 때와 끝날 때는 투명도가 천천히 전환되고, 중간에는 빠르게 전환될 것입니다.
템플릿 파일을 저장하고 블로그의 테스트 페이지에 방문하면 이렇게 새로고침 버튼만 덜렁 있습니다.
자바스크립트 개발을 할 테니 콘솔 창을 미리 열어두어 자바스크립트 오류가 발생하면 빠르게 인지할 수 있도록 준비합니다.
자바스크립트에서 코디 셀렉터 API를 통해 지정 코디 셀렉터의 DOM 요소를 조회합니다.
페이지 새로고침하시고 콘솔 창을 통해 버튼 EL 값과 컨테이너 EL 값을 확인하실 수 있습니다. 
버튼에 대한 클릭 이벤트 리스너를 등록합니다.
해당 요소에 addEventListener를 호출하여 인자로 클릭 문자를 넘겨 클릭 이벤트에 대한 리스너 함수를 등록하실 수도 있고요.
해당 요소에 onClick 속성으로 함수를 지정하여 클릭 이벤트에 대한 리스너 함수를 등록하실 수도 있습니다.
두 방법 모두 가능합니다.
클릭 이벤트에 대한 리스너 함수는 async 함수도 가능합니다.
참고로 나중에 리액트에서는 함수 등록 시에 async 함수가 지원되지 않는 상황도 있습니다. 
자, 여기에 async 함수를 사용한 이유는 패치 API 사용 시에 await를 사용하기 위함이고요.
자바스크립트에서 await는 async 함수 내에서만 사용할 수 있습니다.
패치 API로 블로그의 태그스 주소에 HTTP 요청을 보내고 응답 객체에서 응답 바디의 HTML 문자열을 HTML 텍스트 상수에 저장하고 콘솔에 출력합니다.
그럼 이렇게 HTML 태그, 헤드 태그, 부트스트랩 5의 CSS, 자바스크립트 코드까지 모두 응답으로 받아왔음을 확인하실 수 있습니다.
컨테이너 요소의 innerHTML 속성으로 적용해 보시면 새로고침을 클릭하는 시점에 새로고침 버튼의 스타일이 변경됩니다.
브라우저 개발자 도구 요소 탭에서 태그 리스트 컨테이너 요소를 확인해 보시면 내부에 Bootstrap 5 CSS에 대한 링크 태그가 있죠.
기본 테스트 페이지에는 아무런 CSS가 없는데 새로고침을 클릭하는 시점에 Bootstrap 5 스타일이 로딩되어 웹페이지에 적용이 된 상황입니다.
응답에서 head 요소는 무시하고 body 요소만 적용해 보겠습니다.
바디 요소만 적용하는 이유는 htmx 라이브러리에서는 바디 요소만 지정 요소에 반영하도록 동작하기 때문이고요.
이는 페이지 스타일은 이미 적용된 상황일 테고 동적으로 페이지 스타일이나 라이브러리를 로딩하는 경우는 드뭅니다.
그래서 htmx를 통한 업데이트에서는 불필요하게 CSS, JavaScript, 라이브러리 로딩 없이 컨텐츠만 효율적으로 적용하도록 바디 요소만 지정 요소에 반영하도록 동작합니다.
돈팟을 통해 HTML 문자열을 가공해서 바디 요소만 추출하고요.
추출된 바디 요소의 이너 HTML을 컨테이너 요소에 반영합니다.
웹페이지 새로고침하시고 새로고침 버튼을 클릭해보면 새로고침이 동작하지 않네요.
브라우저 콘솔 탭을 보니 레퍼런스 에러가 발생했습니다.
이렇게 자바스크립트가 예상대로 동작하지 않으면 콘솔 탭을 가장 먼저 확인해 보세요.
오류 내역이 바로 확인이 됩니다.
HTML 변수명을 잘못 지정했네요.
HTML 텍스트 변수명으로 수정합니다.
페이지 새로고침하시고 새로고침 버튼 클릭해 보시면 새로고침 버튼 스타일이 이제 안 바뀌죠?
어? 그런데 태그 목록이 아직 안 보여지네요?
브라우저 개발자 도구 요소 탭에 보시면 태그 리스트 컨테이너 내에 태그 목록이 담긴 메인 요소가 있습니다.
그리고 네트워크 탭에서 블로그의 태그스 요청에 대한 응답을 받는 것도 확인이 되고요.
응답 문서에 바디 요소도 출력해 보시면 콘솔 탭에 출력도 잘 됩니다.
왜 안 보여질까요?
그 이유는 CSS에서 기본 투명도가 0이었고, 투명도를 변경해 주는 코드가 없었네요.
컨테이너 요소에 컨텐츠를 반영하고 Show 클래스를 추가해 줍니다.
Show 클래스에서는 투명도를 1로 변경하는 CSS가 적용되어 있습니다.
페이지 새로고침하시고, 이제 새로고침 버튼 클릭하시면 새로고침 버튼 스타일도 안 바뀌고요.
300ms의 트랜지션 효과와 함께 태그 목록이 보여짐을 확인하실 수 있습니다.
이처럼 간단한 페이지 로딩조차 다양한 오류에 직면하고 디버깅 과정이 복잡합니다.
HTMX를 통해 직관적이고 간결한 코드로 동일한 기능을 구현해 보겠습니다.





HTML과 JavaScript를 이용한 "새로 고침 버튼" 구현
1. 기본 구현 개요
목표: 새로 고침 버튼을 클릭하면, 지정된 주소에서 HTML 콘텐츠를 가져와서 특정 요소에 반영하는 기능을 구현.
사용 기술: HTML, CSS, JavaScript (패치 API), 기본적인 트랜지션 효과.
2. 구현 과정
1. HTML 템플릿 구성:
HTML에 태그 리스트 컨테이너와 새로 고침 버튼을 배치.
CSS:
#tag-list-container에 투명도 전환 효과를 설정 (300ms 동안 투명도 0에서 1로 전환).
isInOut 타이밍 함수로 애니메이션을 제어.
show 클래스는 opacity: 1로 설정해 콘텐츠를 표시.
2. CSS 설정:
css
코드 복사
#tag-list-container {
    transition: opacity 300ms ease-in-out;
    opacity: 0;
}

#tag-list-container.show {
    opacity: 1;
}
**opacity: 0**으로 초기 설정하여 해당 요소가 숨겨져 있다가, show 클래스가 추가되면 **opacity: 1**로 변경되어 나타납니다.
**transition**을 사용하여 300ms 동안 투명도가 변화하도록 설정.
3. JavaScript 코드 작성:
새로 고침 버튼에 클릭 이벤트 리스너를 추가하고, **fetch API**를 사용하여 서버에서 HTML 데이터를 가져옵니다.
서버에서 받은 HTML 콘텐츠를 **#tag-list-container**에 반영하고, show 클래스를 추가하여 애니메이션 효과를 적용합니다.
4. JavaScript 코드 예시:
javascript
코드 복사
document.getElementById('refresh-btn').addEventListener('click', async function() {
    try {
        // 서버에서 HTML 콘텐츠 요청
        const response = await fetch('/tags');
        const htmlText = await response.text();

        // DOM으로 응답 HTML을 처리 (body 부분만)
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = htmlText;
        const newContent = tempDiv.querySelector('body').innerHTML;

        // 태그 리스트 컨테이너에 새로운 HTML 콘텐츠 반영
        const container = document.getElementById('tag-list-container');
        container.innerHTML = newContent;

        // show 클래스 추가 (애니메이션)
        container.classList.add('show');
    } catch (error) {
        console.error('Error fetching HTML:', error);
    }
});
5. 디버깅:
콘솔 확인: 만약 코드가 예상대로 동작하지 않으면, 브라우저의 콘솔에서 오류를 확인해야 합니다. 예를 들어, HTML 텍스트 변수명을 잘못 지정한 경우 오류가 발생할 수 있습니다.
show 클래스 추가 확인: 트랜지션 효과가 정상적으로 적용되지 않는 경우 show 클래스를 추가해야 하며, CSS가 제대로 적용되지 않은 경우 이를 확인해야 합니다.
3. 문제 해결 과정
응답 HTML에 head 태그 포함: fetch로 받은 HTML에는 head 태그도 포함됩니다. 이때 head 부분은 필요 없으므로 body 부분만 추출하여 적용합니다.
CSS 적용 문제: 기본적으로 #tag-list-container의 투명도가 0으로 설정되어 있어, 콘텐츠가 로드되었음에도 보이지 않던 문제를 해결하기 위해 show 클래스를 추가하여 투명도를 1로 변경합니다.
4. HTMX로 동일한 기능 구현
HTMX를 사용하면 직관적이고 간결한 코드로 동일한 기능을 구현할 수 있습니다.
HTMX는 별도의 JavaScript 코드 없이 HTML 속성만으로 서버와 비동기 통신을 처리하고, 특정 요소만 업데이트할 수 있도록 도와줍니다.
예를 들어, hx-get과 hx-target 속성을 사용하여 버튼 클릭 시 서버에서 콘텐츠를 받아와 #tag-list-container에 업데이트하는 방식으로 구현할 수 있습니다.
결론
기본적인 JavaScript로 HTML을 가져와서 페이지에 업데이트하는 것은 간단하지만, 여러 단계의 디버깅과 함께 다양한 오류에 직면할 수 있습니다.
HTMX를 활용하면 이러한 기능을 더 간결하고 직관적인 방식으로 구현할 수 있어 유지보수와 확장성이 용이해집니다.