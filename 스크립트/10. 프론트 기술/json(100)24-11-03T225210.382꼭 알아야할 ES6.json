안녕하세요. 이번 시간에는 꼭 알아야 할 자바스크립트 문법을 빠르게 살펴보겠습니다.

ECMAScript는 자바스크립트 언어의 표준 사양을 뜻합니다.
ECMAScript는 2015년 이전까지 정체기였다가 2015년부터 다시 활발히 발전했는데요.
2015년에 많은 개선이 있었고요.
이후로도 매년 조금씩 개선이 이루어지고 있습니다.
2015년에 나온 ECMAScript 2015를 줄여서 ES6라고 부릅니다.

ES6 이상의 필수 문법을 살펴보겠습니다.
ES6 이전에는 var 키워드만 사용하여 변수를 선언했었는데요.
ES6부터는 let과 const를 통한 변수 상수 선언을 지원합니다.
var 키워드로 변수를 선언하면 함수 단위의 스코프를 가지고요.
즉 함수 내에서 바로 선언된 변수 선언이 아래에 있어도 그 위에 코드에서 아래 변수를 참조할 수 있습니다.
이를 호이스팅이라고 부릅니다.
let과 const로 선언된 변수 상수는 블록 단위의 스코프를 가지기에 변수 선언 시점부터 참조할 수 있으며 블록을 벗어나면 참조할 수 없습니다.
그리고 const로 선언된 변수는 한번 할당한 후에는 재할당을 할 수 없고요.
재할당을 하려고 하면 이렇게 타입 에러가 발생합니다.
재할당을 막아놓은 곳일 뿐 속성 변경은 가능하고요.
배열에 대해서도 추가 수정 삭제가 가능합니다.
객체의 변경을 막으려면 객체를 밀봉하시면 되고요.
그러면 각 항목에 대한 변경을 시도하더라도 오류 없이 변경을 무시합니다.
확장을 시도하면 타입 에러가 발생합니다.
기존 배열을 변경하지 않고도 스프레드 연산자를 활용하여 새로운 항목이 추가된 새로운 배열을 만들 수 있는데요.
이를 통해 원본 객체의 불변성을 지킬 수 있고요.
리액트에서 상태 값을 다룰 때 자주 사용하시게 될 연산자입니다.
웹페이지에서 이와 같이 자바스크립트를 통해 반복문을 5회 돌며 새로운 div 요소를 생성해서 body 요소에 추가합니다.
i 변수는 바로 선언되었기에 함수 스코프를 가지고요.
for 반복문 내에서 선언했더라도 호이스팅되어 함수 최상단에 선언된 것처럼 처리됩니다.
그럼 i 변수는 딱 한 번 선언되고요.
반복문을 돌며 변수 값만 변경되는 거죠.
반복문을 돌며 innerHtml 속성에 값을 할당할 때에는 i 변수 값은 매 반복 시마다 각각 0, 1, 2, 3, 4로 할당이 됩니다.
그런데 클릭 이벤트 핸들러인 onClick 함수는 해당 요소를 클릭하는 시점에 실행이 되거든요. 
즉, 다섯 번의 반복문이 끝나고 나서 실행이 됩니다.
다섯 번의 반복문이 끝나고 나면 i 변수 값은 5가 되어 있잖아요.
그러니 샵 0, 샵 1, 샵 2, 샵 3, 샵 4 중 어떤 요소를 클릭하더라도 i 값은 5를 참조하게 되어 clicked.sharp5가 출력이 됩니다.
var을 let으로 변경하시면 i 값은 블록 스코프를 가지고요.
반복문을 순회할 때마다 새로운 i 변수가 생성이 됩니다.
온클릭 함수는 외부 함수의 변수 i에 접근할 수 있으며 각각의 온클릭 함수는 각기 다른 i 값을 기억합니다.
내부 함수가 외부 함수의 스코프에 접근하는 메커니즘을 클로저라고 부릅니다.
외부 함수의 실행이 끝난 후에도 외부 함수의 변수를 참조할 수 있습니다.
파이썬에서는 장식자 구현 시에 클로저가 사용됩니다.
파이썬의 사전 타입과 자바스크립트의 객체 타입은 선언 방법이 유사합니다.
자바스크립트 속성 키는 문자열로 지정해야 하는데요.
키가 변수명으로 사용할 수 있는 이름이면 따옴표를 생략할 수 있습니다.
이는 자바스크립트의 문법적 단순화를 위한 것이고요.
자바스크립트 객체를 JSON 문자열로 변환하면 코드는 비슷해 보이는데요.
JSON으로 변환될 경우에는 모든 키는 쌍 따옴표로 감싸집니다.
속성키로써 사용할 문자열을 이렇게 조합하고 키로 지정하면 이는 위 변수 값이 아니라 이름 그 자체로 키 이름이 되어 키는 new name이 됩니다.
변수명이나 계산된 값을 키로 지정하려면 대관로로 감싸주어야 하고요.
이를 계산된 속성면 문법이라고 부릅니다.
파이썬에서는 변수 지정만으로도 해당 변수 값이 키로 사용됩니다.
자바스크립트에서는 클래스 없이도 단일 객체를 생성하여 관련 속성과 함수를 하나의 객체로 묶을 수 있는데요.
자바스크립트에서 함수를 정의할 때 function 키워드를 사용할 수도 있고, 화살함수, arrow function으로 정의할 수도 있습니다.
단일 객체 내에서 메서드를 정의할 때에는 this 키워드가 현재 객체에 바인딩 되도록 하기 위해 function 키워드를 사용하여 함수를 정의하는 것이 중요합니다.
화살 함수를 사용할 경우 this는 외부 스코프의 this 값을 상속받게 되므로 메서드가 속한 객체 대신 다른 컨텍스트를 가리키게 됩니다.
따라서 객체의 메서드에서 객체 자신의 속성이나 다른 메서드에 접근하려면 function 키워드로 함수를 정의하여 this가 메서드를 호출하는 현재 객체에 올바르게 바인딩 되도록
해야만 합니다.
<<<<<<< HEAD
속성의 키 이름과 각 변수의 이름이 같을 때에는 이렇게 줄여서 단축 속성명을 적용하실 수도 있습니다. 
=======
속성의 키 이름과 각 변수의 이름이 같을 때에는 이렇게 줄여서 단축 속성명을 적용하실 수도 있습니다.
>>>>>>> c753b33e5a2263a502dd7d3e57bc41ae23fae5ce
함수 키워드로 정의된 함수도 이렇게 단축 속성명으로 적용하실 수 있고요.
위 코드와 동작은 동일합니다.
깊은 복사는 객체의 모든 레벨을 재기적으로 복사하므로 큰 객체나 복잡한 객체 구조에서는 비용이 많이 듭니다.
즉, 메모리 소모가 많아지고 느리게 동작해요.
얕은 복사는 최상위 레벨의 속성만 복사하기 때문에 더 빠르고 효율적입니다.
이렇게 객체 할당에서는 얕은 복사가 이루어지고요.
Object1과 Object2는 이름만 다를 뿐 같은 객체를 가리키기에 Object2를 변경하면 Object1도 변경됩니다.
파이썬에서도 동일하게 객체 할당에서는 얕은 복사가 이루어지고요.
Object2를 변경하면 Object1도 변경됩니다.
자바스크립트 기본에서는 깊은 복사를 위한 API가 지원되지는 않고요 깊은 복사를 지원해주는 외부 라이브러리를 쓰셔야 합니다
깊은 복사를 수행하는 방법 중 하나는 객체를 JSON 문자열로 변환한 후에 이 문자열을 다시 객체로 변환하는 과정을 거쳐 깊은 복사를 수행하는 것입니다
<<<<<<< HEAD
이 방법은 JSON 직렬화를 지원하지 않는 객체에 대해서는 수행할 수 없고요 깊은 복사를 지원하는 웹 라이브러리에 비해 성능이 떨어지지만 작은 객체에서는 자바스크립트 기본
API만으로 깊은 복사를 수행할 수 있기에 유용합니다.
=======
이 방법은 JSON 직렬화를 지원하지 않는 객체에 대해서는 수행할 수 없고요 깊은 복사를 지원하는 웹 라이브러리에 비해 성능이 떨어지지만 
작은 객체에서는 자바스크립트 기본 API만으로 깊은 복사를 수행할 수 있기에 유용합니다.
>>>>>>> c753b33e5a2263a502dd7d3e57bc41ae23fae5ce
이렇게 깊은 복사를 하면 Object1의 값을 변경하더라도 깊은 복사된 Object2의 객체는 변경되지 않습니다.
파이썬에서는 깊은 복사를 위한 딥 카피 함수를 지원해 줍니다.
자바스크립트에서는 백틱을 사용하는 템플릿 리터럴 문법을 통해 여러 줄의 문자열을 정의할 수도 있고요.
문자열 내에 표현식을 삽입하는 문자열 보관을 지원합니다.
백틱 키는 키보드에서 숫자 1 좌측에 있는 키입니다.
파이썬에서는 호 따옴표 3개나 쌍따옴표 3개로 열어줄 문자열을 정의할 수 있고요.
f-string 문법으로 문자열 보관을 지원합니다.
각 자바스크립트 코드와 파이썬 코드는 같은 문자열을 정의하고 있습니다.
배열 B 구조와 문법을 통해 배열의 요소들을 인덱스에 맞춰 변수로 추출할 수 있습니다.
파이썬에서도 동일한 문법을 지원하는데요.
파이썬에서는 좌항과 우항의 개수가 일치하지 않으면 value error가 발생합니다.
자바스크립트에서는 오류가 발생하지 않고요.
좌항에서 인덱스에 매칭되는 변수가 선언되어 있지 않으면 무시하고요.
좌항에 선언된 변수에만 값이 할당됩니다.
파이썬에서는 사용하지 않을 값이 있더라도 항상 변수로 값을 받아주지 않으면 문법 오류 에러가 발생합니다.
우항에서 인덱스에 매칭되는 값이 선언되어 있지 않으면 저항에서 그 인덱스의 변수에는 값 할당이 없어서 Undefined가 됩니다.
이때 default 값을 지정해 주시면 값 할당이 없을 때 default 값으로 할당이 되고요. 
우항에서 값 할당이 있더라도 그 값이 undefined라면 default 값으로 할당됩니다.
default 값으로 지정한 표현식은 변수 선언이 되는 시점에 평가되는 것이 아니라 default 값이 필요한 시점에 평가됩니다.
뒤에서 다루는 함수 인자의 default 값에서도 동일하게 함수 default 값이 필요한 시점에 평가가 이루어집니다.
default 값으로 함수를 호출해서 반환 값을 지정했다면 이 함수는 default 값이 필요할 때에만 그 함수가 호출되어 반환 값이 default 값으로 지정됩니다.
객체 비구조화 문법을 통해 객체의 속성들을 속성 키에 맞춰 변수로 추출할 수 있습니다.
파이썬처럼 개별 속성에 접근해서 변수에 할당할 수도 있지만 이렇게 객체 비구조화 문법으로 지정 이름의 값만 변수에 저장할 수 있습니다.
이렇게 Name, 키 값을 뽑아서 OtherName 이름의 변수에 할당할 수도 있고요.
좌항에 지정한 이름의 키가 우항이 없으면 그 변수는 Undefined가 됩니다.
함수 인자로 객체를 넘길 때 객체를 통으로 받을 수도 있지만 객체에서 특정 속성만 필요하다면 인자의 객체 비구조화 문법을 적용하여 인자로 사용할 필요한 인자만 받을 수 있습니다.
파이썬에서는 함수 인자에서 키워드 인자를 지원하죠.
자바스크립트에서는 키워드 인자 문법이 없고요.
객체 비구조화 문법으로 유사하게 활용합니다.
객체 비구조화는 가팔라진 땅이 이루어지는 모든 영역에서 활용할 수 있는데요.
이처럼 for 반복문에서도 객체 비구조화 문법을 활용하실 수 있습니다.
전개문법은 배열이나 객체의 비구조화 문법에서 좌항에서 다수의 값을 하나의 변수로 모아서 할당받거나, 우항에서 하나의 변수에 담긴 다수의 값을 전개하여, 즉 펼쳐서 다수의 값으로
구성할 수 있습니다.
좌항에서 첫 번째 값은 네임 변수에 저장하고, 나머지 값들은 모두 배열로 하나의 레스트 변수에 저장이 됩니다.
우항에서 전개 연산자를 적용하면 해당 배열 항목들이 펼쳐져 전개가 되고요.
두 번 전개를 했으니 Student 배열는 Names 항목이 두 번 들어 있음을 확인하실 수 있습니다.
Python에서도 star를 사용하는 packing, unpacking 문법으로 동일한 동작을 합니다.
함수에서 다수의 위치 인자를 받을 때에도 전개 문법을 사용할 수 있는데요.
자바스크립트와 파이썬이 동일하게 동작합니다.
파이썬에서는 다수의 키워드 인자를 받을 때에는 star를 2개 써서 사전으로 받는 패킹 문법이 지원되는데요.
자바스크립트 함수에서는 키워드 인자를 받는 문법이 없죠.
리액트에서는 각 객체의 불변성을 지키며 새로운 객체를 만들게 되는데요.
이때 전개문법을 활용하면 손쉽게 원본 데이터의 복사본을 만들 수 있습니다.
이는 깊은 복사는 아니고요.
객체나 배열의 가장 바깥층, 첫 번째 레벨의 요소를 새로운 객체나 배열에 복사합니다.
객체나 배열이 중첩된 요소들은 참조 복사가 되어 원본과 복사본이 같은 중첩된 객체나 배열을 참조하게 돼요.
객체에서 원본 객체는 변경하지 않으면서 특정 속성만 변경한 새로운 객체를 만들 때 이렇게 전개문법을 활용할 수 있습니다.
속성명이 중복될 경우 마지막에 지정한 속성이 남는 특성을 활용한 것입니다.
파이썬에서는 딕 함수를 통해 새로운 사전을 생성하며 변경할 키와 밸류를 지정하여 구현합니다.