여러 소셜미디어에 자주 사용되는 목록 페이지에서의 무한 스크롤을 HTMX를 통해 구현해 보겠습니다. 
페이징 지원을 위해 태그 를 를 변경합니다.
새로 고친 버튼에는 현재 페이지 번호에 맞게 HTMX 요청이 이루어지도록 hxget 속성의 주소에 페이지 인자를 추가해 주겠습니다.
페이지 인자를 추가하지 않으면 웹페이지는 3페이지를 보고 있을 때 새로고침에서는 페이지 지정이 없으니 항상 1페이지를 요청하게 되겠죠.
페이지 번호 렌더링은 Django Bootstrap 5 라이브러리에 bootstep__pagination 템플릿 태그를 활용하겠습니다.
실습해 볼게요.
리스트 뷰 클래스를 상속받은 태그 리스트 뷰 클래스를 정의하고 이를 통해 태그 리스트 함수를 생성합니다.
태그 리스트 함수에서 구현한 내용을 태그 리스트 뷰 클래스에도 적용해 주겠습니다.
모델과 쿼리셋 설정을 적용하고요.
검색어 처리를 위해 매 요청마다 쿼리셋을 다르게 지정해야 하니 getCodicet 메서드를 재정의해서 적용합니다.
그리고 매 요청마다 템플릿을 다르게 지정해줘야 하니 getTemplateNames 메서드를 재정의하고요.
getTemplateNames 메서드는 사용할 템플릿 경로명 list를 반환해야만 합니다.
list가 아닌 문자열을 반환해도 동작하도록 Django 내부에서 구현되어 있긴 합니다.
태그 리스트 함수 기반 뷰 구현은 제거하고요.
페이지 새로고침하시면 종전대로 잘 동작합니다.
페이징 지원을 위해 페이지네이트바이 설정을 추가합니다.
저는 태그가 현재 8개뿐이니까 5를 지정해서 2페이지 이상 나오도록 하겠습니다.
5를 지정하니까 이렇게 5개만 출력되죠?
블로그에 태그리스트.html 템플릿에 페이지링크도 추가해줍니다.
부트스트랩 원더바 페이지네이션 템플릿 태그를 활용하고요.
페이지 오브젝트 인자를 안 넘겼었네요.
추가해주고요.
새로고침하시면 페이지 링크도 잘 출력됩니다.
이 페이지에서 새로고침 버튼 클릭해보면 1페이지 내용으로 새로고침이 되고 있습니다.
새로고침 버튼에 hxget 속성에 지정된 주소에 현재 페이지 번호를 추가합니다.
그럼 이렇게 현재 페이지 번호에 맞게 새로고침 시에도 페이지 번호가 지정되어 페이지에 맞게 새로고침이 됨을 확인하실 수 있습니다.
현재 태그 개수가 몇 개 없잖아요
79개의 태그를 미리 만들어 놨습니다
이 태그 목록을 로딩해서 데이터베이스에 없는 태그만 생성해주는 로드 블로그 태그스 관리 명령을 수행하여 태그 개수를 조금 늘려 보겠습니다
블로그 앱에 로드 블로그 태그스 명령을 추가해 줍니다
슬라이드에 안내해 드린 소스 코드를 복사해서 그대로 적용하겠습니다
링크의 텍스트 파일은 한 줄에 하나씩 생성할 태그명이 지정되어 있습니다
파이썬 manage.py 로드 블로그 태그쓰 명령을 실행하면 현재 데이터베이스에 없는 태그들만 생성해줍니다. 
저는 78개가 생성되었네요.
페이지 새로고침하시면 새롭게 등록된 태그들이 보여지고요.
지금은 태그가 많으니 한 페이지에 10개씩 보여지도록 태그 리스트 뷰 설정도 변경해줍니다.
무한 스크롤을 구현할 때 다음 페이지 로딩을 트리거하는 방법이 두 가지가 있습니다
그 중 첫 번째가 다음 페이지를 로딩하는 버튼을 목록 끝에 두어 그 버튼을 클릭하면 다음 페이지를 이어 로딩하는 방식이고요 클릭 투 로드 패턴이라고 부릅니다
두 번째가 스크롤이 목록 끝에 도달하면 자동으로 다음 페이지를 로딩하는 방식입니다.
무한 스크롤 패턴이라고 부릅니다.
첫 번째, 클릭 투 로드 패턴입니다.
underbar-taglist.html 템플릿에서 각 태그들을 렌더링할 때, 방법문에서 마지막 태그이고, 다음 페이지가 있을 때 다음 버튼을 추가해 줍니다.
다음 버튼을 클릭하면 HTMX를 통해 다음 페이지를 요청하고 다음 페이지 내용으로 이 다음 버튼 요소를 대체하겠습니다.
여러 페이지가 하나의 리스트 그룹으로 보여지기 위해 underscore 태그 리스트 점 HTML 템플릿에서는 태그 리스트 그룹을 제거하고요.
부모 템플릿에 리스트 그룹을 추가합니다.
실습해 볼게요.
블로그의 태그 리스트 점 HTML 템플릿에서 페이지 링크를 제거하고요.
블로그의 언더바 태그 리스트 점 HTML 템플릿에서 태그 목록 렌더링에서 마지막 태그이고 현재 페이징에서 다음 페이지가 있을 경우 다음 버튼을 추가해 줍니다.
이 다음 버튼을 클릭하면 다음 페이지를 서버로 요청하고요.
여러 번 클릭 되더라도 한 번만 요청을 수행하고요.
서버 응답을 받으면 다음 버튼 요소를 제거하고 다음 버튼 위치에 응답을 적용합니다.
페이지 새로고침 하시고요.
다음 버튼을 클릭하시면 다음 페이지 내용이 추가됩니다.
그런데 다음 페이지의 최상단의 모서리에 굴곡이 있죠?
블라우저 개발자 도구로 살펴보시면 기존 1페이지의 리스트 그룹 안에 2페이지의 리스트 그룹이 추가로 생성되어서 그렇습니다.
여러 페이지가 하나의 리스트 그룹으로 보여지는 것이 UI 상으로 깔끔할 것입니다.
블로그에 underscore 태그 리스트 점 html 템플릿에서 리스트 그룹을 제거합니다.
그러면 태그 목록에 대한 htmx 응답에서도 리스트 그룹 없이 태그 목록 응답이 있을 것입니다. 
리스트 그룹은 블로그에 태그 리스트 점 html에 적용합니다.
그리고 새로 고친 버튼 클릭 시에도 리스트 그룹에 응답이 적용되도록 hx target 속성도 수정해 줍니다.
페이지 새로고침하시고 다음 버튼 클릭해보시면 이제 하나의 리스트 그룹 안에 여러 페이지의 태그 목록들이 잘 렌더링됨을 확인하실 수 있습니다.
마지막 페이지까지 가시면 다음 버튼이 더 이상 없죠?
마지막 페이지에서 페이지 끝입니다 라고 보여주실 수도 있습니다.
블로그에 언더바 태그 리스트 점 HTML 템플릿에서 두 개의 if 조건을 나눠 지정합니다.
다음 페이지가 없을 때에 대한 조건도 추가합니다.
페이지 새로고침하시고 다시 확인해 보시면 페이지 끝에 도달하면 이렇게 페이지 끝입니다 라고 표시됩니다 

이번에는 무한 스크롤을 구현해 보겠습니다 
클릭을 통한 로드 패턴에서 버튼에 HX 트리거만 클릭해서 리빌드로 변경해 주시면 됩니다
그 버튼이 화면에 보여질 때 자동으로 HTMX 요청이 전달되어 다음 페이지가 로딩됩니다
실습해 볼게요
버튼은 더 이상 클릭을 받지 않을 테니 active 속성을 제거하여 파란색 스타일을 제거합니다.
HX 트리거 속성에서 클릭을 리빌드로 변경합니다.
페이지 새로고침해 보시면 2페이지는 로딩이 되는데 3페이지는 로딩이 안 되네요.
HX 트리거의 온수 설정 때문입니다.
온수 설정을 제거하고요.
페이지 새로고침하시고 스크롤해 보시면 이제 다음 텍스트가 화면에 보이실 때마다 다음 페이지 로딩을 시도합니다.
텍스트는 다음이 아니라 로딩 중입니다으로 보여주는 것이 좀 더 적절하겠네요.







무한 스크롤 구현: HTMX와 Django로 페이징 처리
1. 페이징을 위한 기본 설정
HTMX 페이징 설정:

페이지 번호를 URL에 포함시켜서, 페이지 새로고침 시에도 올바른 페이지가 로드되도록 설정.
hx-get 속성에 현재 페이지 번호를 포함하여 요청을 보낼 수 있도록 설정합니다.
Django Pagination:

Django의 Paginator와 Bootstrap 5의 pagination 템플릿 태그를 사용하여 페이지 네비게이션을 설정합니다.
페이지 번호를 URL로 포함시키고, hx-get 속성으로 페이지 번호를 넘겨서 페이징을 구현합니다.
페이지 링크 추가:

bootstep__pagination 템플릿 태그를 사용하여 페이지 링크를 추가하고, 페이지 번호를 정확히 표시합니다.
2. 태그 리스트 페이지 설정
태그 모델과 쿼리셋 설정:

ListView를 상속받아 태그 목록을 페이지별로 나누어 렌더링합니다.
페이지네이션을 위해 Paginator를 설정하고, 페이지마다 렌더링할 템플릿을 동적으로 변경합니다.
태그 목록 뷰:

페이지 번호에 맞게 태그를 출력하고, get_context_data 메서드를 오버라이드하여 페이지네이션을 처리합니다.
bootstep__pagination을 사용하여 페이지 네비게이션을 출력합니다.
3. 새로 고침 및 페이지 번호 맞추기
새로 고침 시 페이지 번호 보존:
페이지 새로 고침을 할 때마다 현재 페이지 번호를 hx-get 속성에 추가하여, 새로 고침 시에도 이전에 보던 페이지가 유지되도록 합니다.
4. 데이터 생성 및 태그 로딩
태그 추가 명령어:

python manage.py load_blog_tags 명령어를 사용하여 미리 설정된 태그 목록을 데이터베이스에 추가합니다.
이 명령어는 데이터베이스에 존재하지 않는 태그만 새로 생성합니다.
페이징 크기 조정:

태그 개수를 늘려서 여러 페이지가 생성되도록 하고, 페이지당 표시할 태그 수를 10개로 설정하여 태그 목록을 10개씩 표시합니다.
5. 클릭을 통한 로드 패턴 (Click-to-Load)
HTMX를 이용한 다음 페이지 로드:

underbar-taglist.html 템플릿에서 마지막 태그일 경우 "다음" 버튼을 표시하고, 버튼 클릭 시 HTMX를 사용하여 서버에서 다음 페이지를 로드합니다.
HTMX 응답이 오면, 기존 "다음" 버튼을 제거하고 새로운 페이지 데이터를 삽입합니다.
리스트 그룹 구조 변경:

여러 페이지를 하나의 리스트 그룹으로 묶어서 UI를 깔끔하게 만듭니다.
각 페이지 응답에서 리스트 그룹을 제거하고, underbar-taglist.html에서 리스트 그룹을 부모 템플릿으로 이동시킵니다.
페이지 끝 표시:

마지막 페이지에 도달하면 "페이지 끝입니다"라는 메시지를 표시하도록 추가 조건을 설정합니다.
6. 무한 스크롤 구현 (Infinite Scroll)
HTMX로 무한 스크롤:

버튼을 클릭하는 대신, 스크롤이 페이지 끝에 도달할 때 자동으로 다음 페이지를 로딩하는 무한 스크롤 패턴을 구현합니다.
hx-trigger 속성을 click에서 reveal로 변경하여, 버튼이 화면에 보일 때마다 자동으로 페이지 요청을 보냅니다.
"로딩 중" 메시지 표시:

페이지가 로딩되는 동안 버튼의 텍스트를 "다음" 대신 "로딩 중..."으로 표시하여 사용자에게 로딩 상태를 명확히 알립니다.
7. 최종 구현 흐름
태그 목록 페이지:

기본적으로 페이지는 10개씩 태그를 출력하며, 페이지네이션 기능을 제공합니다.
bootstep__pagination을 사용하여 페이지 링크를 표시하고, hx-get으로 페이지 번호를 관리합니다.
클릭을 통한 로드:

페이지 목록 끝에 "다음" 버튼을 추가하여, 클릭 시 HTMX를 통해 다음 페이지를 요청하고, 그 위치에 데이터를 삽입합니다.
여러 페이지가 하나의 리스트 그룹 안에 표시되도록 설정하여 UI가 깔끔하게 유지됩니다.
마지막 페이지에서 "페이지 끝입니다"라는 메시지가 나타납니다.
무한 스크롤:

버튼 클릭 대신, 스크롤이 화면에 보일 때 자동으로 HTMX 요청이 트리거되어 다음 페이지를 로딩합니다.
버튼 스타일은 비활성화하고, hx-trigger="revealed"로 설정하여 버튼이 화면에 보일 때마다 페이지를 로드합니다.
"로딩 중..."이라는 메시지를 표시하여 로딩 상태를 명확히 알립니다.
결론
HTMX를 이용한 페이징 처리 및 무한 스크롤을 통해, 사용자 경험을 개선할 수 있었습니다.
페이지 새로 고침 없이 스무스한 로딩이 가능하고, 클릭을 통한 로드 및 자동 로드 방식으로 두 가지 방법을 구현했습니다.
태그 목록을 페이지별로 나누어 효율적으로 관리하고, UI/UX 개선을 위해 스크롤을 통한 자동 로딩을 적용했습니다.