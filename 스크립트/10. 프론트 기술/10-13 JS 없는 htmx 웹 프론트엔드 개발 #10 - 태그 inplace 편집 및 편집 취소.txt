이번에는 태그 수정 기능을 태그 목록에서 페이지 전환 없이 제공하는 태그 인플레이스 편집
기능을 구현해 보겠습니다
태그 리스트 스타일을 변경할 텐데요
기존에는 태그를 클릭하면 삭제 기능으로 동작을 했었죠
여기에 수정 기능을 지금 추가할 거잖아요
태그명 우측에 삭제 버튼을 추가하여 삭제 버튼을 클릭하면 삭제로 동작하도록 하고요 태그를
클릭하면 수정으로 동작하도록 하겠습니다
삭제 버튼에서는 hx 타겟 속성을 변경합니다.
htmx 삭제 요청에 대한 응답을 받으면 삭제 버튼만 지우는 것이 아니라 그 삭제 버튼을
감싸고 있는 태그 항목을 지워야 하죠.
Closest List Group Item을 지정하여 삭제 버튼의 조상 중에 가장 가까운
리스트 그룹 아이템 요소를 제거하도록 합니다.
그러면 삭제 후에 해당 태그가 제거됩니다.
실습해 볼게요. 각 리스트 그룹 아이템 요소에 삭제 버튼을 추가하기 위해 flexbox로
변경하고요.
flexbox 내 각 아이템들을 수평으로 정렬하되 시작 부분과 끝 부분에 위치시키고 나머지
공간을 균등하게 분배합니다.
두 개의 아이템이 있다면 각 아이템을 양 끝으로 밀어내고 가운데 공간을 확보합니다.
그리고 수직 방향에서 중앙에 위치시킵니다.
나머지 htmx 설정들은 제거하고요.
태그명에 바로 이어서 삭제 버튼으로써 스판 태그를 추가합니다.
방금 제거한 htmx 설정을 그대로 적용할게요.
텍스트만 붉은색으로 보여지기 위해 text-danger 클래스를 적용합니다.
페이지 새로고침하시면 이렇게 빨간색 삭제 버튼이 각 태그마다 보여지죠.
삭제 버튼 클릭하시고 삭제해 보시면 htmx 응답 후에 삭제 버튼만 화면에서 제거됩니다.
삭제 버튼에 hx target 속성이 없죠.
hx target 속성은 디폴트로 `dis`입니다.
그래서 hx swap delete 속성과 함께 삭제 버튼만 제거된 상황입니다.
태그를 삭제하면 태그의 리스트 그룹 아이템이 삭제되어야 하죠.
그러니 삭제 버튼에 hx-target 속성을 추가하고 삭제 버튼의 조상 중에 리스트 그룹 아이템
클래스를 가진 가장 가까운 조상이 삭제되도록 Closest List Group Item을
지정합니다. 그럼 삭제를 수행하면 각 태그 리스트 그룹 아이템들이 삭제됩니다.
태그를 클릭하면 태그 수정 폼을 태그 위치에 보여주겠습니다.
먼저 태그 수정 뷰인 태그 에디트 뷰를 추가하고요.
태그 수정과 태그 생성은 모델 폼 인스턴스 생성 시에 인스턴스 인자만 다를 뿐 다른 구현은
모두 동일합니다.
태그 에디트 뷰에서는 태그 뉴 뷰를 호출하여 태그 수정을 구현해 주겠습니다.
태그 뉴 뷰에서는 PK 인자가 있으면 관련 태그를 조회해서 인스턴스 변수를 생성하고 모델
폼 인스턴스 생성 시에 생성자로 전달합니다
_태그 폼 HTML 템플릿에서는 HX 포스트 속성에서 태그 생성일 때와 태그 수정일
때의 주소가 다르거든요
이는 리퀘스트 요청 객체에서 갭 풀 패스 메서드를 참조토록 하여 현재 요청 주소를 전달하여
해결합니다 태그 수정, htmx에서는 hxget 속성으로 태그 수정 주소를 지정하고요.
클릭되면 동작하겠고요.
태그 요소를 태그 폼 요소로 덮어 쓰겠습니다.
실습해 볼게요.
블로그 앱의 태그 에디트 뷰를 정의하고 태그 뉴 뷰를 호출하여 구현합니다.
태그 에디트 뷰에 대한 url 패턴도 등록해 주고요.
태그 new view 함수에는 pk 인자를 추가합니다.
생성 요청에서는 pk 인자 지정이 없을 테니 값이 non일 것이고요.
수정 요청에서는 pk 값이 있겠죠.
pk 값이 있으면 데이터베이스 조회를 하고 인스턴스 변수에 담습니다.
모델 폼에서는 인스턴스 키워드 인자가 non이면 생성으로 처리하고, 인스턴스 인자가 있으면
수정으로 처리합니다.
블로그에 underbar-tag list.html 템플릿에서 각 태그명에 수정 링크를
추가합니다.
클릭하면 각 태그 수정 주소로 GET 요청을 보내어 수정 폼 HTML을 받아와서 각 태그에
리스트 그룹 아이템 요소를 덮어쓰도록 합니다.
그럼 각 태그를 클릭하면 이렇게 수정 폼으로 대체가 됩니다.
그런데, 브라우저 개발자 도구로 해당 form 요소를 찍어보면, hx post 속성 값이
태그 생성 주소를 가리키고 있죠.
각 태그 수정 주소가 지정되어야 하는데 말이죠.
블로그의 underbar-tag-form.html 템플릿에서 hx post 속성을
request 객체에 개플 패스 메서드를 호출하여 각 생성, 수정 요청의 현재 주소를
지정토록 합니다.
그러면 수정에서도 생성에서도 각 상황에 맞게 hxpost 속성에 주소가 잘 지정됩니다.
그리고 form 태그에 style도 추가해 줍니다.
페이지 새로 고치지 마시고 수정을 해보면 수정이 잘 반영됩니다.
그런데 현재 상황에서 UI에서 뭔가 어색한 점을 눈치 못 채셨나요?
태그 뉴뷰 함수에서 저장한 후에 htmx 요청에서는 리프레쉬 태그 리스트 이벤트를
발생시키잖아요
그래서 인플레이스 편집 후에 강제로 목록 새로고침이 수행되고 있습니다
인플레이스 편집의 장점은 각 태그들을 개별적으로 동시에 수정할 수 있음에 있는데요
지금처럼 목록이 새로고침되면 다른 인플레이스 편집이 없어지는 상황이 생깁니다
이 부분은 곧 뒤에서 해결해 볼게요
인플레이스 편집 중에 취소 기능을 구현해 보겠습니다.
HTMX에서는 웹 프론트엔드 단에서 어떠한 상태도 가지고 있지 않습니다.
매 상황에서 서버로 요청해서 그 응답을 지정 요소에 덮어 쓸 뿐입니다.
간단한 메커니즘인데요.
그래서 자바스크립트 코드는 거의 쓰지 않고 서버 주도로 다양한 UI를 구현할 수 있게
됩니다. 취소 버튼을 눌렀을 때 해당 태그 내역에 HTML 응답하는 뷰가 추가로
필요합니다. 그 뷰 응답으로 인플레이스 폼을 덮어 쓰면 폼이 제거되고 태그 내역이 보여지니
취소 처리가 되는 거죠.
지정 태그에 대한 내역을 응답하는 태그 리스트 아이템 뷰를 추가로 구현합니다.
언더바 태그 리스트 점 HTML 템플릿에서 각 태그 내역의 HTML을 잘라내서 언더바 태그
리스트 아이템 점 HTML 파일로 저장하고요.
태그 리스트 아이템 뷰에서 템플릿 응답으로 사용합니다.
태그 뉴 뷰에서 수정 동작 시에는 지정 태그 내역을 응답하는 주소를 계산합니다.
이 주소는 수정 취소 시에도 활용하고 수정 저장 후에도 활용합니다.
블로그의 언더바 태그 폼.html 템플릿에서는 수정 요청 시에는 cancel URL 값이
있을 것이고요.
해당 주소로 취소 요청을 보냅니다.
그럼 태그 내역으로 응답을 받아와서 폼을 덮어 쓰겠죠.
생성 요청 시에는 cancel URL 값이 없을 것이고요.
default 값으로 생성 요청을 받는 주소를 지정하면 취소 시에 빈 생성 폼.html을
다시 받아와서 폼을 덮어 쓰게 됩니다.
실습해 볼게요.
블로그의 underbar-taglist.html 템플릿에서 태그 내역 템플릿 코드를
잘라내어 그 자리에 블로그의 underbar-taglist-item.html 템플릿을
include하고요. 해당 템플릿으로 템플릿 코드를 옮기겠습니다.
태그 목록 확인해 보시면 여전히 잘 동작하고요.
태그 리스트 아이템 뷰를 구현해 주고 블로그의
underbar-taglist-item.html 템플릿을 통해 응답을 합니다.
유아될 패턴으로 등록해 줍니다.
블로그 underbar-tag 폼.html 템플릿에 저장 버튼과 취소 버튼을 추가합니다.
폼 요소 내에 버튼 요소는 클릭하면 폼 제출로서 동작합니다.
그러니 저장 버튼은 style만 지정해 주시면 되고요.
취소 버튼을 클릭하면 폼 요소를 덮어 쓸 html을 서버에서 받아와서 덮어 쓰도록
HTMX 설정을 해줍니다.
취소 URL은 cancel URL 값으로 지정받을 텐데요.
생성 요청에서는 이 값이 없을 거예요.
이 값이 없을 때에는 현 생성 요청의 주소가 default로 지정되도록 합니다.
그럼 취소하면 빈 폼에 HTML을 받아와서 덮어쓰게 됩니다.
웹페이지 새로고침하시고 생성 폼의 취소 버튼을 보시면 hxget 속성이 생성 주소로 잘
지정되어 있습니다.
값 입력하다가 취소 버튼 클릭해 보시면 이렇게 빈 폼으로 취소가 잘 됩니다.
이제 수정 요청에서 취소 URL 계산이 필요한데요.
태그 뉴뷰에서 수정 요청일 때 태그 리스트 아이템 URL 주소를 계산합니다.
템플릿에도 Cancel URL 값으로 넘겨줍니다.
그럼 이렇게 수정 폼에서 취소 버튼을 클릭하면 원래 태그 내역으로 잘 전환이 됨을 확인하실
수 있습니다.
태그를 수정하시고 저장하시면 빈 폼으로 응답을 받고 목록 새로고침이 발생하는 이슈가 여전히
있습니다. 폼 저장 후에 수정 HTML 요청일 경우에는 빈 폼 응답을 하지 않고 태그
리스트 아이템 URL 주소로에 이동 응답을 합니다.
그러면 수정 저장 후에 빈 폼이 아닌 태그 내역으로 전환이 될 것이고요.
Refresh 태그 리스트 이벤트 응답도 없으니 불필요한 목록 새로고침도 없을 것입니다.
이제 수정하시고 저장하시면 목록 새로고침 없이 변경된 태그 내역으로 잘 보여집니다.
그런데 태그를 저장했습니다라는 성공 메시지가 보여지지 않고 있죠.
메시지 소비를 위해 블로그에 언더스코어 태그리스트 아이템.html 템플릿에도
bootstrap__messages 템플릿 태그를 추가하여 메시지 소비를 하도록 합니다.
페이지 새로고침하시면 이전에 소비되지 않은 메시지가 보여지고요.
다시 수정해 보시면 이렇게 성공 메시지가 잘 보여짐을 확인하실 수 있습니다.


1. 태그 리스트 UI 변경 (삭제 버튼 추가)
기존 기능: 태그를 클릭하면 삭제 기능이 동작함.
수정:
각 태그 우측에 삭제 버튼을 추가.
삭제 버튼 클릭 시 태그 삭제, 태그 클릭 시 수정 폼을 표시하도록 설정.
삭제 버튼에는 hx-target 속성 추가하여, 삭제 후 해당 태그를 삭제하도록 설정.
2. 삭제 기능 구현
삭제 요청 후 응답 처리:
삭제 버튼 클릭 시 hx-target 속성을 사용하여, 삭제 버튼이 포함된 태그 항목을 삭제.
Closest List Group Item을 사용하여 삭제 버튼의 가장 가까운 상위 리스트 그룹 항목을 제거.
결과: 삭제 후 태그 리스트 항목이 정상적으로 제거됨.
3. 태그 수정 기능 추가
태그 수정 뷰 추가:
태그 수정과 태그 생성은 동일한 폼을 사용하되, 인스턴스 변수만 다르게 전달하여 처리.
hx-get을 사용하여 태그 클릭 시 수정 폼을 가져오고, 해당 태그로 덮어씌운다.
태그 수정 시에는 hx-post 속성에서 현재 요청 URL을 지정하여 수정이 올바르게 처리되도록 함.
4. 태그 수정 폼 응답
수정 후 폼 처리:
태그 수정 폼을 제출하면 서버에서 처리된 후 수정된 결과를 반환하고, 목록을 새로고침하지 않도록 설정.
hx-post로 수정 요청을 보내고, 성공적으로 수정이 완료되면 새로고침 없이 태그 내역을 갱신.
5. 취소 기능 구현
취소 요청 처리:
수정 중 취소 버튼을 추가하고, 취소 시에는 폼을 덮어쓸 HTML을 서버에서 받아옴.
cancel URL을 사용하여 취소 시 폼을 원래 상태로 되돌리도록 설정.
생성 폼에는 cancel URL이 없으므로, 기본 생성 요청 URL이 사용됨.
6. 리스트 아이템 응답 뷰 구현
underbar-tag-list-item.html:
태그 항목을 응답으로 받기 위한 뷰 템플릿을 분리하여 구현.
태그 목록을 렌더링할 때 각 태그 항목을 해당 뷰 템플릿을 통해 출력하도록 함.
7. 메시지 처리 (성공 메시지 표시)
성공 메시지 표시:
수정 후, 성공 메시지가 정상적으로 표시되지 않던 문제를 해결.
bootstrap__messages 템플릿 태그를 사용하여 성공 메시지를 표시하도록 수정.
태그 수정 후 메시지가 잘 소비되고 표시됨을 확인.
8. 결과
태그 수정 시: 수정 폼이 올바르게 덮어쓰여지고, 수정이 완료되면 새로고침 없이 변경된 태그 내역이 바로 표시됩니다.
태그 삭제 시: 삭제 버튼을 클릭하면 해당 태그 항목이 삭제됩니다.
취소 시: 폼에서 취소 버튼을 클릭하면 폼이 원래 상태로 돌아갑니다.
성공 메시지: 수정 후 성공 메시지가 잘 표시됩니다.
이 구현은 HTMX를 활용하여, 페이지 전환 없이 사용자 인터페이스를 동적으로 처리하는 방법을 설명합니다.