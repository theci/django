안녕하세요
이번에는 유저 팔로잉, 언팔로잉 버튼을 구현해 보겠습니다
팔로잉 버튼 클릭 시에 페이지 새로고침 없이 팔로잉 버튼만 변경되도록 htmx를 활용해서
구현해 보겠고요 자바 스크립트 코드는 일절 없습니다
먼저 유저 간의 팔로잉 관계를 저장할 수 있도록 User 모델에 대한 Many-to-Many
관계를 저장하기 위해 Many-to-Many 필드 타입으로 Following User
Set 필드를 추가하겠습니다.
Many-to-Many 필드 타입에서는 관계의 대칭성을 지정하는 symmetrical
인자가 있습니다.
Default로 None이고요.
지금처럼 모델 자신에 대해 관계를 맺을 때에는 symmetrical 인자가 Default로
참으로 지정되어 자동으로 대칭 관계로 설정됩니다.
유저 A가 유저 B를 팔로잉하면 거꾸로 유저 B가 유저 A를 팔로잉하는 것은 아니잖아요.
그러니까 팔로잉 관계에서는 symmetrical 인자는 거짓으로 지정하는 것이 맞습니다.
하지만 친구 관계에서는 유저 A가 유저 B와 친구를 맺으면 거꾸로 유저 B 입장에서도 유저
A는 친구니까 친구 관계는 대칭 관계이고요.
이때는 symmetrical 인자를 참으로 지정하시는 것이 맞겠죠.
유저 A가 유저 B를 팔로잉하면 거꾸로 유저 A는 유저 B의 팔로워가 됩니다.
그러니 유저 B 입장에서 손쉽게 팔로워를 조회할 수 있도록 related_name 설정을
FollowerUserSet으로 지정합니다.
유저 초기 생성 시에는 팔로잉이 없죠.
그러니 Blank 참을 지정하여 팔로잉 관계 없음을 허용하도록 합니다.
인자의 유저가 팔로워인지 확인하는 is_follower 메서드를 구현하고요 셀프 유저를
인자의 유저가 팔로워하는 follow 메서드를 구현하고 unfollow하는 unfollow
메서드도 구현합니다
그리고 셀프 유저의 팔로워 수를 반환하는 팔로워 카운트 메서드도 구현합니다
마이그레이션 파일을 생성하시고 데이터베이스에 반영도 해줍니다
유저 팔로우 뷰 함수와 유저 언팔로우 뷰 함수를 구현하겠습니다
유저 팔로우 뷰는 GET 요청과 POST 요청을 받겠고요 GET 요청에서는 현재 팔로잉
상황에 맞춰 팔로잉, 언팔로잉 버튼을 응답하겠고요 버튼을 클릭하면 팔로잉 상황에 맞춰
팔로잉 요청이나 언팔로잉 요청을 HTMX를 통해 POST 방식으로 전송하도록 하겠습니다
팔로잉 버튼은 underbar-user-follow.html 템플릿을 통해 구현하겠습니다
user-page.html 템플릿의 팔로잉 버튼 HTML은 잘라내어
underbar-user-follow.html 템플릿으로 옮기겠고요.
user-page.html 템플릿에서는 HTML을 통해 팔로잉 버튼을 조회하겠습니다.
이 방식은 템플릿에서는 항상 유저명만 지정하면 되기에 나중에 팔로잉 버튼을 컴포넌트로
만들기도 좋습니다.
페이지 새로고침 하시면 HTMX 요청을 통해서 팔로잉 버튼 2개를 받아와서 화면에 잘
보여주고 있습니다.
이제 팔로잉 상황에 따라 서로 다른 버튼을 보여주도록 하겠고요.
클릭하면 HTMX를 통해 포스트 요청을 보내어 팔로잉 처리를 해주겠습니다.
팔로잉 요청이 들어오면 팔로잉을 하는 유저와 팔로잉 당하는 유저가 있습니다
두 유저 간의 관계를 맺으려면 둘 다 유저 모델 인스턴스여야 하는데요
이 경우 유저 모델에 추가한 isFollower 메서드를 통해 팔로워 여부를 확인할 수
있습니다 그런데 logout 상황에서는 request.user는 user 모델 인스턴스가
아닌 anonymous user 파이썬 클래스의 인스턴스이기에, anonymous
user 인스턴스에서는 isFollower 메서드가 없죠.
이 경우 isFollower 플래그는 거짓으로 설정합니다.
logout 상황에서는 팔로잉을 하는 유저가 없으니 팔로잉 관계가 아닌 것이 맞죠.
템플릿에 팔로잉 여부를 나타내는 isFollower 플래그를 넘겨 팔로잉 여부에 따라 버튼을
다르게 보여줍니다.
팔로잉 중일 때에는 이 버튼을 클릭하면 언팔을 해야 할 테고요.
언팔 상태에서는 이 버튼을 클릭하면 팔로우를 해야겠죠.
페이지 새로고침해 보면 htmx 요청 처리 중에 500응답 서버 오류가 발생했네요.
개발 서버 로그를 보니 유저 팔로우에 대한 URL 리버스 시에 첫 번째 인자에 빈 문자열이
들어 있습니다.
장고 템플릿에서 빈 문자열은 참조되는 값이 없다는 의미입니다.
뷰에서 유저네임 이름의 값을 넘겨주지 않았었어요.
유저네임 값을 넘겨주고 페이지 새로고침해 보시면 URL 리버스가 잘 됩니다.
팔로잉은 htmx를 통해 포스트 요청으로 처리할 것이기에 각 버튼에 hx-post 요청으로
대상 주소를 지정하고요.
htmx-post 요청을 보내어 그 응답을 이 버튼에 그대로 반영할 테니까요.
텐데요. hx-swap 속성을 지정하지 않으면 default로 inner-html로
동작하고 그러면 태그 안에 태그가 중첩이 될 테니 hx-swap 속성을
outer-html로 지정해서 태그를 태그로 덮어쓰도록 설정합니다.
이제 유저 팔로우 뷰에서 요청을 처리하겠습니다.
포스트 요청에서 로그인 상태에서는 팔로우 처리를 할 것이고요.
isFollowUp 플래그는 참으로 설정하고 템플릿 응답을 하면 됩니다.
그러면 팔로잉된 버튼 응답이 화면에 반영될 것입니다.
로그아웃 상태에서는 팔로우 처리가 불가능하고요.
그러니 로그인 페이지로 이동을 시키고 로그인 후에 현재 유저 페이지로 다시 오도록 next
인자로 지정해 줘야만 합니다.
userUnfollowView 함수는 아직 전혀 구현하지 않았는데요.
userFollow 함수와 거의 동일한 구현일 것입니다.
이 부분, 유저의 팔로우 메서드 호출 부분만 unfollow 메서드를 호출하는 것을
제외하고는 똑같을 거예요.
그러니 userUnfollowView 함수를 따로 구현하지 않겠고요.
userFollowView 함수를 같이 사용하도록 해보겠습니다.
URL 패턴에서 unpar 요청에 대해서 user-follow 함수를 호출하도록 할
텐데요. 이렇게 패턴을 정리해 두면 user-follow 뷰 함수가 호출이 될 때 지금이
팔로우 요청인지, unpar로 요청인지 알 수가 없습니다.
pass 함수에서는 keyword argument 이름으로 뷰 함수가 호출이 될 때 추가로
전달한 인자를 사전 타입으로 정적으로 지정하실 수 있습니다.
팔로우 요청에서는 액션 인자를 팔로우 문자열로 전달하겠고요.
언팔로우 요청에서는 액션 인자를 언팔로우 문자열로 전달하겠습니다.
그럼 유저 팔로우 뷰 함수에서는 액션 인자를 통해 현재 요청이 팔로우 요청인지 언팔로우
요청인지를 판단할 수 있게 됩니다.
액션 인자가 팔로우 문자열이면 팔로잉 처리를 하고요.
아니라면 언파일 처리를 하겠습니다.
마지막으로 로그아웃 상황에서 팔로잉 요청이 왔을 때에는 로그인 페이지로 이동을 시킬
텐데요. htmx 요청이니 현재 페이지 주소는 hxcurrenturl 요청 헤더에 담겨
있습니다. 그 값을 읽어서 로그인 페이지에 next 인자로 지정해서 HTMX 응답에서
실제로 페이지 이동을 하도록
http://response-client-redirect-class를 통해 응답을 합니다.
그럼 유저 팔로잉 기능 구현 끝이고요.
템플릿 단에서는 유저의 로그인 여부를 판단할 필요가 없고요.
isFollower 플래그에 따라서 팔로잉 버튼만 적절하게 보여지고 서버로 포스트 요청을
보내어 그 응답을 화면에 보여주기만 하면 됩니다.
페이지 새로고침하시고요 로그인 상황에서 유저 페이지에 방문하시면 팔로잉 상황에 맞춰 버튼이
표시되고요 버튼을 클릭해서 팔로잉을 하시거나 언팔로잉을 하실 수 있게 됩니다
로그아웃을 하시면 언팔 상태로써 팔로잉하기 버튼이 보여지고요 클릭하시면 서버로 팔로잉
포스트 요청이 전송되고 서버에서는 로그인 페이지로의 리다이렉트 응답을 합니다.
로그인하시면 방금 전 로그인 페이지로 다시 이동을 하며 현 로그인 유저의 팔로잉 상황에
맞게 팔로잉 버튼이 보여집니다.
저는 alias ID의 유저로 로그인을 한 상태인데요.
제가 제 계정을 팔로잉할 필요는 없을 것입니다.
팔로잉을 풀고요.
underbar-user-follow.html 템플릿에서 유저 페이지의 유저가 로그인
유저일 경우에는 자기 자신에 대해서는 팔로잉 버튼을 노출하지 않도록 수정하겠습니다.


1. 유저 모델에 팔로잉 관계 추가
Many-to-Many 관계: User 모델에 다른 유저를 팔로우할 수 있는 Following User Set 필드를 추가하여 유저 간 팔로잉 관계를 설정합니다.
Symmetrical 설정: 팔로잉은 대칭 관계가 아니므로 symmetrical=False로 설정.
related_name 설정: 팔로워를 쉽게 조회할 수 있도록 FollowerUserSet을 설정.
메서드 추가:
is_follower: 특정 유저가 다른 유저를 팔로우하는지 확인하는 메서드.
follow: 다른 유저를 팔로우하는 메서드.
unfollow: 팔로우를 취소하는 메서드.
follower_count: 유저의 팔로워 수를 반환하는 메서드.
2. 뷰 함수 구현
유저 팔로우 및 언팔로우 뷰:
user_follow: GET 요청에서 현재 팔로잉 상태에 맞춰 버튼을 표시하고, POST 요청에서 팔로우 처리를 합니다.
user_unfollow: 언팔로우 요청에 대해 처리하는 뷰입니다. follow와 거의 동일하지만 unfollow 메서드를 호출합니다.
3. HTMX를 활용한 팔로우/언팔로우 버튼 처리
팔로우 버튼 템플릿:
underbar-user-follow.html 템플릿을 만들어 팔로잉 버튼을 컴포넌트화하고, user-page.html에서 이를 포함시킵니다.
HTMX 요청:
팔로우 버튼을 클릭하면 hx-post로 POST 요청을 보내고, 응답으로 받은 버튼 상태를 갱신합니다.
hx-swap="outerHTML"을 사용하여 버튼을 교체합니다.
4. 팔로우/언팔로우 처리 로직
팔로우 처리: 로그인된 유저가 다른 유저를 팔로우할 때, is_follower 플래그가 True로 설정되고, 템플릿에서 이를 반영하여 팔로잉된 상태의 버튼을 표시합니다.
로그인 안 한 상태: 로그인하지 않은 경우에는 팔로우 요청을 처리할 수 없으며, 로그인 페이지로 리다이렉트합니다. 리다이렉트 URL을 next 파라미터로 전달하여 로그인 후 원래 페이지로 돌아올 수 있게 합니다.
5. URL 패턴 설정
팔로우/언팔로우 요청 구분: URL 패턴에서 action 인자로 follow 또는 unfollow를 받습니다. 이를 통해 팔로우와 언팔로우 처리를 구분합니다.
user-follow 뷰에서 처리: action 인자에 따라 팔로우 혹은 언팔로우 로직을 분기하여 실행합니다.
6. 템플릿에서 팔로우 버튼 로직
팔로우 버튼 표시:
로그인 상태에서 유저 페이지에서 팔로잉 상태에 맞는 버튼이 표시됩니다. 버튼을 클릭하면 상태에 따라 팔로우 혹은 언팔로우가 처리됩니다.
로그인하지 않은 상태에서는 팔로우 버튼을 클릭하면 로그인 페이지로 리다이렉트됩니다.
7. 자기 자신에 대한 팔로잉 방지
자기 자신을 팔로우하지 않도록: 로그인 유저가 자기 자신을 팔로우하려는 경우에는 팔로우 버튼을 표시하지 않도록 underbar-user-follow.html 템플릿에서 조건을 추가합니다.
8. 기타 처리
htmx 요청 후 페이지 상태 처리:
요청에 따라 팔로잉 버튼이 동적으로 업데이트됩니다.
htmx 응답을 통해 서버에서 처리된 후 버튼을 즉시 갱신하여 페이지 새로고침 없이 사용자 경험을 개선합니다.
9. 기능 구현 결과
페이지 새로고침 없이 htmx를 통해 팔로잉/언팔로잉 버튼이 동적으로 변경됩니다.
로그아웃 상태에서 팔로우 버튼 클릭 시 로그인 페이지로 리다이렉트되고, 로그인 후 원래 페이지로 돌아옵니다.
자기 자신을 팔로우하는 버튼을 숨기는 로직을 통해 불필요한 팔로우를 방지합니다.
요약
유저 모델에 팔로잉 관계 추가 (Many-to-Many 필드 사용)
follow와 unfollow 메서드로 팔로우와 언팔로우 처리
htmx를 사용하여 버튼 클릭 시 페이지 새로고침 없이 팔로우 상태 변경
로그인/로그아웃 상태에 따른 처리 (로그인 안 하면 로그인 페이지로 리다이렉트)
템플릿 컴포넌트화 (underbar-user-follow.html) 및 자기 자신 팔로우 방지
팔로잉 상태에 맞춰 동적으로 버튼 변경