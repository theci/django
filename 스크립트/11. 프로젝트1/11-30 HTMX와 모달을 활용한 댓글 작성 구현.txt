이번 시간에는 자바스크립트를 거의 작성하지 않고 HTMX와 모델 컴포넌트를 활용하여 댓글 작성을 구현해 보겠습니다
포톨로그 앱에 Comment 댓글 모델을 작성하고요 소속 노트 필드, 작성자 유저 필드, 댓글 내용 필드, 그리고 생성 일시 필드, 수정 일시 필드로 구성합니다 데이터베이스 마이그레이션 수행해 주고요 
코멘트 모델에 대한 모델 폼인 comment_form_class를 정의하고요 유저에게는 메세지 필드만 입력 받도록 합니다 
댓글 생성 뷰인 comment-create-view-class를 정의하고요
모델 속성, 폼 클래스 속성 지정하고 템플릿은 crispy-forms.html을 활용합니다
URL 패턴도 등록해 줄 텐데요.
댓글 생성은 주체가 코멘트 모델이잖아요.
그런데 지금 PK 인자는 소속 노트의 기본 키이죠.
뷰에서 PK 이름만 보면 코멘트에 대한 기본 키로 오해할 소지가 다분하니 인자명을 보다 명확하게 note-pk로 지정하겠습니다.
note-detail.html 템플릿에 댓글 쓰기 버튼도 추가해 줍니다.
A 링크로 연결하면 클릭 시에 이렇게 페이지 전환이 될 테고요.
htmx 요청을 통해 댓글 생성 폼을 띄울 것이고요.
그래서 hx get 속성으로 댓글 생성 주소를 지정해 줍니다.
hx target 속성으로 body 요소를 지정해 주고요.
hx swap 속성으로 before end를 지정해 주면 htmx 응답이 body 요소 끝에 렌더링 됩니다.
페이지 새로고침하시고 댓글쓰기 버튼을 클릭해보시면 이렇게 바디 요소 끝에 댓글쓰기 페이지가 렌더링됩니다.
htmx 응답이 모달 폼이면 모달 폼으로 뜰 것입니다.
댓글 생성 템플릿은 포톨로그 앱에 언더바 코멘트 form.html 템플릿을 통해 구현하겠습니다. 
GET 요청에서는 modal form 응답을 할 것이고요.
form 응답은 post 요청에서와 get 요청에서 모두 동일한 렌더링이 필요하므로 partial define 템플릿 태그를 통해 form 렌더링 코드를 정의하고 활용하도록 합니다.
form 렌더링 전에 text만 지정하여 modal form 동작을 확인해보고요.
crispy 템플릿 태그를 통해 form을 렌더링 해보고요.
모델 폼을 띄워보면 댓글 폼이 잘 렌더링 됩니다
코멘트 폼, 폼 클래스에서 helper 속성을 통해 레이아웃을 커스터마이즈 하겠고요
Attribute 사전 속성을 통해 HTML 폼 태그에 필요한 속성을 추가 지정할 수 있습니다 
태그에서 폼 전송 시 HTMX를 통해 전송이 되도록 등의 속성을 지정해야 합니다
속성은 요청 객체를 참조하여 지정해야 하기에 일단 빈 문자열로 두고요 그 외에 속성과 속성을 지정합니다
댓글 쓰기 못할 폼을 브라우저 개발자 도구로 확인해 보시면 이렇게 태그에 각종 속성들이 잘 지정되어 있음을 확인하실 수 있습니다
helper 속성 지정 시에 request 객체가 필요하니깐요
helper 속성은 생성자를 통해서 지정하겠고요 생성자에서 request 인자를 추가로 전달받도록 합니다
그럼 이렇게 hxPost 속성을 지정해 줄 수 있게 되겠죠
그럼 Form 인스턴스 생성 시에 request 이름의 요청 객체 전달이 필요한데요
CreateView 클래스 기반 뷰에서는 getFormKeywordArguments() 메서드를 통해 Form 인스턴스 생성 시에 전달된 인자 목록을 사전으로 반환합니다
그러니 getForm 키워드 아규먼트 메서드를 재정의해서 request 요청 객체를 추가로 지정해 줍니다 
다시 댓글쓰기 모델 폼을 띄워 보시면 이렇게 hxPost 속성이 댓글 생성 주소로 잘 지정이 되어 있습니다
댓글 생성 폼에서 필드 레이블은 없어도 될 듯한데요 레이블 클래스 속성으로 d-none 클래스를 지정하시면 이 폼의 모든 필드 레이블을 숨길 수 있습니다
폼벨리드 메서드를 재정의해서 댓글 저장 전에 필수 필드인 작성자 필드와 노트 필드를 지정하고요 
작성자는 리퀘스트 객체의 유저 속성으로 지정하면 되지만 관련 노트는 note-pk 이름의 url-captured-value 값을 참조하여 조회를 해야 하잖아요
폼밸리드 메서드가 호출되는 시점은 유효성 검사가 끝나고 난 뒤인데요 이때
관련 노트를 조회하면 관련 노트가 조회되지 않을 경우 저장 시점에 404 오류가 발생하게 되죠 
관련 노트가 없다면 초기 생성 폼을 띄우는 시점에 404 오류가 발생해야 할 것입니다
그러니 dispatch 메서드를 재정의해서 관련 노트를 조회하고 없다면 404 응답을 하도록 합니다 댓글을 저장하고요.
성공 메세지를 남기고, htmx 응답을 위해 underbar-messages-as-event.html 템플릿으로 응답 객체를 생성하여 응답을 합니다.
댓글 쓰기 못할 폼을 다시 띄워서 메세지 입력 없이 폼 전송해보면 유효성 검사 잘 동작하고요. 
메세지 넣고 폼을 전송하면 이렇게 태그를 저장했습니다.
라는 성공 메세지도 잘 보여집니다.
댓글 생성 후에 modal 창이 자동으로 닫히기 위해 언더바 코멘트 폼.html 템플릿에서 body 요소에서 refreshCommentList 커스텀 이벤트가 발생하면 modal 요소에 hide 커스텀 이벤트를 발생시켜 modal 창이 닫히게 하겠습니다.
그럼 htmlx 응답에서도 refreshCommentList 커스텀 이벤트 응답이 있어야 할 것이고요.
추가해 줍니다.
댓글 쓰기 모델 폼을 다시 띄워서 댓글을 작성해 보시면 성공 메시지도 잘 뜨고 모델 폼도 자동으로 잘 닫혔습니다
댓글 목록 자동 갱신 기능은 댓글 새로고침 기능을 구현한 후에 적용하겠습니다
그런데 로그아웃 상황에서 댓글 쓰기 버튼을 클릭하면 로그인 페이지로 이동을 해야 할 텐데요
클릭을 해보면 로그인 페이지로 이동을 하지 않고 페이지 하단에 로그인 페이지가 추가되죠?
이는 CommentCreateView에서 LoginRequiredMixin 클래스를 통해 Location 헤더로만 페이지 이동 응답을 해서 그렇습니다.
그러니 htmx 요청에서는 그 페이지로 이동을 하는 것이 아니라 지정 주소의 페이지 응답을 받아서 htmx 렌더링을 할 뿐인 거죠.
htmx 페이지 이동을 위해 Django 공사 프로젝트에서 구현했던 LoginRequiredHx 장식자가 필요합니다.
Django 공사 프로젝트에서 복사해 주시고요.
이렇게 장식자 코드를 적용해 줍니다.
그런데 지금의 LoginRequiredHX 장식자는 함수에 대해서만 동작합니다.
함수에 대해서만 동작하는 장식자를 클래스에 적용할 때에는 method decorator 장식자를 활용하고요.
첫 번째 인자로 함수 장식자를 지정하고, 두 번째 인자로 그 장식자를 적용할 method 이름을 지정합니다.
이렇게 지정하시면 디스패치 메서드가 호출되기 전에 로그인 required HX 장식자가 먼저 수행됩니다.
로그아웃 상황에서 페이지 새로 고침하시고 댓글 쓰기 버튼을 클릭하시면 로그아웃 페이지로 잘 이동함을 확인하실 수 있습니다.