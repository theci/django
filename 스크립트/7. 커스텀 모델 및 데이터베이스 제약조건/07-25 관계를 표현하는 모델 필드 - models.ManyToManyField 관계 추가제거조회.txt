관계 필드 세 번째로써, 모델의 ManyToManyField를 살펴보겠습니다.
ManyToManyField는 m-n 관계에서 어느 쪽이라도 지정할 수 있습니다.
예를 들어, Post와 Tag의 관계에서 Post 측의 관계를 정의해도 되고, Tag
모델의 관계를 정의해도 됩니다.
태그는 포스트 외에도 다양한 모델에 의해서 사용될 수 있기에 태그를 사용하는 측인 포스트
측에 ManyToMany 관계 필드를 추가하겠습니다.
ManyToManyField에서도 RelatedName 설정과
RelatedQueryName 설정을 지원합니다.
RelatedName 설정은 디폴트로 ManyToManyField가 정의된 모델명 소문자
이름이 사용되고, RelatedQueryName 설정은 디폴트로
ManyToManyField가 정의된 모델명 소문자 이름이 사용됩니다.
이 default 설정을 그대로 사용할 경우, 이와 같이 post에 등록된 태그 목록
쿼리셋과 한 태그가 등록된 post 목록 쿼리셋을 생성하실 수 있습니다.
m-n의 관계에서는 관계를 저장하는 테이블이 필수인데요.
post 모델과 태그 모델만 현재 정의가 되어 있죠.
관계를 저장하는 테이블에 대해서는 모델 코드에 기소란 바가 없습니다
그런데 수행되는 SQL 쿼리를 보면 block, post, tag, set 이름의 테이블이
사용되고 있네요
ManyToManyField를 추가하면 관계 테이블을 자동으로 생성해 줍니다
물론 관계를 저장하는 모델을 정의하고 그 관계 모델을 통해서 ManyToMany 관계를
사용하실 수도 있어요
커스텀 관계 모델에 대해서는 뒤에서 살펴보겠습니다
태그 모델을 사용하는 다른 Post 모델이 있을 경우를 대비해서 RelatedName
설정과 RelatedCodeName 설정에 앱 이름을 추가하겠습니다.
그럼 이와 같이 쿼리셋 코드가 변경되어야 하고요.
수행되는 SQL 쿼리는 동일합니다.
Blog의 Post 모델에 태그셋 필드에 RelatedName 설정과
RelatedCodeName 설정을 추가합니다.
앱 이름과 모델명을 적용하는 거죠.
QuerySet 테스트를 위해 장고 셀을 열어주세요.
셀 플러스에서는 각 장고 앱의 모델들을 자동 임포트하는데요.
Post 클래스를 보니 샵 앱의 Post 클래스네요.
우리는 블로그 앱의 Post 클래스를 사용해야 하니 직접 임포트해줍니다.
첫 번째 포스트를 하나 조회하고요.
ManyToMany 관계 필드명을 통해 포스트에 등록된 태그 목록을 조회합니다.
수행된 쿼리 내역을 보니, BlogPost 태그 Set 관계 테이블과 조인해서 처리를
해주고 있네요.
태그 모델을 통한 Query Set에서는 Related Query Name인 Blog
Post를 통해 포스트에 등록된 태그 목록을 이렇게 조회하실 수 있습니다.
처음 태그를 하나 조회하고요.
태그 모델 인스턴스에서는 Related Name인 Blog Post Set을 통해서 태그가
등록된 포스트 목록을 조회하실 수 있고요.
포스트 모델을 통한 Query Set에서는 ManyToManyField, 필드명을 통해
동일한 조회를 수행하실 수 있습니다.
RelatedName, RelatedCodename 설정을 반영하면서 모델 필드 내역을
변경했습니다. 장고 마이그레이션은 데이터베이스 스키마 변경 여부와 상관없이 모델 필드의
변경 내역을 관리하기 때문에 지금 마이그레이션 파일 생성이 필요합니다.
makemigrations 블로그 명령으로 0019 마이그레이션 파일이 생성되었네요.
sqlmigrate 블로그 0019 명령으로 수행되는 SQL 내역을 보시면 비어있습니다.
수행되는 SQL 내역이 없더라도 migrate-blog 명령으로 migration을 적용해
주시고요. 버전 관리에도 추가해 주세요.
장고 migration은 모델 필드의 히스토리 관리가 핵심입니다.
ManyToManyField에 관계를 추가하고 제거하는 코드 예시를 살펴보겠습니다.
먼저 태그 3개를 태그1, 태그2, 태그3 이름으로 생성하고 태그 쿼리셋을 태그QS
이름으로 생성해 둡니다.
태그 모델에서 NameField는 유일성 제약 조건이 걸려 있기 때문에 같은 네임으로 다른
태그를 생성할 순 없습니다.
이때 getOrCreate 메서드를 사용하면 편리합니다.
지정 네임의 태그 존재 유무를 먼저 확인하고, 이미 있다면 그 태그 모델 인스턴스를
반환하고, 없다면 새로운 태그 모델 인스턴스를 생성해서 반환해줍니다.
반환 값은 튜플이고요.
첫 번째 값은 모델 인스턴스이며, 두 번째 값은 생성 여부 분리형 값입니다.
현재 코드에서는 생성 여부는 신경 쓰지 않을 것이기에 더밀 변수에 저장했습니다.
이 변수가 특별한 역할은 하는 것은 아니고요.
이 값을 사용하지 않을 것이라는 의도를 코드에 명확하게 표현한 것뿐입니다.
한 포스트 모델 인스턴스에 태그를 한 개 추가하고 제거하는 예시입니다.
관계에 대해서 데이터베이스에는 유일성 제약 조건이 추가되어 있지만, add 메서드를 여러
번 호출하더라도 오류가 발생하지 않습니다.
수행되는 SQL 쿼리를 보시면요.
끝에 유일성 제약 조건이 위배되더라도 이를 무시하도록 쿼리가 수행이 됩니다.
같은 태그 모델 인스턴스에 대해 중복해서 add 메서드를 호출해도 괜찮습니다.
태그 등록 여부를 확인해서 미등록 상황에만 add 메서드를 호출하실 필요는 없습니다.
그냥 add 메서드를 호출하시면 미등록 상황이면 데이터베이스에 인서트가 될 것이고, 등록
상황이면 조용히 무시가 됩니다.
remove 메서드도 여러 번 호출하셔도 오류가 발생하지 않습니다.
등록 상황이면 데이터베이스에서 제거될 것이고요, 미등록 상황이면 무시됩니다.
태그 등록 여부를 체크해서 등록 상황에서만 remove 메서드를 호출하도록 하실 필요는
없습니다. 두 개 이상의 태그를 등록하실 때에는 개별 태그마다 add 메서드를 호출하지
마시고요.
위치인자로 태그 모델 인스턴스를 여럿 넘겨주시면 됩니다.
그럼 하나의 쿼리로 관계가 저장됩니다.
태그 목록이 리스트나 튜플에 저장되어 있다면 Unpack 문법을 쓰시면 리스트 내 값이
개별 인자로 전달이 됩니다.
Remove method로 동일합니다.
쿼리셋은 순회 가능한 객체이므로 리스트 튜플과 마찬가지로 Unpack 문법이 가능합니다.
위에서 정의한 태그 언더바 QS 쿼디셋을 처음 사용했다면 데이터베이스 쿼디가 발생할
것이고요. 아래의 remove 메서드에서 태그 QS 객체를 다시 활용했을 때에는 이미
데이터베이스 조회를 한 이유이므로 추가 셀렉트 쿼디 없이 작업이 수행되었습니다.
마지막으로 포스트에 등록된 모든 태그 관계를 삭제하려면 clear 메서드를 호출합니다.
장고 셸를 구동해 주시고요.
블로그 앱에 태그 모델을 통해 태그를 생성할 텐데요.
태그 모델에서 네임 필드는 유일성 제약조건이 적용되어 있죠.
같은 이름의 태그는 생성할 수 없습니다.
get-or-create를 통해 장고 이름의 태그가 있다면 가져오고 없다면
생성하겠습니다.
get-while create에서는 튜플로 모델 인스턴스와 생성 여부를 반환합니다.
생성 여부 값은 거짓이네요.
그러면 조회된 모델 인스턴스입니다.
파이썬 태그 모델 인스턴스도 생성하고요.
웹 개발 태그 모델 인스턴스도 생성합니다.
앞서 생성한 태그들을 조회할 수 있는 쿼리셋도 생성해 둡니다.
셸플러스에 의해서 자동 임포트된 포스트가 샵 앱의 포스트네요.
블로그에 포스트 임포트 후에 샵 앱에 포스트가 임포트가 되어서 그런가 봅니다.
블로그 앱에 포스트 모델도 임포트하고요.
첫 번째 레코드에 대한 모델 인스턴스를 하나 생성하겠고요.
ManyToManyField, ModelField를 통해 현 Post Record에 등록된
태그 목록을 조회해 보니 저는 장고 태그 하나가 있네요.
Clear Method 호출로 등록된 태그를 모두 제거하겠습니다.
다시 태그 목록을 보니 비워졌습니다.
ManyToManyField, ModelField에 Add Method 호출로 태그 1을
인자로 전달하여 관계를 추가합니다.
즉시 인서트 코리가 수행되었죠.
태그 목록을 보니 방금 추가된 장고 태그가 보이네요.
ManyToManyField 모델 필드의 Remove 메서드 호출로 태그 1을 관계에서
제거합니다. 즉시 Delete Query가 수행되었고요.
Add 메서드나 Remove 메서드는 여러 번 수행해도 오류 없이 수행됩니다.
태그 목록을 보니 다시 비워졌네요.
이번에는 태그 두 개를 한 번에 등록합니다.
하나의 Insert Query로 두 개의 관계가 추가되었고요.
전체 목록을 보니 두 개의 태그가 등록되어 있습니다.
같은 태그로 다시 add를 수행해 봐도, 같은 insert query가 수행되었고, 오류도
발생하지 않았습니다.
태그 목록에는 여전히 태그 2개가 등록되어 있습니다.
태그 모델 인스턴스로 리스트를 하나 구성합니다.
매투맨이 관계를 저장할 때, 모델 인스턴스를 하나씩 관계를 맺는 것이 아니라, 리스트에
담아두고, 한 번에 관계를 맺도록 처리합니다.
리스트를 통해 한 번에 ManyToMany 관계를 맺을 때에는 리스트에 unpack 문법을
적용해서 하나의 리스트에 담겨진 값들을 풀어서 add 함수에는 여러 개의 인자로 넘겨지도록
합니다. 그럼 리스트에 담겨진 태그들로 인서트 쿼리가 오류 없이 잘 수행됩니다.
remove 메서드 호출에서도 리스트에 unpack 문법을 적용하여 호출하면 리스트 내에
모든 태그들이 관계에서 제거됩니다.
태그 목록을 보면 비워져 있습니다.
이번에는 앞서 생성한 태그 쿼리셋이 있죠.
태그 쿼리셋은 생성만 했을 뿐 아직 데이터베이스 조회가 발생하지 않은 쿼리셋입니다.
쿼리셋은 리스트 튜플과 마찬가지로 순회 가능한 객체이기 때문에 리스트처럼 unpack
문법을 적용하실 수 있습니다.
태그 _ QS 쿼리셋은 아직 데이터베이스 조회 전이었기 때문에 데이터베이스 조회가
발생했고, unpack을 통해 조회된 모델 인스턴스가 add 함수의 인자로 전달되어
수행되었습니다.
remove 함수에 대해서도 동일하게 인자를 지정하실 수 있고요.
태그 _ QS 쿼리셋 객체가 이미 데이터베이스 조회를 했었기 때문에 데이터베이스 조회
없이 remove 함수의 모델 인스턴스 인자가 지정되었습니다.
Query Set 객체 내에서 조회 결과를 캐싱하기 때문입니다.
만약 새로운 태그 _ QS Query Set 객체를 만드시고 나서 다시 Remove
메서드를 호출하시면 데이터베이스 조회가 다시 발생합니다.
ManyToManyField의 Clear 메서드를 호출해서 포스트의 모든 태그 관계를
삭제합니다. 이번에는 여러 태그명이 포함된 문자열을 가공해서 태그를 저장하는 방법에 대해서
살펴보겠습니다.
유저가 포스팅의 태그를 입력할 때 입력한 태그 중에 이미 데이터베이스에 저장된 태그도
있고, 저장되지 않은 태그도 있을 것입니다.
유저는 단지 그 포스팅 태그로써 저장될 태그들을 문자열 형태로 여럿 나열할 뿐인 거죠.
유저가 입력한 문자열 형태의 태그 목록이 있습니다.
이를 리스트로 먼저 변환하고요.
문자열 태그 리스트를 태그 모델 인스턴스로 구성된 리스트로 변환을 해줍니다.
getOrCreate 메서드를 통해 데이터베이스에 없는 태그는 새롭게 생성을 해주고요.
태그 관계를 저장할 모델 인스턴스가 있을 것이고요.
기존 포스팅에 등록된 태그 중에 새로운 태그 리스트에 없는 태그는 삭제되어야 할 것입니다.
이를 체크해서 없는 태그는 삭제하고 새로운 태그를 추가할 수도 있겠지만, 간결한 처리를
위해서 클리어 메서드를 호출하여 등록된 모든 태그들을 삭제하고 새로운 태그들로 다시
채워주도록 할 수 있습니다.
혹은 setMethod를 호출할 때 clear 참인자를 넘겨 포스트에 등록된 모든 태그
관계들을 삭제하고 지정 태그들로 관계를 저장하도록 하실 수 있습니다.
태그 관계로 저장할 태그 문자열이 있고요.
태그 관계로 저장할 태그 문자열이 있고요.
태그 문자엘을 콤마를 구분자로 리스트로 변환하면 각 태그명의 시작에 공백 문자엘이 포함되어
있네요. 앞뒤 공백 문자열을 제거하려면 문자열의 스트립 메서드를 활용합니다.
파이썬 쉘에서는 이전 처리 결과를 언더스코어 변수에 자동 저장하니까 언더스코어를 통해 이전 처리
결과를 태그네임 리스트 변수에 저장합니다.
태그 네임 리스트를 순회하며 각 태그 문자열을 바꾸어 태그 모델 매니저의
getOrCreate 메서드를 통해 태그 모델 인스턴스를 생성하고 태그 리스트 리스트에
누적하겠습니다.
관계로 저장할 모델 인스턴스는 반드시 저장이 되어 기본 키가 할당된 상태여야 합니다.
기본 키가 할당되지 않으면 외래 키 관계를 맺을 수가 없습니다.
수행된 Query 내역을 보니 Select Query만 있네요.
지정한 Query가 모두 이미 데이터베이스에 존재하는 태그였나 봅니다.
데이터베이스에 없는 태그가 있었다면 그 수만큼 Insert Query가 수행되었을 겁니다.
태그 리스트를 구성했고요.
PostModel 클래스는 Shop 앱에 PostModel이니 블로그 앱에 PostModel을
임포트하고 첫 번째 레코드에 PostModel 인스턴스를 생성합니다.
ManyToManyField 모델 필드인 태그 언더바 셋 속성의 clear 메서드를 호출하여
모든 태그 관계를 제거하고 태그 언더바 리스트를 언팩하여 개별 인자로 add 메서드를
호출합니다 태그 언더바 리스트에 담겨진 모델 인스턴스의 기본 키 값으로 Insert Query가 잘
전달이 되네요
등록된 태그 목록을 살펴보니 세 개 태그가 잘 등록되어 있습니다.
ManyToMany 필드 관계를 활용한 Post 태그 조회 예시입니다.
ManyToMany 필드 명을 활용해서 장고 태그가 등록된 Post 목록 쿼리셋을
이렇게 생성할 수 있습니다.
이번에는 태그가 한 개가 아니라 두 개 이상의 태그 중에 하나라도 등록된 Post 목록을
조회하려고 합니다.
__in lookup을 활용하여 포함 여부로써 쿼리가 동작합니다.
Join Query 수행으로 인해 중복행이 발생하므로 Distinct를 지정해서 중복행을
배제할 수 있습니다.
앞선 예시에서는 문자열 동등 비교를 수행하는데요.
대소문자를 무시하거나 포함 여부 등을 조회 조건에 추가하려면 이렇게 Queue 객체를
활용합니다. 큐 객체를 사용하기에 좀 더 복잡한 조건을 지정할 수 있겠죠.
장고 쿼리셋은 데이터베이스 서브 쿼리를 지원해 줍니다.
서브 쿼리란 다른 SQL 쿼리문 내부에 포함된 쿼리문을 말합니다.
주로 셀렉트, 인서트, 업데이트, 딜리트 쿼리문의 웨얼 절 내에서 조건을 정의하는데
사용됩니다. 원하는 범위의 태그 목록 쿼리셋을 먼저 생성하고요.
post 쿼리셋에 태그 언더바 set, 언더바 언더바 in, lookup을 통해 앞서
생성한 태그 쿼리셋을 지정하면 post 조회 SQL 쿼리 내에서 서브 쿼리로 태그 조회
SQL 쿼리가 수행됩니다.
앞서 살펴본 코드와 동일한 결과지만 이렇게 다른 접근으로 데이터베이스 조회를 하실 수
있습니다. 포스트 제목에 특정 검색어가 포함된 태그 목록을 조회하려면 이렇게 Related
Query Name을 활용해서 조회하실 수도 있습니다.



ManyToManyField 개요
ManyToManyField는 m:n(다대다) 관계를 설정하는 Django 모델 필드입니다. 이 필드를 통해 두 모델 간에 서로 연결된 여러 인스턴스를 다룰 수 있습니다. 예를 들어, Post와 Tag 모델 간의 관계를 설정할 수 있습니다.

1. ManyToMany 관계 설정
Post와 Tag의 관계에서, ManyToManyField는 어느 쪽에든 정의할 수 있지만, Post 모델에서 Tag 모델을 참조하는 형태로 설정하는 것이 일반적입니다.
RelatedName과 RelatedQueryName을 설정하면 관련된 역방향 관계를 정의할 수 있습니다.
2. RelatedName 및 RelatedQueryName
**RelatedName**은 ManyToManyField가 설정된 모델에서 역방향으로 접근할 때 사용할 이름을 정의합니다. 기본값은 모델 이름을 소문자로 한 값입니다.
**RelatedQueryName**은 쿼리셋에서 해당 관계를 필터링할 때 사용할 이름을 정의합니다.
예를 들어, RelatedName을 blog_posts로 설정하고, RelatedQueryName을 tags로 설정하면, Post에서 Tag에 대한 역방향 관계를 blog_posts로 접근하고, Tag에서 Post에 대한 역방향 관계를 tags로 접근할 수 있습니다.
3. ManyToManyField에 대한 SQL
Django는 ManyToManyField를 정의하면 자동으로 관계 테이블을 생성합니다. 이 관계 테이블은 두 모델 간의 연결을 저장합니다. 예를 들어, Post, Tag, block 등의 테이블이 생성될 수 있습니다.
관계를 저장하는 테이블은 Django에서 자동으로 관리하지만, 커스텀 관계 모델을 정의해서 수동으로 관계를 설정할 수도 있습니다.
4. add, remove, clear 메서드
add(): 여러 개의 객체를 관계에 추가할 수 있습니다. 같은 객체를 여러 번 추가해도 오류는 발생하지 않습니다.
remove(): 특정 객체를 관계에서 제거할 수 있습니다. 이미 없으면 무시됩니다.
clear(): 관계에 등록된 모든 객체를 제거합니다.
**add와 remove**는 리스트나 튜플 형태로 여러 객체를 한 번에 처리할 수 있습니다. Unpack 문법을 사용하여 여러 인자를 한 번에 전달할 수 있습니다.
5. get_or_create() 메서드
**get_or_create()**는 모델에서 객체를 찾고, 존재하지 않으면 새로 생성하는 메서드입니다. 이를 사용하여 태그와 같은 유일성 제약이 있는 필드를 처리할 수 있습니다.
6. 태그 문자열을 사용한 관계 저장
사용자가 태그 문자열을 입력할 때, 이를 처리하여 ManyToMany 관계에 추가할 수 있습니다.
get_or_create() 메서드를 사용하여 문자열을 태그 인스턴스로 변환하고, clear() 메서드를 사용하여 기존 태그를 제거한 후 새로운 태그 목록을 추가할 수 있습니다.
7. 쿼리셋 활용
**in lookup**을 사용하여 여러 태그 중 하나라도 포함된 포스트를 조회할 수 있습니다.
서브 쿼리를 활용하여 한 모델에서 다른 모델을 조건으로 조회하는 쿼리도 가능합니다.
**RelatedQueryName**을 사용하면 특정 조건에 맞는 태그를 기반으로 포스트를 조회할 수 있습니다.
요약
ManyToManyField는 두 모델 간의 m:n 관계를 정의하며, Django는 관계 테이블을 자동으로 생성합니다.
RelatedName과 RelatedQueryName을 사용하여 역방향 관계 및 쿼리 조건을 지정할 수 있습니다.
add, remove, clear 메서드를 통해 관계를 추가, 제거, 초기화할 수 있으며, get_or_create() 메서드를 사용하여 중복을 처리할 수 있습니다.
태그 문자열을 입력받아 관계를 저장하거나, 쿼리셋을 활용해 동적으로 조회할 수 있습니다.