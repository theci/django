수강 신청 시스템에서는 한 학생이 한 강의에 대해서 한 학기에 한 번만 수강 신청할 수
있도록 제한되어야 합니다.
이를 위해 수강 신청 모델에서 학생, 강의, 학기 3개 컬럼에 대한 유일성 제약 조건이
필요합니다. 복수 컬럼에 대한 유일성 제약 조건을 설정하는 방법은 두 가지가 있습니다.
첫 번째 방법은 모델의 메타 클래스에 unique together를 사용하여 유일성을 보장할 필드들을
지정하는 것입니다.
이 방식은 지정된 필드들의 조합에 대해 데이터베이스 수준에서 유일성 제약 조건을
생성합니다. 외래킷 필드에 대해서는 외래킷 값인 정수 값을 사용하여 유일성 제약 조건을
확인합니다. 그런데 unique together는 향후 장고에서 사용이 중단될 예정이므로 대신 두 번째
방법을 권장합니다.
두 번째 방법은 UniqueConstraint의 fields 인자로 유일성을 같이 확인할 필드명들을
나열하는 것입니다.
첫 번째 방법과 동일한 쿼리가 생성되며 쿼리셋 동작도 동일합니다.
두 방법 모두 유효성 검사 과정에서 데이터베이스를 조회하여 유일성 여부를 확인하고요.
이때 학기 필드에 대해서는 대소문자를 구별해서 유일성 여부를 확인합니다.
대소문자로 구별하지 않고 유일성 제약 조건을 적용하기 위해서는 lower 데이터베이스 함수
적용이 필요한데요 유니크 컨스트레인트의 필드 인자는 단순히 필드명만을 나열할 뿐
데이터베이스 함수를 적용할 수 없습니다
fields 인자를 사용하지 않고 expression 인자를 사용하면 데이터베이스 함수를
적용할 수 있습니다.
expression 인자는 키워드 인자가 아니라 위치 인자로만 지정할 수 있습니다.
그래서 위치 인자로 유일성을 함께 체크할 필드들을 나열하고, 학기 필드에 대해서는
lower database 함수를 적용합니다.
인덱스 생성 쿼리에서도 학기 필드에 lower 데이터베이스 함수가 적용된 것을 확인할
수 있고요. 유효성 검사에서도 lower 데이터베이스 함수가 적용되어 수행됨을 확인할
수 있습니다.
슬라이드 하단에 안내된 링크의 페이지에서 모델 코드를 복사해서 적용하겠습니다.
유일성 제약 조건에 대한 마이그레이션만 따로 확인하기 위해 메타 클래스를 제외한 모델 필드
내용만 복사해서 먼저 Make Migration 명령을 수행하고요.
그 후에 메타 클래스를 적용하고 Make Migrations 명령을 한 번 더 수행합니다.
방금 블로그 앱에 0017 마이그레이션 파일이 생성되었고요.
SQL 마이그레이트 블로그 0017 명령으로 수행될 코드내역을 살펴보니 복수 필드에 대한
유니크 인덱스가 생성되며, 학기 필드에는 lower database 함수가 적용될 것임을
확인하실 수 있습니다.
블로그 앱에 대한 마이그레이션 적용내역을 확인해 보면, 16번과 17번 마이그레이션이 현재
미적용이고요.
마이그레이트 명령으로 해당 마이그레이션을 데이터베이스에 적용합니다.
장고셀을 구동하고 새 학생과 새 코스를 생성하고, 수강신청 모델 인스턴스를 생성하고,
유효성 검사를 수행해 보면, 유효성 검사 시에 lower() 데이터베이스 함수가 사용됨을
확인하실 수 있습니다.



이번에는 수강 신청 시스템에서 한 학생이 한 강의에 대해 한 학기에 한 번만 수강 신청할 수 있도록 복수 컬럼에 대한 유일성 제약 조건을 설정하는 방법을 다뤘습니다. 핵심 내용은 다음과 같습니다:

1. 복수 컬럼에 대한 유일성 제약 조건 설정
수강 신청 모델에서 학생, 강의, 학기 3개의 필드에 대해 유일성 제약 조건을 설정해야 합니다. 즉, 학생-강의-학기의 조합이 유일하도록 보장합니다.
두 가지 방법으로 복수 컬럼에 대한 유일성 제약 조건을 설정할 수 있습니다.

첫 번째 방법: unique_together 사용

모델의 메타 클래스에 unique_together를 사용하여 유일성 제약 조건을 설정합니다.
예를 들어, unique_together = ['student', 'course', 'semester']와 같이 설정하여 3개의 필드 조합이 유일하게 됩니다.
그러나, **unique_together**는 장고에서 향후 사용이 중단될 예정이므로, 두 번째 방법을 사용하는 것이 권장됩니다.
두 번째 방법: UniqueConstraint 사용

모델의 메타 클래스에서 UniqueConstraint를 사용하여 fields 인자로 유일성 제약을 적용할 필드들을 나열합니다.
예: UniqueConstraint(fields=['student', 'course', 'semester'], name='unique_course_registration')
이 방법은 **unique_together**와 동일한 쿼리와 동작을 생성합니다.
2. 대소문자 구별 없이 유일성 제약 적용하기
학기(semester) 필드는 기본적으로 대소문자를 구별하여 유일성을 검사합니다.
만약 대소문자 구별 없이 유일성을 체크하고 싶다면, lower 데이터베이스 함수를 적용해야 합니다.
방법:

UniqueConstraint에서 fields 인자만 사용하면 lower 함수 적용이 불가능하므로, expression 인자를 사용하여 lower 함수를 적용합니다.
예: UniqueConstraint(fields=['student', 'course', 'semester'], name='unique_course_registration', condition=Lower('semester'))
**expression**을 사용하면 데이터베이스 쿼리에서 학기 필드에 lower() 함수가 적용되어, 대소문자를 구별하지 않고 유일성을 검사할 수 있습니다.

3. 마이그레이션 파일 생성 및 적용
모델 코드에서 복수 필드에 대한 유일성 제약을 설정한 후, makemigrations 명령을 통해 마이그레이션 파일을 생성합니다.
메타 클래스에 UniqueConstraint를 추가한 후 다시 makemigrations 명령을 실행하여 마이그레이션 파일을 갱신합니다.
생성된 마이그레이션 파일을 확인하면, 유일성 제약 조건과 함께 lower() 데이터베이스 함수가 적용된 인덱스가 생성되는 쿼리를 확인할 수 있습니다.
migrate 명령으로 해당 마이그레이션을 데이터베이스에 적용합니다.
4. 유효성 검사
장고 셀을 사용하여 새로운 수강 신청 인스턴스를 생성하고, 유효성 검사를 수행하면, lower() 데이터베이스 함수가 적용된 유일성 검사 과정이 확인됩니다.
예를 들어, semester 필드에 대해 대소문자 구별 없이 유일성 검사가 수행되는 것을 확인할 수 있습니다.
결론
수강 신청 모델에서 학생, 강의, 학기 3개의 컬럼에 대해 유일성 제약 조건을 설정하려면 **UniqueConstraint**를 사용하는 방법이 권장됩니다.
대소문자 구별 없이 유일성 제약 조건을 적용하려면 lower() 데이터베이스 함수를 활용하여 검사를 수행할 수 있습니다.
마이그레이션 파일을 통해 유일성 제약 조건을 적용하고, 유효성 검사를 통해 데이터 무결성을 보장할 수 있습니다.