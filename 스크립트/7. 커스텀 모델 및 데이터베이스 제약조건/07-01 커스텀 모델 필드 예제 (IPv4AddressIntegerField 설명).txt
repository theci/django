안녕하세요 이번 시간에는 두 개의 커스텀 모델 필드를 만들어 보겠습니다 장고에서 기본
지원하는 모델 필드 외에도 커스텀 모델 필드를 정의하여 원하는 데이터베이스 필드 타입에
맞춰 모델 필드를 구성할 수 있습니다
커스텀 모델 필드가 필요한 이유는요 첫 번째, 장고 기본 모델 필드에서 지원하지 못하는
데이터 포맷이 있을 때입니다
예를 들어 y 혹은 n 문자를 저장하는 불리한 필드를 두어 파이썬 딴에서는 참 혹은
거짓으로 처리하고 데이터베이스에는 y 혹은 n 문자로 저장하며 일관된 참 거짓 처리를 할
수 있습니다 두 번째로 재사용성 높이기 위함인데요
특정 프로젝트에 필요한 독특한 데이터 타입이나 유효성 검사 로직을 포함한 모델 필드를 한
번 정의해 두면 여러 모델 혹은 여러 프로젝트에서 재사용성을 높일 수 있고 코드의 가독성도
높일 수 있습니다.
주민번호 관련 유효성 검사와 암호화 및 입력 위젯이 지정된 주민번호 필드를 예로 들 수
있겠습니다. 세 번째로 데이터베이스 최적화인데요
특정한 형태의 쿼리를 더 효율적으로 처리하기 위해 데이터베이스의 특정 기능을 활용하는
커스텀 모델 필드를 생성할 수 있습니다
예를 들어 IP를 정수로 저장하는 필드를 두어 더 작은 저장 공간을 사용하고 검색 속도를
높일 수 있습니다
IPv4 IP를 데이터베이스에 정수로 저장하는 IPv4AddressIntegerField
모델 필드 예시입니다.
문자열 IP를 정수로 저장하면 더 작은 저장 공간을 사용하고 검색 속도를 높일 수
있습니다. 먼저, 문자열과 숫자의 대소 비교 특성에 대해서 살펴보겠습니다.
정열에서도 대소 비교 특성이 활용됩니다.
192.168.0.10 IP와 192.168.0.2, 192.168.0.1 IP 리스트를
오름차순으로 정렬한다면 어떤 결과를 예상하시나요?
오름차순 정렬을 수행해 보면 .10 IP가 .2 IP보다 작다는 판정을 받습니다.
그 이유는 문자열의 대소비교에서는 문자열의 0번 인덱스부터 같은 인덱스의 문자 간의 크기를
비교해가며 대소비교가 판가름이 날 때까지 인덱스를 증가시켜가며 비교합니다.
문자열 10과 문자열 9는 0번 인덱스에서 문자열 1과 문자열 9에 비교해서 문자열 1의
ASCII 코드 값은 49, 문자열 9의 ASCII 코드 값은 57로써 문자열 9가 더
크기에 다음 인덱스 비교 없이 우항이 더 크다는 판정을 받습니다.
튜플 간의 비교도 마찬가지이고요.
하지만 숫자 간에 비교해서는 숫자 10이 숫자 9보다 더 크죠.
IP 오름자순 정렬에서 .10 IP가 .2 IP보다 크다는 판정을 받으려면 문자열
타입으로서의 비교가 아니라 숫자 타입으로 변환한 후에 비교가 이루어져야 합니다.
이를 도와주는 라이브러리가 파이썬 기본 라이브러리에서 IP 주소 모듈이 있습니다.
IPv4와 IPv6를 모두 지원하는데요.
여기에서는 IPv4 지원만을 위해 IPv4Address 클래스만을 사용하겠습니다.
IP_리스트, List를 순회하며 각 문자열 IP를 숫자로 변환합니다.
숫자로 보니 192.168.0.10의 숫자 값이 192.168.0.2의 숫자 값보다 크게
나오죠 192.168.0.1 IP의 숫자 값은 323,223,5521로 나오는데요
이 값은 각 옥텟의 숫자를 바이트 위치에 맞춰 비트 연산한 후에 더한 값입니다
IP를 문자열로 표현하면 최대 15바이트의 공간을 차지하지만 이렇게 숫자로 표현하면
4바이트만 차지하네요
그리고 대소비교로 바르게 동작합니다
숫자 값으로 정렬해보면 이렇게 수치적 순서에 따라 정렬이 되고요.
숫자 값이 아닌 IPv4AddressInstance로 정렬을 해봐도 IPv4Address
내부에서 정수 값으로 대소 비교가 이루어지기에 동일하게 수치적 순서대로 정렬이 됩니다.
뒤에서 IPv4AddressIntegerField 을 구현할 텐데요 구현에 앞서 IP를
문자열로 처리했을 때와 정수로 처리했을 때의 차이점을 먼저 예시로 살펴보겠습니다 새로운
모델, AccessLog 모델을 정의했고요 첫 번째 IP Underbar Generic
Field는 GenericIPAddressField를 사용하고 두 번째 IP
Underbar IntField는 IPv4AddressIntegerField를 활용하여
정수로 IP를 처리해 보겠습니다
MySQL과 PostgreSQL에 대해서 각각 SQL Migrate 명령으로 수행될
쿼리를 확인해 보면 첫 번째 IP GenericField에 대해서 MySQL은 문자열
타입으로 컬럼이 생성되고, PostgreSQL에서는 INET 타입으로 컬럼이 생성됩니다.
IP 타입 지원은 PostgreSQL이 유일하며, 그 외의 데이터베이스에서는 IP 타입
지원이 없기에, 장고는 문자열 타입으로 IP를 저장합니다.
두 번째 IP UnderbarIntField에 대해서는 MySQL에서는 4-byte
unsigned 정수 타입으로 필드를 생성할 것이고요
그런데 PostgreSQL과 Oracle에서는 unsigned 지원이 없기에 8-byte
정수 타입을 사용할 것입니다
4-byte 정수 타입을 쓰면 unsigned가 없기에 양수 범위에서 표현할 수 있는 값의
범위가 절반밖에 되지 않습니다
즉, IP를 최대 127.255.255.255까지만 저장할 수 있습니다.
그래서 8 바이트 정수 필드를 생성할 것이고요.
PostgreSQL에서는 IP를 위한 INET 타입 지원이 있기에 굳이
IPv4AddressIntegerField를 쓸 필요가 없긴 합니다.
슬라이드에서는 비교를 위해 MySQL과 PostgreSQL에 대한 두 가지 예시를
들었지만 실습에서는 혼란을 줄이기 위해 FoursquareSQL 하나로 진행하겠습니다.
migrate 명령으로 데이터베이스에 적용 후에 192.168.0.1,
192.168.0.2, 192.168.0.10 IP 리스트로 액세스 로그 모델을 통해
레코드를 저장합니다.
IPUnderbarIntField는 양쪽 데이터베이스에서 정수로 변환되어 저장될 것이며,
IPGenericField는 MySQL에서는 문자열로 저장되고,
FoursquareSQL에서는 INET 타입으로 저장이 됩니다.
앞서 살펴본 문자열과 숫자의 대소비교 특성이 다르듯이 데이터베이스에도 동일하게 적용됩니다.
IP Generic Field는 MySQL에서는 문자열 필드이기에 IP
GenericField를 기준으로 오름차순 정렬을 하면 문자열 특성으로 정렬되어
192.168.0.10IP 다음에 .2IP로 정렬됩니다.
PostgreSQL에서는 INETField이기에 INETField 특성으로 IP가 수치적 순서대로
정렬됩니다.
IP-INTField는 모든 데이터베이스에서 정수 필드이기에 수치적 순서대로 정렬이
됩니다. 범위 조회에도 앞선 대소 비교 특성이 그대로 적용이 됩니다.
192.168.0.1 IP와 192.168.0.9 IP 사이에 IP를 검색하려 합니다.
MySQL에서 IP generic 문자의 필드를 기준으로 조회를 하면 문자열 특성으로
조회가 되기에 192.168.0.10 IP까지 조회가 됩니다.
하지만 PostgreSQL에서는 IP generic field가 INET 타입이므로
조회를 하면 192.168.0.10 IP는 조회되지 않습니다.
IPIntField는 모든 데이터베이스에서 정수값으로 조회되기에 192.168.0.10
IP는 조회되지 않습니다.
IPv4 주소를 정수로 저장하고 조회하는 IPv4AddressIntegerField 모델
필드를 구현해 보겠습니다
이 모델 필드는 웹을 통해 값을 입력받을 때와 쿼리셋 작성 시에는 문자열 타입으로 IP를
입력받아 처리할 것이기에 모델스의 CharacterField 클래스를 상속받고 최대 입력
길이는 15글자로 디폴트 설정합니다
내부적으로 4-byte unsigned 정수 필드로 데이터베이스에 저장하고 쿼리셋을 작성할
것이기에 getInternalType 메서드를 재정의해서 파시티브 인티저 필드를 반환합니다
그런데 Foursquare SQL과 Oracle에서만 파시티브 인티저 필드는 4-byte에
부호가 있는 정수이므로 양의 범위에서 unsigned에 비해 값의 범위가 절반이 되어 모든
IP를 다 저장할 수 없습니다 255.255.255.255까지 모든 IP를 담을 수 있도록
PostgreSQL과 Oracle에 대해서만 8바이트 정수형으로 지정하겠습니다.
DB 타입 메서드를 재정의해서 현재 연결이 PostgreSQL 혹은 Oracle
일대에만 8-byte 정수형을 지정하고 나머지 데이터베이스에서는
GetInternalType을 통해 지정된 기본 타입을 활용하도록 하겠습니다
SQLite에서는 IntegerUnsignedType이고요 MySQL에서도
IntegerUnsignedType이 됩니다 추가로 세 개의 메서드를 재정의했습니다
첫 번째로 FromDbValue 메서드는 데이터베이스로부터 정수 IP 값을 조회하고 문자열
IP 값으로 변환할 때 호출이 됩니다
인자로 데이터베이스로부터 조회한 필드 값이 전달되며, null일 경우에는 non으로 인자를
전달받게 됩니다.
toPython 메서드를 통해 정수 IP에 대한 값 변환을 처리하겠습니다.
두 번째로 getPreparedValue 메서드는 입력된 값을 데이터베이스에 저장 혹은
코리아 형태로 변환하는 역할을 합니다.
모델 필드나 코딧의 조회 값으로 문자열 IP나 정수 IP를 받더라도 항상 정수 IP로
반환합니다. 부모의 getPreparedValue method을 호출하면 내부에서
toPython method을 호출하여 값 변환을 수행합니다.
현재 우리 구현의 toPython method는 None이나 문자열 IP를 반환합니다.
그러니 값이 non이라면 non을 반환하고, non이 아니라면 문자열 IP겠죠.
문자열 IP를 정수 IP로 변환해서 반환하도록 하겠습니다
세 번째로 toPython 메서드는 인자로 문자열 IP 혹은 정수 IP를 받을 수 있고요
항상 문자열 IP를 반환하도록 합니다 구현부 시작에서 현재 모델 필드에 null 옵션이
켜져 있고 현재 필드 값이 빈 값을 나타내는 값 중에 하나라면 논 값을 반환하고요.
HTML 폼을 통해 값을 입력받을 때 모든 값은 문자열입니다.
모델 필드에서 적절한 변환이 필요한데요.
정수 IP가 타입이 문자열로 넘어올 수 있으니 값이 문자열 타입이고 값의 모든 문자가
숫자로 구성되어 있다면 이를 숫자로 변환해서 IPv4Address 클래스를 통해 문자열
IP로 변환하여 반환합니다.
값에 오류가 있어 IP 변환에 실패할 경우 ValidationError 예외를 발생하도록
합니다.
ValidationError는 유효성 검사 에러를 발생시키는 오류로서 이후 장고 폼즈
챕터에서 자세히 다룰 것입니다.
예외 메시지를 저장할 때 하드 코딩으로 오류 메시지를 저장하지 않고 클래스 변수로서 디폴트
에러 메시지를 정리하고 이를 참조하도록 했습니다.
다른 모델 필드의 에러 메시지 처리부를 그대로 가져왔습니다.
이러한 구성으로 클래스 코드를 변경하지 않아도 필드 정의 시에 에러 메시지를 손쉽게 변경할
수 있고, 국제화에도 대응해서 여러 언어별로 에러 메시지 번역을 제공할 수 있습니다.
null을 허용할 때와 null을 허용하지 않을 때의 에러 메시지도 다르게 지정했습니다.