이번에는 블로그 앱 포스트 모델을 중심으로 관계 모델에 대해서 살펴보겠습니다
제가 ChatGPT를 통해서 미리 생성해 둔 JSON 샘플 데이터가 있습니다
이 데이터를 로딩해서 카테고리, 포스팅, 태그, 댓글 데이터를 추가해 봅시다 장고 커스텀
매니지먼트 명령으로 구현했으며 슬라이드 하단의 링크에서 소스 코드를 확인하실 수 있습니다
로드 블로그 포스트 명령의 소스 코드를 지정 경로에 복사합니다 지정 경로에 샘플 데이터를
로드하여 블로그 장고 앱의 여러 모델에 데이터를 추가하는 명령입니다 명령의 옵션으로 포스트
제이손 데이터의 URL과 댓글 텍스트 데이터의 URL을 지정할 수 있도록 했고요 그리고 새
데이터를 저장하기 전에 기존 데이터를 모두 삭제하는 플래그 옵션도 추가를 했습니다
디폴트 샘플 포스트 제이손 데이터 주소와 디폴트 샘플 댓글 텍스트 데이터 주소를 열어서
데이터 포맷을 확인해 봅니다
파이썬 매니지파이 로드 언더바 블록 언더바 포스트 명령으로 명령이 구동되면 핸들 메서드가
호출되며 명령을 수행합니다.
핸들 메서드의 키워드 인자로 addArguments 메서드에서 지정한 명령 옵션을 전달
받습니다. 데이터 삭제 플래그가 설정되었다면 클리어 데이터 메서드를 호출하여 테이블
데이터를 모두 삭제합니다.
지정 URL에 JSON 파일과 텍스트 파일을 모두 내려받고요.
내려받은 내역으로 카테고리, 태그, 포스트, 댓글들을 생성할 거예요.
카테고리를 생성할 때에는 먼저 데이터베이스에 저장된 카테고리 이름을 집합으로 변환해
두고요. 생성할 카테고리 명도 집합으로 변환합니다.
차집합, 연산으로 데이터베이스에 없는 카테고리 명만 뽑아서 카테고리 모델 인스턴스 리스트를
생성하고 bulk create를 통해 일괄 생성합니다.
태그도 카테고리와 마찬가지로 데이터베이스 없는 태그명만 뽑아서 태그 모델 인스턴스 리스트를
생성하고 bulk_create를 통해 일괄 생성합니다.
포스트의 경우에는 카테고리와 유저에 대한 외래키 필드 지정이 필요합니다
매번 데이터베이스에서 조회할 수도 있겠지만 생성할 포스트의 개수가 아주 많을 때에는 먼저
데이터베이스에서 전체 카테고리를 조회한 뒤에 카테고리 명을 키로 갖고 값으로 모델
인스턴스를 가지는 사전을 만들어서 활용하면 데이터베이스 부하를 줄이실 수 있습니다
태그에 대한 모델 인스턴스 사전도 생성하고요.
post 모델 인스턴스를 생성한 후에 title 필드의 값이 채워져 있으니 slugify
메서드를 호출하여 slug 필드 값도 채워줍니다.
아직 post 모델 인스턴스를 생성하기 전이니 태그 모델과의 관계를 맺을 순 없습니다.
임시 속성으로 post에 태그 리스트를 잠시 저장해두고요.
bulk create를 통해 일괄 생성한 뒤에 post 리스트를 순회하며 태그와의
메인투맨이 관계도 추가해줍니다.
댓글 생성에서는 인자로 각 줄마다 댓글 내용이 담긴 문자열이 전달됩니다.
문자열 데이터를 3배 크기로 늘려줬고요.
줄 단위로 끊어서 리스트로 변환도 했습니다.
줄 단위로 순회를 돌면서 좌우 공백을 제거한 문자열이 빈 문자열이 아닐 때 코멘트 모델
인스턴스를 생성해 주고요.
bulk create를 통해 일괄 생성합니다.
터미널을 여시고 로드 블로그 포스트 클리어 명령을 실행해 주세요.
이렇게 샘플 데이터가 모두 생성되었습니다
데이터베이스 테이블을 조회해 보시면 데이터들이 모두 잘 들어 있고요 각 외래키 관계들도 잘
지정되어 있음을 확인하실 수 있습니다 포스팅 목록 페이지 기본을 구성하고요 템플릿 내에서
포스팅 목록에서 작성자의 유저명을 출력해 봅니다
장고 디버그 툴바를 통해 수행되는 SQL 내역을 보면, 유저명을 출력하기 전에는 3개의
코드였는데, 유저명을 출력하니 레코드 개수 100개가 더해져 103개의 코드가 수행되었음이
확인됩니다.
N+1 문제네요.
작성자 필드는 외래키 필드이기에, select related을 통해서 즉시 로딩할 수
있으며, 혹은 prefetch related을 통해서도 즉시 로딩을 수행할 수 있습니다.
슬라이드 하단에 템플릿 소스코드 링크가 있고요.
블로그의 views.py 파일에 post__listview 함수를 생성합니다.
전체 포스트를 조회하는 코드셋을 생성하고, 블로그의 post__list.html 템플릿을
통해 HTML 응답을 렌더링합니다.
블로그의 urls.py 파일에 post__listview에 대한 url 패턴도 추가합니다.
템플릿 랩 인자의 값에 물결 표시가 있는데요.
해당 이름의 템플릿 파일을 파이참이 못 찾고 있음을 의미합니다.
아직 이 이름의 템플릿 파일은 만들어주지 않았어요.
파이참의 기능을 활용해서 템플릿을 생성하려는데, 블로그의 폴더가 아닌 다른 앱 경로의
템플릿을 생성하려고 시도하네요.
블로그의 폴더 밑에 템플릿 폴더가 없어서 그렇습니다
블로그 폴더 밑에 템플릿 폴더를 생성해 주시고 다시 시도해 보시면 파이참을 통해 블로그
밑에 템플릿 경로에 템플릿 파일을 자동 생성하실 수 있습니다
템플릿 파일이 생성된 템플릿 경로는 블로그 밑에 템플릿 밑에 블로그 밑에
post__list.html입니다. 제공해드린 템플릿 소스 코드를 복사해서 붙여넣기
해주세요. 간결한 페이지 스타일링을 위해 미니멀 CSS 프레임워크인 pico-css를
적용했습니다.
HTML 페이지 내에서 별도 클래스명 지정 없이도 어느 정도 스타일링이 입혀집니다.
pico-css 외에도 MVP라는 CSS 프레임워크도 있어요.
장고 개발 서버 구동을 확인하시고 http://localhost:8000의 블로그 주소로
접속하시면 이렇게 블로그 포스트 페이지가 뜹니다
각 포스트의 제목과 작성자 유저명이 출력되고 있죠
장고 디버그 툴바를 통해 수행된 SQL 쿼리 개수를 확인해 보시면 101개의 쿼리가
수행되었네요 레코드 개수가 100개이니 M++ 문제가 발생한 듯 보이고요 웹페이지 렌더링에
100개의 쿼리는 너무 많습니다
포스트 모델의 author 작성자 필드는 외래키 필드이니 select related를 통해
즉시 로딩을 수행할 수 있습니다.
적용하니 INNER JOIN 쿼리도 실행되어 쿼리 수가 1개로 확 줄었네요.
select related를 사용한 조회는 애플리케이션 개발에서 많이 사용하는데요.
다음에 특징이 있습니다.
쿼리 수는 감소하지만 결과 데이터셋의 크기가 커질 수 있습니다 조인을 통해 두 테이블 간의
가능한 조합을 만들어내고요 커진 데이터셋 크기로 인해 네트워크를 통한 데이터 전송량의
증가로 이어집니다
또한 데이터베이스에서 조인 처리에 따른 비용도 고려해야 합니다
select_related는 두 모델이 같은 데이터베이스에 위치해야만 조인 쿼리를 수행할 수 있습니다 
prefetch_related를 사용한 조에는 다음의 특징이 있습니다
한 개의 추가 쿼리가 더 수행되고요.
조인 처리는 장고 애플리케이션 서버에서 이루어집니다.
이는 데이터베이스의 조인 처리 비용을 줄이면서 장고 애플리케이션 서버의 부하를 증가시킵니다. 
즉 부하가 데이터베이스와 장고 간에 분산되는 거죠.
데이터베이스는 서버 확장이 보수적인 반면 애플리케이션 서버는 스케일아웃이 상대적으로 자유롭기 때문에 부하 분산 효과가 더 큽니다.
스케일아웃은 운영 서버 대수를 늘리는 것을 말합니다.
그리고 네트워크를 통한 데이터 전송량을 감소시키고요.
별도의 쿼리를 통해 수행되기 때문에 서로 다른 종류의 데이터베이스 간에도 적용할 수 있습니다. 
이는 더 유연한 데이터베이스 활용을 가능하게 합니다.
모든 관계 필드는 명시적으로 즉시 로딩을 지정하지 않으면 게으르게 지연 로딩됩니다.
포스팅 목록에서 포스팅별로 태그 목록을 출력하면 각 포스팅마다 관련 태그 조회 쿼리가 수행되어 M++ 문제가 발생합니다.
태그 세트 필드는 many-to-many 필드이기에 select related에는 사용할 수 없고요 
프리패치 related을 통해 추가 쿼리 1개로 즉시 로딩을 수행합니다 포스트
목록 조회 시에 각 포스트에 등록된 태그 목록을 순회 돌며 태그명을 출력하도록 합니다.
웹페이지를 새로고침해보면 101개의 쿼리가 수행되었네요.
포스트와 태그는 made-to-many 관계이므로 prefetch_related을 통해
즉시 로딩을 수행할 수 있습니다.
즉시 로딩을 수행하니 포스트 조회 쿼리 1개와 태그 조회 쿼리 1개, 총 2개의 쿼리가
수행되었습니다.
포스팅 목록에서 포스팅별로 댓글 목록을 출력하면 무시무시하게 3104개의 쿼리가 수행되었고 총 응답 시간은 5.5초가 걸렸네요.
이런 상황에서는 데이터 개수가 많아지면 많아질수록 수행되는 쿼리 수와 총 응답 시간이 기하급수적으로 늘어날 것입니다.
서비스 기획을 변경하거나 즉시 로딩을 적용해 봐야겠네요.
관계는 팔로우를 타듯이 이어 지정하여 즉시 로딩할 수 있습니다.
댓글의 작성자 유저명도 같이 출력하고자 할 때 prefetch_related에 comment__set__author를 지정하여 댓글 작성자 내역을 추가 쿼리로 즉시 로딩하도록 합니다.
포스트별 댓글 목록을 별도 행으로 출력하겠습니다.
포스트 제목과 작성자명 태그는 총 3개의 컬럼으로 구성되는데요.
3개 컬럼을 합쳐 댓글 목록을 보여주기 위해 태그에 콜스판 3 속성도 지정합니다.
웹페이지를 새로 고침해보면 페이지 응답까지 수초가 걸리고, 쿼리 개수도 3,102개로 확인되네요. 
포스트 입장에서 댓글 목록과의 즉시 로딩과 댓글 내 작성자에 대한 즉시 로딩 2개를 수행할 수 있는데요 작성자 부분을 추적 처리하시고 웹페이지를 새로 고침하시면 SQL
수행 개수가 102개로 확인됩니다
작성자 조회 부분에서 쿼리 개수가 기하급수적으로 늘어났었네요
댓글 목록 즉시 로딩을 위해 prefetch_related의 CommentSet을
적용해봅니다
웹페이지를 새로 고침하시면 총 3개의 쿼리가 수행되었습니다
포스트 조회 시에 select related에 지정한 필드와의 조인 쿼리 1개와
prefetch related에 지정한 필드 2개에 대한 쿼리 2개 총 3개의 쿼리가 수행된 거죠 작성자 출력 코드에 대한 주석을 해제하고요.
다시 웹페이지 새로고침을 해보면 3,003개의 쿼리가 수행되었습니다.
무시무시하네요.
prefetchrelated에 작성자 필드로 지정해 주시면 쿼리 수가 3,003개에서 4개로 확 줄어듭니다.
마지막 4개째 쿼리는 유저 테이블에서 댓글에 유저를 조회하는 쿼리네요.




위 내용은 Django 블로그 애플리케이션에서 모델 관계를 처리하고, 데이터 로딩 및 최적화를 위한 방법을 설명한 것입니다. 핵심 포인트는 다음과 같습니다:

1. 커스텀 관리 명령 (Management Command):

load_blog_post라는 커스텀 명령어를 만들어 JSON 형식의 포스트 데이터를 로드하고, 카테고리, 포스트, 태그, 댓글 등의 데이터를 데이터베이스에 추가합니다.
명령어는 데이터를 로드하기 전에 기존 데이터를 삭제하는 옵션도 제공하며, 샘플 데이터 URL을 지정할 수 있습니다.
데이터를 로드하는 과정에서 bulk_create를 사용해 성능을 최적화하고, 카테고리와 태그를 추가할 때 데이터베이스에 없는 항목만 추가합니다.

2. 모델 데이터 추가:

카테고리와 태그는 기존 데이터를 확인한 후 없는 항목만 추가하고, 이를 bulk_create로 일괄 삽입합니다.
포스트는 외래키 필드인 유저와 카테고리를 처리할 때, 먼저 카테고리와 태그 데이터를 사전으로 저장하여 조회 성능을 향상시킵니다.
댓글은 텍스트 데이터에서 줄 단위로 나누어 생성 후 bulk_create로 일괄 삽입합니다.

3. N+1 문제:

포스트 목록을 렌더링할 때 작성자 정보를 출력하면 N+1 문제(N개 포스트마다 추가 쿼리가 실행됨)가 발생합니다.
select_related를 사용하면 작성자 정보를 즉시 로딩할 수 있어 SQL 쿼리 수를 줄일 수 있습니다.

4. 태그와 댓글의 관계 최적화:

포스트와 태그는 many-to-many 관계이므로, prefetch_related를 사용하여 태그를 즉시 로딩합니다.
포스트와 댓글 관계에서, 댓글 작성자도 출력할 때 prefetch_related로 댓글과 댓글 작성자를 즉시 로딩합니다.

5. 즉시 로딩 (Eager Loading):

select_related: 외래키(1:N 관계)로 연결된 객체를 즉시 로딩하며, 하나의 SQL 쿼리로 여러 데이터를 불러옵니다.
prefetch_related: 많은 관계(예: many-to-many나 reverse 관계)에서 여러 쿼리를 실행하지만, 네트워크와 데이터베이스 부담을 분산시켜 효율적입니다.

6. 성능 최적화:

데이터베이스의 쿼리 수를 줄이기 위해, select_related와 prefetch_related를 적절히 사용합니다.
작성자, 태그, 댓글 등 여러 필드를 즉시 로딩하여 SQL 쿼리 수를 최소화합니다.

7. 웹 페이지 렌더링 최적화:

여러 쿼리로 인해 페이지 로딩 시간이 길어지는 문제를 해결하기 위해 즉시 로딩을 사용해 쿼리 수를 최적화하고, 성능을 개선합니다.
결론:

Django에서 관계 모델을 처리할 때는 데이터의 양이 많아지면 쿼리 최적화가 중요합니다. 
select_related와 prefetch_related를 사용하여 데이터베이스 쿼리 수를 줄이는 방법이 매우 유용하며, 이를 통해 성능을 크게 개선할 수 있습니다.