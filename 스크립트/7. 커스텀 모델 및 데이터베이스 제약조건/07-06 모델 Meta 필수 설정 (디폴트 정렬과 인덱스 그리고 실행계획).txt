데이터베이스 조회에서는 정렬 기준 지정은 필수입니다 정렬 기준을 지정해야만 일관된 순서로
데이터를 조회할 수 있습니다
모델마다 많이 사용되어지는 정렬 기준이 하나씩 있습니다
코디셋을 작성할 때마다 그 정렬 기준을 매번 지정해야겠죠
그런데 매번 그 정렬 기준을 지정하지 않아도 메타의 오더링 설정을 통해 디폴트 정렬을
지정하시면 매번 정렬 기준을 지정하지 않아도 디폴트 정렬이 자동 적용됩니다
물론 코디셋에 정렬 조건이 추가되면 디폴트 정렬 옵션은 무시됩니다 실행 계획을 통해서
코디의 동작을 예측할 수 있고요 코디셋의 explain method 호출을 통해 코디 실행
계획을 조회할 수 있습니다
인덱스가 없을 때의 실행 계획을 살펴보면 풀 테이블 스캔으로 확인이 됩니다
이로 인해 코디 성능이 낮을 수 있습니다
기본 정렬과 일치하는 방향으로 인덱스를 생성하여 인덱스 스캔으로 코디 성능을 올릴 수
있습니다 인덱스가 추가된 후에 실행 계획을 확인해 보면 인덱스 스캔으로 확인이 됩니다
혹시 인덱스를 추가한 후에도 빈 테이블이라면 데이터베이스의 코디 오티마이저에서 풀 테이블
스캔으로 결정하여 동작할 수도 있습니다
데이터를 추가한 후에 실행 계획을 다시 확인해 보세요
블로그 앱의 models.py 파일에다가 태그 모델을 만들겠습니다
makemigrations 블로그 명령을 통해서 새로운 마이그레이션 파일을 생성해 주시고요
마이그레이트 명령으로 데이터베이스에 반영도 해줍니다
이어서 장고 셀을 구동하시고 태그 모델을 통해 기본 쿼리셋을 수행하시면 SELECT 쿼리에서
정렬을 수행하는 오더바이가 없음을 확인하실 수 있습니다
디폴트 정렬로써 네임 필드에 대한 오름차순 정렬을 지정하겠고요 장고 셸을 빠져나오시고
새롭게 장고 셸을 여신 다음에 태그 모드에 대한 기본 코디셋을 수행해 보시면 이렇게
디폴트 정렬이 적용된 것을 확인하실 수 있습니다
그리고 이렇게 직접 정렬을 지정해 주시면 디폴트 정렬은 무시되고 우리가 지정한
정렬로 수행이 됨을 확인하실 수 있습니다 실행 계획을 확인해 보겠습니다
태그 모드에 대한 기본 코디셋을 생성을 하고요 코디셋.explain 함수 호출을 통해서
해당 코디셋에 대한 실행 계획을 확인하실 수 있습니다 데이터베이스에서 실행 계획을 확인하는
Query는 Select Query 앞에 Explain을 붙이는 것이고요.
아래에 실행 계획이 출력되고 있습니다.
Sequence Scan이라는 것은 테이블 풀 스캔을 의미하고, 지정 테이블 전체를 다
스캔한 뒤에 정렬을 수행함을 의미합니다.
이번에는 기본 정렬 방향과 일치하는 인덱스를 생성하여 QuerySet이 인덱스 스캔으로
동작하도록 구성을 해보겠습니다.
indexes라는 설정을 추가하겠고요 모델의 인덱스를 통해서 인덱스를 추가하실 수 있습니다
인덱스 대상 필드는 네임 필드에 대한 오름차순 인덱스를 생성하겠습니다 장고 셀을
빠져나가시고요
make-migrations-blog 명령을 통해 migration 파일을 생성해 주시고
migrate-blog 명령을 통해 데이터베이스에 이렇게 적용도 해줍니다
장고 셀을 새롭게 구동해 주시고 태그 모델에 대한 기본 코디셋을 생성하신 다음 실행 계획을
출력해 보겠습니다
현재 블록 언더바 테이블에 대한 인덱스가 생성이 되어 있는 상황임에도 이렇게 시퀀스
스캔으로 동작을 하고 있겠고요 데이터베이스 패널에서 새로고침을 하신 뒤에 블록 언더바
태그에 대해서 모디파이 테이블을 선택하시고 이 테이블의 인덱스 내역에 보시면 이렇게
인덱스가 잘 생성이 되어 있음을 확인하실 수 있습니다
현재 데이터베이스에 저장된 태그가 하나도 없는데요
약 만 개의 태그를 생성을 해 보겠습니다
아직 저장되지 않은 태그 모델 인스턴스의 리스트를 생성하고 bulk create를 통해서
한번에 생성을 해 주겠습니다
이렇게 생성이 되었고요
태그 모델에 대한 기본 코디셋을 생성하고 다시 실행 계획을 확인해 보시면 아직 시퀀스
스캔으로 동작을 하는데요
새로운 태그 만 개를 저장하고 나서 그 즉시 실행 계획을 확인했을 때는 시퀀스 스캔으로
확인이 되었는데요
약 몇 분의 시간이 흐른 뒤에 다시 실행 계획을 확인해 보시면 이렇게 인덱스 스캔으로
동작함을 확인하실 수 있습니다