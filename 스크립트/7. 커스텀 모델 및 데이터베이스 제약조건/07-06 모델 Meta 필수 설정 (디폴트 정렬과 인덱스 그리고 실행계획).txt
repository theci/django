데이터베이스 조회에서는 정렬 기준 지정은 필수입니다 정렬 기준을 지정해야만 일관된 순서로
데이터를 조회할 수 있습니다
모델마다 많이 사용되어지는 정렬 기준이 하나씩 있습니다
쿼리셋을 작성할 때마다 그 정렬 기준을 매번 지정해야겠죠
그런데 매번 그 정렬 기준을 지정하지 않아도 메타의 오더링 설정을 통해 디폴트 정렬을
지정하시면 매번 정렬 기준을 지정하지 않아도 디폴트 정렬이 자동 적용됩니다
물론 쿼리셋에 정렬 조건이 추가되면 디폴트 정렬 옵션은 무시됩니다 실행 계획을 통해서
쿼리의 동작을 예측할 수 있고요 쿼리셋의 explain method 호출을 통해 쿼리 실행
계획을 조회할 수 있습니다
인덱스가 없을 때의 실행 계획을 살펴보면 풀 테이블 스캔으로 확인이 됩니다
이로 인해 쿼리 성능이 낮을 수 있습니다
기본 정렬과 일치하는 방향으로 인덱스를 생성하여 인덱스 스캔으로 쿼리 성능을 올릴 수
있습니다 인덱스가 추가된 후에 실행 계획을 확인해 보면 인덱스 스캔으로 확인이 됩니다
혹시 인덱스를 추가한 후에도 빈 테이블이라면 데이터베이스의 쿼리 오티마이저에서 풀 테이블
스캔으로 결정하여 동작할 수도 있습니다
데이터를 추가한 후에 실행 계획을 다시 확인해 보세요
블로그 앱의 models.py 파일에다가 태그 모델을 만들겠습니다
makemigrations 블로그 명령을 통해서 새로운 마이그레이션 파일을 생성해 주시고요
마이그레이트 명령으로 데이터베이스에 반영도 해줍니다
이어서 장고 셀을 구동하시고 태그 모델을 통해 기본 쿼리셋을 수행하시면 SELECT 쿼리에서
정렬을 수행하는 오더바이가 없음을 확인하실 수 있습니다
디폴트 정렬로써 네임 필드에 대한 오름차순 정렬을 지정하겠고요 장고 셸을 빠져나오시고
새롭게 장고 셸을 여신 다음에 태그 모드에 대한 기본 쿼리셋을 수행해 보시면 이렇게
디폴트 정렬이 적용된 것을 확인하실 수 있습니다
그리고 이렇게 직접 정렬을 지정해 주시면 디폴트 정렬은 무시되고 우리가 지정한
정렬로 수행이 됨을 확인하실 수 있습니다 실행 계획을 확인해 보겠습니다
태그 모드에 대한 기본 쿼리셋을 생성을 하고요 쿼리셋.explain 함수 호출을 통해서
해당 쿼리셋에 대한 실행 계획을 확인하실 수 있습니다 데이터베이스에서 실행 계획을 확인하는
Query는 Select Query 앞에 Explain을 붙이는 것이고요.
아래에 실행 계획이 출력되고 있습니다.
Sequence Scan이라는 것은 테이블 풀 스캔을 의미하고, 지정 테이블 전체를 다
스캔한 뒤에 정렬을 수행함을 의미합니다.
이번에는 기본 정렬 방향과 일치하는 인덱스를 생성하여 QuerySet이 인덱스 스캔으로
동작하도록 구성을 해보겠습니다.
indexes라는 설정을 추가하겠고요 모델의 인덱스를 통해서 인덱스를 추가하실 수 있습니다
인덱스 대상 필드는 네임 필드에 대한 오름차순 인덱스를 생성하겠습니다 장고 셀을 빠져나가시고요
make-migrations-blog 명령을 통해 migration 파일을 생성해 주시고
migrate-blog 명령을 통해 데이터베이스에 이렇게 적용도 해줍니다
장고 셀을 새롭게 구동해 주시고 태그 모델에 대한 기본 쿼리셋을 생성하신 다음 실행 계획을 출력해 보겠습니다
현재 블록 언더바 테이블에 대한 인덱스가 생성이 되어 있는 상황임에도 이렇게 시퀀스 스캔으로 동작을 하고 있겠고요 데이터베이스 패널에서 새로고침을 하신 뒤에 블록 언더바
태그에 대해서 모디파이 테이블을 선택하시고 이 테이블의 인덱스 내역에 보시면 이렇게 인덱스가 잘 생성이 되어 있음을 확인하실 수 있습니다
현재 데이터베이스에 저장된 태그가 하나도 없는데요
약 만 개의 태그를 생성을 해 보겠습니다
아직 저장되지 않은 태그 모델 인스턴스의 리스트를 생성하고 bulk create를 통해서 한번에 생성을 해 주겠습니다
이렇게 생성이 되었고요
태그 모델에 대한 기본 쿼리셋을 생성하고 다시 실행 계획을 확인해 보시면 아직 시퀀스 스캔으로 동작을 하는데요
새로운 태그 만 개를 저장하고 나서 그 즉시 실행 계획을 확인했을 때는 시퀀스 스캔으로 확인이 되었는데요
약 몇 분의 시간이 흐른 뒤에 다시 실행 계획을 확인해 보시면 이렇게 인덱스 스캔으로 동작함을 확인하실 수 있습니다



이번 강의에서는 Django 모델에서의 기본 정렬 설정과 데이터베이스 성능 최적화에 대해 다뤘습니다. 주요 내용은 다음과 같습니다:

1. 모델의 기본 정렬 (Ordering) 설정
메타 옵션 ordering: 모델에서 기본 정렬 기준을 설정할 수 있습니다. 이를 통해 매번 쿼리셋에 정렬 조건을 지정하지 않아도 자동으로 지정된 정렬 방식이 적용됩니다.
예를 들어, ordering = ['name']으로 설정하면, name 필드를 기준으로 기본 오름차순 정렬이 적용됩니다.
이 기본 정렬은 쿼리셋에서 다른 정렬 조건을 지정하면 무시됩니다.
쿼리셋에서 실행 계획을 확인하려면 queryset.explain() 메서드를 사용할 수 있습니다. 이를 통해 쿼리 실행 계획을 보고, 테이블 스캔 방식(Sequence Scan) 등을 확인할 수 있습니다.
2. 쿼리 성능 최적화: 인덱스
인덱스: 기본 정렬 기준에 맞는 인덱스를 생성하여 쿼리 성능을 최적화할 수 있습니다. 인덱스를 생성하면, 데이터베이스가 풀 테이블 스캔 대신 인덱스 스캔을 사용하여 데이터를 효율적으로 조회할 수 있습니다.
인덱스 생성: 모델의 indexes 옵션을 사용해 특정 필드에 인덱스를 추가할 수 있습니다. 예를 들어, name 필드에 대해 오름차순 인덱스를 생성할 수 있습니다.
3. 실습 예시
기본 정렬 설정: ordering = ['name']을 모델 메타에 설정한 후, Tag 모델에 대해 기본 쿼리셋을 실행하면 name 필드 기준으로 자동 정렬됩니다. 쿼리셋에 별도의 정렬 조건을 추가하면 기본 정렬은 무시됩니다.
실행 계획 확인: queryset.explain()을 호출하여 실행 계획을 확인한 결과, Sequence Scan(풀 테이블 스캔)을 통해 테이블 전체를 스캔하며 정렬을 수행한다고 나옵니다.
인덱스 추가 후 성능 최적화: name 필드에 대해 인덱스를 생성하고, 실행 계획을 다시 확인했을 때 Index Scan으로 동작하는 것을 확인할 수 있습니다. 데이터베이스에서 인덱스가 제대로 생성되었는지 확인하려면 데이터베이스 테이블의 인덱스를 조회하면 됩니다.
4. 대량 데이터 삽입 후 성능 변화
태그 모델에 약 10,000개의 데이터를 삽입한 후, 다시 실행 계획을 확인한 결과, 인덱스 스캔으로 동작하는 것을 확인할 수 있었습니다.
처음에는 데이터가 없기 때문에 Sequence Scan이 사용되지만, 데이터가 추가된 후 몇 분이 지나면 인덱스 스캔으로 최적화됩니다. 이는 데이터베이스의 쿼리 옵티마이저가 시간이 지나면서 인덱스를 활용하는 방법을 선택했기 때문입니다.
5. 정리
모델에서 기본 정렬을 설정하면 쿼리셋에 별도로 정렬을 지정하지 않아도 자동으로 적용됩니다.
인덱스를 추가하면 쿼리 성능을 최적화할 수 있으며, 특히 데이터 양이 많을수록 인덱스 스캔이 더 효과적입니다.
실행 계획을 확인하여 성능을 평가하고, 적절한 인덱스를 추가하는 방식으로 최적화를 수행할 수 있습니다.
이 강의에서는 Django에서 모델의 기본 정렬 설정과 데이터베이스 성능 최적화 방법을 배우고, 실제 데이터를 다루며 성능 차이를 실습을 통해 확인할 수 있었습니다.




