블로그 서비스를 관계 예시로써 만들어봤습니다
이는 하나의 예시일 뿐, 서비스에 따라 다른 설계가 나올 수 있습니다 오른쪽에서 ERD로
블로그 서비스의 데이터베이스 테이블 다이어그램을 그려봤습니다
ERD는 개체 관계 다이어그램으로써 데이터베이스 테이블을 설계하는 하나의 방법입니다
ERD에서 accounts 장고 앱의 유저 모델이 있구요
한 명의 유저는 하나의 프로필을 가지도록 설계할 것이기에 1대 1 관계입니다
넷플릭스 서비스에서처럼 하나의 아이디로 여러 프로필을 가지도록 설계한다면 1대 N의 관계가
될 것입니다 그리고 한 명의 유저는 여러 포스팅이나 여러 댓글을 쓸 수 있을 것이기에 1
대 n의 관계이고요 또 하나의 포스팅에는 여러 댓글을 쓸 수 있을 것이기에 이 역시 1 대
n의 관계입니다
그리고 하나의 포스팅에는 여러 태그를 남길 수 있고 하나의 태그는 여러 포스팅에 속할 수
있기에 포스팅과 태그는 m 대 n, 즉 many to many 관계가 될 것이고요
Posting과 태그의 관계를 저장하는 테이블로 BlogPostTagSet 테이블을
설계했습니다.
accounts 앱에 User 모델을 설계했는데요.
User 모델은 우리가 앞서 정의를 했었죠.
Custom User 모델 등록을 위해 Settings 파일에 AUTH_USER_MODEL
설정도 했었습니다.
AbstractUser 추상화 모델 클래스에 이미 username 필드, password
필드 등이 이미 정의가 되어 있기에 추가로 필요한 필드는 없습니다.
유저 모델과 1대1 관계에 있는 프로필 모델을 정의하겠습니다.
Models의 1-to-1 필드를 통해 1대1 관계를 정의하고요.
필드명을 사용자로 쓰면 데이터베이스 외래기 필드명은 디폴트로 user__id가 됩니다.
유저 레코드가 삭제되었을 때의 정책은 관련 프로필 레코드로 같이 삭제되도록 cascades를
지정합니다. 주소 필드는 문자열 필드이기에 모델스의 캐릭터 필드를 지정하고요 주소를 옵션
필드로 처리하기 위해 블랭크 참 설정도 적용합니다
블로그 앱의 퍼스트 모델에는 이미 작성자 author 필드가 추가되어 있습니다
관계 필드의 첫 번째 인자로 대상 모델을 지정할 때 모델 클래스를 직접 지정하실 수도
있지만 앱 이름.
모델명, 문자열로 지정하실 수도 있습니다
settings.py 내 authUserModel 설정 값은 문자열로
account.user로 설정했었죠
그러니 Accounts 앱의 User 모델과 관계를 맺게 됩니다
제목 필드도 이미 추가가 되어 있네요
태그모델도 이미 정의했었습니다
태그모델을 직접 정의한 것은 예시일 뿐 실서비스에서는 Django Taggit 라이브러리를 추천합니다
퍼스트 모델의 태그모델과의 many-to-many 관계를 정의하기 위해 models에
many-to-many 필드를 추가합니다
모델스파이 소스파일 내에서 퍼스트 모델 클래스가 태그모델 클래스보다 위에 있으므로 태그모델
클래스를 직접적으로 지정할 수 없습니다
문자열로 태그 모델을 지정하여 관계를 맺어주세요.
관계 지정에서 앱 이름 없이 모델명만 문자열로 문자열로 지정하면 같은 앱 내에서 지정 모델과 관계를
맺습니다. 모든 모델 필드에서 블랭크 설정은 디폴트로 거짓입니다.
이 설정이 Many-to-Many 필드에 적용되면 유효성 검사에서 포스팅에 1개 이상의
태그를 요구하게 됩니다.
0개 이상의 태그 지정을 위해 블랭크 설정은 참으로 지정합니다.
코멘트 모델에도 유저 모델과 1대 N 관계 지정을 위해 외래키 필드를 추가합니다.
대댓글을 지원하려면 현재 댓글의 부모 댓글이 누구인지 외래키로 남겨야 합니다.
문자열로 셀프를 지정하면 현재 모델과 관계를 맺을 수 있습니다.
최상위 댓글은 부모가 없으므로 Null 설정으로 참을 지정하여 Null이 가능한 필드임을
설정하고 Blank 참을 설정하여 입력 폼에서 부모가 입력되지 않을 수도 있음을
설정합니다.
대댓글과 같은 계층 구조를 처리하실 때에는 장고 라이브러리를 활용하시면 편리합니다.
makemigrations 명령으로 모델 변경 내역에 대한 마이그레이션 파일을
생성합니다.
외래키로써 유저 모델에 대한 필수 필드가 추가되었었죠.
일회성 디폴트 값을 입력하기 위해 1번 메뉴를 선택하고 디폴트 외래키 값으로 이를 지정해
주겠습니다. 블로그 앱의 마이그레이션에서 기본키가 1인 유저가 없다면 생성하는
마이그레이션이 있었죠.
데이터베이스 데이터는 언제든 삭제될 수 있는 것이므로 기본키가 1인 유저가 없는 상황이
발생할 수도 있습니다
해당 마이그레이션 파일을 수정해서 기본키가 1인 유저가 없을 경우에 생성해주는 어플레이션을
추가하는 것도 좋습니다
블로그 앱에 대해서도 makemigrations 명령을 수행하고 migrate 명령으로
생성된 마이그레이션 파일을 데이터베이스에 적용해 주세요.
어드민 페이지를 열어 추가한 관계 필드를 통해 데이터를 저장해 보겠습니다.
Accounts의 admin.py 파일에서 프로필 모델을 admin에 등록합니다.
그러면 어드민 페이지에 프로필 모델이 뜨고요.
이제 새로운 프로필을 생성해 보겠습니다.
방금 새로운 프로필을 생성했고요 프로필 생성 시에 1대1 관계로써 유저를 선택할 수 있도록
셀렉트박스 UI가 장고 폼에 의해서 자동 생성되었습니다 유저 하나를 선택하고 저장을 누르면
선택된 유저로 메레키 관계가 데이터베이스에 저장됩니다 원투원 필드를 통해 1대1 관계를
명시했기에 이미 맵핑된 유저에 대해서는 다른 프로필이 관계를 맺지 못합니다.
블로그 앱에서는 코멘트 모델과 태그 모델을 어드민에 등록해 주세요.
이제 어드민을 통해 코멘트 모델과 태그 모델을 관리할 수 있습니다.
새 코멘트 생성에서 작성자 필드와 포스트 필드, 페어런트 필드는 1대 n 관계의
외래키이므로 여러 코멘트에 걸쳐 같은 유저와 같은 포스트, 같은 부모 코멘트를 선택할 수
있습니다 태그 모델에서는 태그명이 출력되지 않고 모델 클래스의 기본 문자열 표현으로
보여지고 있네요
태그 클래스의 under by str 메서드를 재정리해서 태그명을 반환하도록
하겠습니다. 웹페이지를 새로 고침하니 태그 목록에 태그명이 보여집니다
포스팅 수정 폼에서 태그 생성은 안되고요 데이터베이스에 등록된 태그 중에 여러 개를
선택하실 수 있습니다
여러 태그 문자열을 입력받아 없는 태그를 자동 생성해 주려면 별도의 장고 폼 구현이
필요합니다 현재 등록된 태그가 하나밖에 없네요 태그를 추가해 주겠습니다
파이썬과 웹 태그를 추가하고 나서 포스팅 수정 폼을 새로 고침합니다.
태그를 여러 선택하고 저장하실 수 있겠고요.
수정 폼에서 카테고리 명이 보여지지 않고 모델 클래스의 기본 문자열 표현으로 보여지고
있네요. 카테고리 모델 클래스에도 언덕 언덕 str 메서드를 재정의합니다.