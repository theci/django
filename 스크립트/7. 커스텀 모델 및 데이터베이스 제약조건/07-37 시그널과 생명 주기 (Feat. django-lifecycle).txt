안녕하세요. 이번 시간에는 생성, 수정, 삭제 시그널에 대해서 살펴보고 장고 라이프사이클
라이프사이클를 통해 가독성과 편의성을 향상시켜 보겠습니다.
시그널은 장고의 이벤트 시스템입니다.
시그널을 등록하고 그 시그널이 발생했을 때 호출되는 함수를 연결해 두면 해당 시그널이
발생되면 그 즉시 등록해 둔 함수가 호출됩니다.
하나의 시그널에 여러 함수를 연결할 수도 있습니다.
장고 내부에서 다양한 시그널이 사용되는데요.
장고 기본 앱인 Auth 앱에서는 유저 로그인과 로그아웃, 그리고 로그인 실패에 대한
시그널을 지원합니다.
그리고 장고 모델에서는 각 모델 인스턴스에서 저장 전과 후, 그리고 삭제 전과 후, 그리고
many-to-many 관계 변경에 대한 시그널을 지원합니다.
Auth 앱에서 구현되어 있는 유저 로그드인 시그널의 내부 구현을 살펴보면요.
새로운 시그널을 생성하고, 유저가 로그인에 성공하면 수행할 함수를 구현하고요.
이 함수는 유저의 최종 로그인 시각을 기록합니다.
유저 로그인 시그널과 방금 생성한 함수를 서로 연결합니다.
Dispatch UID는 각 연결에 대한 식별자로서 이 식별자를 지정하면 그 시그널과
함수를 연결하는 이 connect 함수가 여러 번 호출되어도 연결은 단 1회만 이루어져 함수의
중복 호출을 미연해 방지합니다.
이제 유저가 로그인에 성공했을 때 user.loggedIn.send 메서드 호출을 통해
시그널을 발생시킵니다.
그러면 시그널과 연결된 함수들이 즉시 동기적으로 호출됩니다.
프리 세이브(pre_save) 시그널 예시로서 포스트 모델 인스턴스를 저장하기 전에 title 필드로부터
slug 필드 값을 생성합니다.
이전 실습에서는 save 메서드를 재정의해서 저장 전에 slugify 메서드를
호출했었죠. 포스트 세이브 시그널을 통해서도 동일하게 처리를 하실 수 있습니다.
포스트 모델 클래스에 대해 프리 세이브 시그널과 연결을 맺었고요.
프리 세이브 시그널에서는 키워드 인수 인스턴스로 모델 인스턴스를 전달받습니다.
그 외 키워드 인자는 신경 쓰지 않을 것이기에 키워드 아규먼트 형태로 받았고요.
세이브 메서드를 재정의하는 방식은 모델 내에 정의되므로 명시적이고 유지 보수성이 높습니다.
그에 반해 시그널을 활용하는 방식은 여러 모델이나 앱에 걸쳐 사용할 수 있어서 유연성이
높지만 추적하기 어려워 상대적으로 디버깅과 유지보수가 복잡할 수 있습니다.
참고로 QuerySet.BulkCreate, QuerySet.BulkUpdate 메서드는
모델의 save 메서드를 호출하지 않기 때문에 pre-save, post-save 시그널을
발생시키지 않습니다.
코디셋의 많은 인스턴스에서 시그널을 발생시키는 과정이 오버헤드가 될 수 있기 때문입니다.
블로그 앱의 Post 모델 클래스를 열어주시고요.
Slushify 메서드 구현이 있고, save 메서드를 재정리해서 저장 전에
Slushify 메서드를 호출했었습니다.
save 메서드 재정의 코드를 제거하시고요.
프리 세이브 시그널을 통해 slugify 메서드를 호출도록 하겠습니다.
인스턴스 인자는 PostModel 인스턴스일 것이고요.
slugify 함수를 호출도록 합니다.
그럼 저장 전에 이 함수가 호출되어 title 필드로부터 slug 필드 값을 채워 넣을
것이고요. 현재 slugify 함수는 slug 값이 있을 경우에는 slug 값을 변경하지
않으므로 기존 first instance에 대해서 save 메서드를 호출하는 것만으로는
slug 값 변경이 일어나진 않지만 이렇게 출력을 통해 receive 함수 호출을 확인하실
수 있습니다 출력 코드는 호출 확인을 위해 잠시 추가했을 뿐 실 서비스에서는 Django의
로고 시스템을 활용하거나 제거하시는 것이 좋습니다
PostSignal의 예로써 새로운 유저가 생성되면 관련 프로필을 자동으로 생성해주는
예시입니다.
UserModel 클래스에 대해 PostSaveSignal과 연결을 맺었고요.
PostSaveSignal에서는 키워드 인자로 인스턴스와 생성 여부를 의미하는
Created 인자가 제공됩니다.
생성 시에는 참 값을, 수정 시에는 거짓 값으로 전달됩니다.
생성 시에만 그 유저에 대한 프로필을 구성토록 이렇게 구성하실 수 있습니다.
유저 모델 인스턴스가 생성된 이후의 시점을 잡기 위해 포스트 세이브 시그널과 연결하고요.
Created 인자를 받아서 생성 여부를 확인합니다.
생성 시에만 유저의 프로필을 생성합니다.
쉘에서는 호출 여부를 손쉽게 확인하기 위해 출력 코드도 넣었습니다.
새로운 유저 인스턴스를 생성하고 저장해봅니다
그런데 어떤 속성이 없다고 하네요
소스코드에서 create인데 오타입니다 수정하시고 쉘를 재가동 후에 다시 다른
유저명의 유저 인스턴스를 생성하시면 프로필까지 한 번에 생성이 됩니다
프로필이 삭제되면 관련 사진을 자동으로 삭제하는 예시입니다.
잔고에서 모델스의 이미지 필드를 통해 사진 파일을 손쉽게 저장할 수 있습니다.
하지만 관련 모델 인스턴스가 삭제될 때마다 파일을 자동으로 삭제하진 않습니다.
왜냐하면 하나의 파일이 여러 모델 인스턴스에서 공유될 수 있기 때문이에요
그리고 파일 삭제는 시간이 많이 소모되는 작업이기에 대량의 데이터를 삭제할 때 파일 삭제
작업으로 인한 성능 저하가 발생할 수도 있기 때문입니다
모델에 의해 참조되지 않는 파일은 주기적으로 찾아서 삭제하는 삭제하는 방법이 권장됩니다 본
예시에서는 이미지 필드에 연결된 파일들은 한 개의 모델 인스턴스에만 사용되고 있다고
가정하고 모델 인스턴스가 삭제되면 그 파일을 자동 삭제토록 포스트 딜리트 시그널을 이렇게
활용을 해 볼 수 있겠습니다.
코디셋의 delete 메서드는 모델의 delete 메서드를 호출하지 않습니다
하지만 pre-delete signal과 post-delete signal이 연결되었다면
코디셋의 delete 메서드 호출 시에 pre-delete signal과
post-delete signal을 발생시키고 삭제되는 모든 모델 인스턴스에 대해서
receive 함수를 호출합니다
모델 인스턴스 한 개를 삭제할 때에는 서버의 부하가 적지만 한 번에 많은 수의 모델
인스턴스를 삭제할 때에는 그 수만큼 리시버 함수가 호출되고 파일 삭제를 시도하게 되니
서버의 부하가 클 수도 있으니 조심해서 사용해 주세요
게다가 로컬 파일 시스템이 아니라 아마존 웹 서비스의 S3와 같은 클라우드 스토리지를
연동했다면 삭제 시간이 더욱 오래 걸릴 수 있습니다
프로필 모델에 포토 필드를 추가하고요 업로드된 파일이 저장되는 경로는 기본 저장
경로 밑에 프로필 폴더 밑에 포토 폴더 밑에 저장되도록 하고요 기본 저장 경로는 세팅의
미디어 루트 설정을 따르는데 디폴트로 프로젝트 루트 경로가 됩니다
이 설정에 대해서는 뒤에서 자세히 다루겠습니다 포터 필드를 옵션 필드로 지정하기 위해
blank 참 설정도 넣어줍니다.
모델스의 이미지 필드 내부 구현에서 Pillow 라이브러리를 사용하기 때문에
MakeMigrations를 수행하기 전에 필이 PillowLibrary가 설치되어 있어야
합니다. 설치되어 있지 않으면 MakeMigrations 명령이 실패합니다.
우리는 먼저 설치했었죠.
MakeMigrations Account 명령과 MigrateAccount 명령으로
마이그레이션 파일을 생성하고 데이터베이스에 반영도 해줍니다.
모델스의 이미지 필드 관련 세팅스로써 미디어 URL 설정과 미디어 루트 설정이 있습니다.
대개 이렇게 값을 설정하는데요.
아직 이 설정을 하지 않고 뒤에서 따로 다루겠습니다.
미디어 루트 설정을 하지 않으면 디폴트로 업로드된 파일이 프로젝트 루트 경로를 기준으로
저장됩니다.
프로필의 admin 페이지를 통해서 수정 폼을 여시면 이렇게 이미지를 업로드할 수 있는
폼이 뜹니다.
이미지를 하나 지정하시고 저장해주세요.
그럼 이미지 파일이 저장되었고요.
수정 폼에서 파일 링크는 있지만 클릭해도 아직 파일을 브라우저를 통해서 확인할 수는
없습니다. 뒤에서 살펴볼 미디어 관련 설정이 아직 덜 되었기 때문이고요.
그렇지만 로컬 파일 시스템에 파일은 저장되었고 데이터베이스 포토 컬럼에도 상대 경로
문자열은 저장되어 있습니다.
포토 필드 설정의 upload to 인자로 프로필 슬러시 사진 문자열을 지정했으니 프로젝트
루트 경로 밑에, 프로필 폴더 밑에, 포토 폴더 밑에 업로드된 파일이 저장됩니다.
저는 방금 기본 키가 5인 프로필의 사진을 업로드 했었거든요?
장고 쉘을 통해 기본 키가 5인 프로필 모델 인스턴스의 포토 필드를 조회해 봅니다.
이렇게 사진 파일 경로가 보이네요
해당 모델 인스턴스를 삭제하면 데이터베이스에서 삭제는 되었지만 사진 파일은 삭제되지
않았어요 다른 프로필 인스턴스에 사진을 업로드 해주시고요
그럼 프로필 밑에 포토 폴더 경로에 새로운 파일명으로 이미지가 저장됩니다 분명 같은
파일명의 이미지를 두 번 올렸는데요.
파일이 덮어쓰기가 되지 않고 새로운 파일명으로 저장되었죠.
Django에서는 같은 이름의 파일이 업로드되더라도 덮어쓰기 하지 않고 파일명 뒤에 더미
문자를 붙여 새로운 파일명으로 저장합니다.
프로필 모델에 포스트 딜리트 시그널을 연결하고 리시버가 호출될 때 포토필드의 파일을
삭제하도록 합니다.
Delete 메서드 구현을 보시면 save 키워드 인자가 지원되고 디폴트 값이 참입니다.
한 단계 더 들어가 보시죠.
delete 메서드가 호출되면 스토리지에서 파일을 삭제하고 save 인자 값이 참이면 모델
인스턴스의 save 메서드를 호출해서 저장을 시도하네요.
우리는 모델 인스턴스가 삭제될 때 파일만 삭제해야 합니다.
삭제 과정에서 다시 저장을 시도하지 않도록 save 키워드 인자를 pd 거짓으로
지정해주세요. 장고 셀을 다시 구동하시고 프로필 모델의 코디셋을 통해 삭제하시면 관련
이미지 파일도 같이 삭제됨을 확인하실 수 있습니다.
모델 인스턴스의 필드 값 변경을 탐지하는 예시를 살펴보겠습니다.
첫 번째로 컨텐츠 필드 값이 변경되었을 때에만 updated at 필드 값을 갱신하려고
하고요. 두 번째로 아티클이 발행 상태로 변경되었을 때에만 저자에게 이메일을 보내려고
합니다. 그럼 이렇게 모델 인스턴스 내에서 컨텐츠 필드와 스테이터스, 발행 상태 필드의
초기 값을 별도 변수로 저장했다가 세이프 호출 시에 그 변수 값과 비교해서 변경 여부를
탐지할 수 있습니다.
단순히 모델 인스턴스를 생성했을 때에는 아무런 출력이 없었으나 컨텐츠 필드 값을 변경하고
저장하면 컨텐츠 변경 메시지가 출력되고요.
스테이터스 발행 상태를 발행으로 변경하면 저자에게 이메일을 보낸다는 메시지가 출력됩니다.
코드가 아주 복잡하죠?
동작하는 코드이지만 유지보수성이 무척 낮습니다.
pre-save, post-save signal은 save 재정의 코드를 별도 함수로
정의할 수 있도록 도와줄 뿐 이 상황을 해결해 주진 않습니다.
구원자로 django-lifecycle 라이브러리가 있습니다.
django-lifecycle 사용을 위해 모델은 lifecycle-model 클래스나
lifecycle-model-mixing 클래스를 상속받아야만 합니다.
모델의 커스텀 메서드를 구현하고 hook 조건을 지정하겠습니다.
조회된 인스턴스가 저장되기 전에 content 필드 값이 변경되었을 때에만 이 메서드가
자동 호출도록 조건을 지정하고요.
조회된 인스턴스가 저장되기 전에 status 필드 값이 draft에서 published,
발행 상태로 변경되었을 때에만 호출되도록 조건을 지정합니다.
그럼 앞선 예시와 동일하게 동작하지만 훨씬 관리성이 좋고 가독성이 높은 코드가 되었죠.
실습은 블로그의 포스트 모델에서 진행하겠습니다.
포스트 모델에도 StatusField와 ContentField가 있습니다.
먼저, Django Lifecycle 라이브러리를 설치합니다.
최신 버전이 1.1.2 버전이네요.
ContentField 값이 변경되었을 때 호출될
OnChangedContentMethod를 정의합니다.
Method 이름은 다른 필드명이나 메서드명과 겹치지 않는 이름을 사용하시면 됩니다.
Hook 장식자를 적용하시고요
저장 전에 호출되도록 BeforeUpdate도 적용하고요 대상 필드명은 Content이고
대상 필드가 변경되었을 때 호출되도록 합니다
Content 필드가 변경되었을 때에만 UpdatedApp 필드를 변경하려고 하는데요
상속받은 TimeStamped 모델 클래스의 UpdatedApp 필드에는 AutoNow
설정이 되어 있죠
그래서 저장이 될 때마다 자동으로 현재 시각으로 지정이 됩니다
TimeStamped 모델 클래스 상속을 제거하고 모델 클래스를 상속받도록 하고요.
Hook 사용을 위해 Lifecycle 모델 Mixing 클래스도 같이 상속받습니다.
모델 클래스 상속 없이 Lifecycle 모델 클래스만 상속받으셔도 됩니다.
Created At, Updated At 필드를 Post 모델에 직접 정의하고요.
Updated At 필드의 Auto Now 설정을 Auto Now Add 설정으로 변경하여
최초 저장 시에만 현재 시각이 자동 지정되도록 합니다.
onChangedContentMethod 호출 시에 updatedAppField의 현재
시각을 저장하고요.
status 필드 값이 초안에서 발행 상태로 변경되면서 저장되었을 때 호출될 함수
onPublishedMethod를 정의합니다.
저장 이후에 호출할 것이기에 afterUpdate를 지정하고요.
대상 필드는 status, 이전 상태 값이 draft, 이후 상태 값은 published로
지정합니다. 이메일 발송은 하지 않고 이메일을 보낼 것이다는 출력만 하겠습니다.
업데이트된 필드의 Auto Now Add 설정은 데이터베이스 스키마 변환은 없지만 모델
필드 변경이기에 마이그레이션 과정이 필요합니다.
Make Migrations Blog 명령 후에 SQL Migrate Blog 0023
명령으로 생성된 마이그레이션 파일의 SQL 수행 내역을 보시면 수행되는 SQL은 없습니다.
Migrate Blog 명령으로 적용해 주시고요.
장고실에서 블로그 앱에 포스트 모델을 임포트해 주시고 포스트 모델 인스턴스를 하나 생성하신
후에 업데이트된 앱 필드 값을 확인하시고 save 메서드를 호출하여 저장 후에도 업데이트된
앱 필드 값이 변화가 없음을 확인합니다
이번에는 컨텐츠 필드 값을 저장하시고 나서 저장하시면 컨텐츠 필드가 변경되었으니 업데이트된
앱을 갱신합니다 라는 메시지가 출력되고요 업데이트된 앱 필드 값도 변경되었음이 확인됩니다
Status 값은 D로써 초안 상태입니다.
상태 값을 발행으로 변경하시고 저장하시면 저장 후에 저자에게 이메일을 보냅니다.
메시지가 출력됨을 확인하실 수 있습니다.
Django Lifecycle의 훅 구현에서는 시그널을 사용하진 않았고요.
모델의 save 메서드와 delete 메서드를 오버라이딩해서 구현되었습니다.
그래서 시그널과 호출되는 시점이 좀 다릅니다.
모델 인스턴스의 save 메서드를 호출할 때에는 프리 세이브 시그널이 가장 먼저 발생하고,
장고 라이프 사이클 훅에서는 생성과 수정으로 분개해서 훅을 처리하고, save 메서드를
수행합니다. 그 후에 생성, 수정을 붕괴해서 또 hook이 처리되고요.
최종적으로 firstSaveSignal이 발생합니다.
모델 인스턴스에 delete 메서드를 호출할 때에는 preDeleteSignal이 가장
먼저 발생하고, beforeDeleteHook이 발생하고, 그 후에 delete 메서드
수행 후에 afterDeleteHook 그리고 firstDeleteSignal이
발생합니다.
코디셋의 delete 메서드에서는 해당 모델의 pre-delete, post-delete
시그널이 등록되어 있다면 리시버 함수가 각 모델 인스턴스마다 호출이 되죠.
하지만 hook 구현이 모델의 delete 메서드를 재정의해서 구현되었기 때문에 코디셋의
delete 메서드 호출에서는 Hook이 호출되지 않습니다.
각 호출 순서에 대해서 잘 기억하시고요.
Django Lifecycle 라이브러리에 편리한 기능이 많으니 꼭 살펴보세요.