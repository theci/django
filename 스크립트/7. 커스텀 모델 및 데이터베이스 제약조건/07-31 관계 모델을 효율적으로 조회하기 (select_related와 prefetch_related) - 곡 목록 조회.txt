안녕하세요. 이번 시간에는 하나의 조회 요청에서 관계 모델을 효율적으로 조회하는 방법을
살펴보겠습니다. 곡 목록에서 각 곡마다 가수명을 출력하려 합니다.
송 모델을 통해 곡 목록을 조회하고, 순회 돌면서 외래키 관계에 있는 아티스트 모델을 통해
가수명을 출력했습니다.
총 수행되는 쿼리 수는 4개이고요.
지정 개수의 곡 조회에 1개의 쿼리가 수행되었고, 3개의 곡을 순회 돌며 곡별로 가수명이
조회되었습니다.
이러한 상황이 N 플러스 1개의 쿼리가 수행되는 것이며, N 플러스 1 문제라고 말합니다.
N 플러스 1 문제는 데이터베이스와의 상호 작용에서 자주 발생하는 성능 문제 중
하나입니다. 이는 데이터베이스의 부하를 높이고 애플리케이션의 성능을 저하시킬 수 있습니다.
그런데 의도적으로 N+1 문제를 발생시키는 경우도 있습니다.
대부분의 상황에서 M++1 문제는 애플리케이션 성능 저하의 원인이 되므로 피해야 할
상황입니다. 장고 모델은 기본적으로 모델 단위로 관계 필드를 제외한 모든 필드에 대해서
셀렉트 조회를 합니다.
쿼디셋의 ONLY 메서드나 DEEPER 메서드를 통해 일부 필드만 조회한 경우에도 조회되지
않은 필드에 접근하면 이때에도 아직 조회하지 못한 필드를 조회하기 위해 레코드의 개수만큼
n 플러스 1개의 쿼리가 수행되는 상황이 발생합니다.
지연 로딩은 필요할 때까지 관련 데이터를 로딩하지 않는 방식으로 데이터에 실제 접근하는
시점에 해당 데이터를 데이터베이스에서 조회합니다.
반대 용어로서 즉시 로딩, eager loading은 처음 쿼리할 때 관련 데이터를 미리
로드하는 방식을 말합니다.
장고에서 즉시 로딩을 수행하는 두 가지 방법은 select_related 메서드를
사용하거나 prefetch_related를 사용합니다.
select-related method는 모델의 one-to-one 필드나 외래키 필드의
정방향 참조 모델에서만 사용할 수 있습니다.
이를 적용하면 외래키를 통해 조인 쿼리로 동작합니다.
데이터베이스에서 조인한 결과를 받아서 처리하는 방식이고요.
외래키 필드가 null을 허용하지 않는다면 inner join으로 동작하고 null을
허용한다면 outer join으로 동작합니다.
프리패치 릴레이티드 필드는 외래키 필드의 정방향 참조 모델을 비롯한 모든 관계 필드에서
사용할 수 있습니다.
적용하면 추가 쿼리 한 개를 더 수행한 뒤에 장고단에서 조인 처리를 합니다.
앞선 셀렉트 릴레이티드 방식과 데이터 로딩의 방법만 다를 뿐 쿼리셋을 사용하는 코드는
동일합니다. 조인 쿼리가 모든 경우에 정답인 것은 아닙니다
데이터 성격에 따라 select-related가 효율적일 수도 있고요
prefetch_related가 효율적일 수도 있고 즉시 로딩을 안 하는 것이 효율적일
수도 있습니다
레코드 개수가 많아짐에 따라 쿼리 수가 기하급수적으로 늘어간다면 즉시 로딩이 필요할
것입니다 그리고 select_related는 데이터베이스 단에서 조인을 수행하므로 같은
데이터베이스 내에 테이블에 한해서만 동작하지만 prefetch_related는 별도의 쿼리로
수행하므로 다른 주소의 데이터베이스 간에도 적용 가능하며 심지어 다른 종류의 데이터베이스
간에도 사용할 수 있어서 활용 범위가 넓습니다.
외래키 역방향 참조 모델의 예를 살펴보겠습니다.
아티스트 모델과 송 모델이고요.
아티스트 모델을 통해서 쿼리를 하죠.
송 모델에 대해서 아티스트 모델에 대한 외래키 필드가 있으므로 역방향 참조 모델입니다.
각 아티스트를 순회하며 각 아티스트의 노래 곡명을 모두 출력하려 합니다.
각 아티스트마다 노래를 조회하는 쿼리가 수행되니 N플러스원 문제가 발생합니다.
지정 개수의 가수를 조회하는 쿼리 1개와 가수 3명에 대한 곡을 조회하는 쿼리 3개까지
해서 총 4개의 쿼리가 수행됩니다.
현 상황에서 즉시 로딩을 하려면 외래키 정방향 참조 모델이 아니니까 select_related는
사용할 수 없고요 prefetch_related를 사용하실 수 있습니다
프리패치 릴레이티드에 many to many 필드, 필드명을 쓰시면 이렇게 추가 쿼리 한
개를 통해 조회되는 가수들의 모든 곡을 한 번에 조회해서 M plus 1 문제를 해결합니다
각 가수마다 곡 조회 조건이 다르면 프리패치 릴레이티드를 지정하더라도 n개의 추가 쿼리로
인해 n 플러스 1 문제가 발생하니 유의해 주세요.
장고 셀을 여시고요.
song 모델을 통해 쿼리셋을 만들고 3개의 레코드만 조회하겠습니다.
song 모델에 있는 필드만 이렇게 출력을 하면요.
1개의 쿼리만 수행이 됩니다.
Song Query Set을 순회 돌면서요.
외래키인 Artist의 값을 출력을 해보면 이렇게 Song 목록을 조회하는 한 개의
Query와 그리고 Song 레코드 별로 Artist를 조회하는 N개의 Query가
수행되었음을 확인하실 수 있고요.
각 N개의 Query는 Artist 필드에 접근할 시점에 지연 로딩으로 조회가 이루어지고
있습니다. 즉시 로딩을 해보겠습니다 아티스트 필드는 외래키이니까요 셀렉트 릴레이티드를
사용하실 수 있습니다
그럼 이렇게 한 개의 쿼리로서 이너 조인으로 즉시 로딩이 이루어졌음을 확인하실 수 있습니다
prefetch_related는 외래키 정방향 참조 모델을 비롯한 모든 관계에서 사용할 수 있습니다
한번 사용해 볼게요
이렇게 송 목록을 조회하는 한 개의 쿼리와 아티스트를 조회하는 한 개의 추가 쿼리를 통해서
즉시 로딩이 이루어졌습니다.
이번에는 외래키 역방향 참조 모델을 실습해 볼게요.
세 개의 아티스트를 조회하고 순회 돌며 아티스트 모델 필드만 출력하면 한 개의 쿼리만
수행됩니다.
Artist 모델 인스턴스가 있구요
Song 모델에 정의된 Artist 외래키의 Related Name 설정인 역참조 이름
Song Underbar Set을 통해서 아티스트의 노래 목록을 조회하실 수 있구요 노래
제목을 하나의 문자로 만들어서 이렇게 출력할 수 있습니다
이를 반복문에 적용해 볼게요
Artist Query Set 반복문 안에다가 매 아티스트마다 Song Names를
계산하는 코드를 넣고 이렇게 출력을 해줍니다
그럼 아티스트마다 노래 목록을 조회하는 N개의 쿼리가 수행되어 N 플러스 1 문제가
발생하죠. 외래키 역방향 참조 모델에서는 prefetch_related로 즉시 로딩을 합니다.
이를 적용해 보면 1개의 추가 쿼리로 즉시 로딩이 이루어져 총 2개의 쿼리가 수행되었네요.
곡 목록에서 각 곡마다 앨범 명을 출력하려 합니다 아티스트 외래기 필드에 대해서만 즉시
로딩을 수행했을 때 즉시 로딩을 수행하지 않은 앨범 필드에 접근하면 이렇게 M++1 문제가
또 발생합니다
select_related 메서드에 앨범 필드를 추가 지정하여 두 개의 외래기 필드에
대해서 즉시 로딩을 수행할 수 있습니다
select_related 메서드와 PRE-PATCH RELATED 메서드는 한 개 이상의
필드를 지정할 수 있어요
섣부른 최적화로 사용하지 않는 관계에 대해서 즉시 로딩을 수행하는 것은 오히려 성능 저하를
가져옵니다. 즉시 로딩을 처음부터 적용하지는 마시고요.
즉시 로딩 없이 구현하셨다가 M++ 문제가 탐지되면 상황을 분석하신 후에 즉시 로딩을
적용해 주세요.
장고 애플리케이션에서 발생하는 쿼리를 모니터링하고 분석하는 데에는 Django Debug Toolbar
라이벌리나 Django Silk 사용을 추천드립니다.
앞선 예시의 코드를 먼저 한번 더 수행을 해 보고요 아티스트 외래키 필드에 대해서 즉시
로딩을 수행했고 이렇게 출력했었죠
앨범 외래키 필드에 대해서 출력만 해보면 이렇게 다시 N플러스 1 문제가 발생합니다
앨범 외래키에 대해서도 select_related를 통해 즉시 로딩을 수행하면 이렇게 이너조인으로
N+1 문제가 해결되었습니다 곡 목록에서 각 곡마다 장르명을 출력하려 합니다
현재 QuerySet은 와 통해 즉시 로딩 처리가 되어 있죠
수행하면 M+1 문제가 발생합니다.
장르 언더바셋 에 대해서는 즉시 로딩 처리가 안되어 있습니다.
외래키 정방향 모델에 대해서만 셀렉트 릴레이티드를 사용할 수 있으며, 프리패치 릴레이티드는
모든 관계에서 사용할 수 있죠.
프리패치 릴레이티드를 통해 에 대한 즉시 로딩을 처리해줍니다.
그러면 이렇게 추가 1개의 쿼리를 수행하여 조회하는 곡의 안에서 장르 목록을 조회하여 N
플러스 1 문제가 해결되었습니다.
매 곡의 장르를 이렇게 조회해서 출력을 해보면 N 플러스 1 문제가 발생을 하죠.
곡의 개수만큼 장르를 조회하는 쿼리가 N개의 수행이 되었습니다.
Make-to-Many 필드에 대해서 즉시 로딩을 수행하시려면, prefetch_related를
사용하시고, Make-to-Many 필드명을 지정하시어 수행하실 수 있습니다.
셀렉트 닐레이티드를 통한 조인 쿼리와 prefetch_related를 통한 한 개의 추가 쿼리를
통해서 M++1 문제가 해결되었습니다.