데이터베이스 테이블 단위로 유일성이 보장되어야 할 데이터들이 있습니다
우편번호 코드나 태그의 네임 필드를 예로 들 수 있겠습니다
단일 컬럼에 대한 유일성 제약 조건을 지정하는 방법은 두 가지입니다.

첫 번째 방법은 모델 필드에 unique=True 인자를 지정하는 것입니다.
마이그레이션 시에 유일성 제약 조건이 추가되며, PostgreSQL에서는 문자열 필드의 경우 like, ilike 검색 성능을 향상시키는 인덱스가 자동으로 생성됩니다.
이 방법은 대문자를 구별하여 다른 값으로 처리하므로 대소문자가 다른 문자열은 유일성 제약 조건을 위반하지 않아 각각 저장될 수 있습니다.
대소문자가 같은 문자열을 저장하려 할 때 인티그리티 에러 예외가 발생하며 유효성 검사 시에는 같은 이름의 레코드를 조회하여 유일성을 체크해 줍니다.

두 번째 방법은 모델의 메타 클래스 안에서 UniqueConstraint를 사용하여 제약 조건을 추가하는 것입니다.
이 방법에서는 다양한 옵션으로 유일성 제약 조건을 추가할 수 있으나, 첫 번째 방법과 달리 like, ilike 검색 성능을 향상시키는 인덱스가 자동으로 생성되지 않습니다.
필요한 경우 이와 같이 사용자가 직접 인덱스를 정의하여 추가할 수 있습니다.
두 방법 모두 제약 조건과 인덱스 생성 코드 및 코드셋의 동작 방식은 서로 동일합니다.

블로그 태그 모델에 네임 필드에 유니크 참 인자를 추가하고 makemigrations 블로그 명령을 통해 마이그레이션 파일을 생성합니다 
방금 블로그 앱에 0014 마이그레이션 파일이 생성되었고요 
sql migrate blog 0014 명령으로 수행될 쿼리를 확인해봅시다 
Ultra Table Add Constraint Unique Query로 유일성 제약 조건이 추가될 것이며, 현재 데이터베이스가 PostgreSQL이기에, Name Field에 대한 인덱스도 추가되네요. 
그런데 이미 Name Field에 대한 인덱스가 있기 때문에, 인덱스가 이중으로 추가될 수 있습니다.
Name Field에 대한 인덱스를 하나만 사용하기 위해, 기존 인덱스 설정을 제거하고, 다시 마이그레이션 파일을 생성하겠습니다.
블로그 웹에 0014 마이그레이션 파일을 삭제하고요.
다시 마이그레이션 파일을 생성하니 기존 인덱스를 제거하는 동작도 추가된 듯 보입니다
SQL Migrate 명령으로 수행될 SQL 내역을 살펴보니까 이렇게 기존 인덱스를 제거하는 쿼리도 있고요 
유니크 제약 사항도 추가되고 새로운 인덱스도 추가됨을 확인하실 수 있습니다 
Show Migrations Blog 명령으로 현재 마이그레이션 적용 내역을 확인하고요 
14번이 현재 미적용 상황입니다
14번 마이그레이션 파일을 삭제하고 재생성하겠습니다
unique=True 인자를 제거하고 Uniqueconstraint를 추가합니다.
fields 인자만 지정하시고 make-migrations 명령을 수행하시면 Uniqueconstraint는 반드시 name 인자를 지정해야 한다는 Value error가 발생합니다.
name 인자를 지정하시고 다시 make-migrations 명령을 수행하시면 명령이 성공합니다. 
앞서 지정한 인덱스가 제거되는 동작도 있구요
유일성 제약사항이 추가되는 동작도 있습니다
현재 PostgresSQL이기에 unique-charm 에서와 동일한 인덱스를 추가해 주겠습니다 
그리고 앞서 생성한 0014 마이그레이션 파일을 제거하고 make-migrations 명령을 통해 다시 생성하겠습니다
SQL migrate Blog 0014 명령으로 수행될 쿼리를 확인해 보면 기존 네임필드에 대한 인덱스를 제거하며 name 필드에 대한 새로운 인덱스를 생성하고 name 필드에 대한 유일성 제약 조건도 추가될 것입니다.

태그 모델을 통해 데이터를 생성해 보겠습니다.
먼저 Migrate Blog 명령으로 0014 마이그레이션을 데이터베이스에 적용합니다.
이어서 장고 셀을 구동해 주시고요
태그.object.create를 통해서 첫 글자가 대문자인 장고 태그를 생성하시고요 
모두 소문자인 장고 태그도 생성해 주겠습니다
현재 유일성 제약 조건에서는 대소문자를 구별하기 때문에 대소문자가 다른 문자열을 각각 생성할 수 있습니다
이미 저장된 소문자의 장고 태그에 대해서 저장을 시도하면 데이터베이스에서 인서트 쿼리가 실행되는 시점에 유일성 제약 조건 위반으로 오류가 발생하고, 장고 단에서는 Integrity Error 예외로 처리됩니다.
현재 저장된 태그 네임으로는 소문자의 장고가 있구요 
소문자 장고 값으로 설정된 새로운 모델 인스턴스를 생성하고 save 메서드를 호출하기 전에 full_clean 메서드를 호출하여 태그 모델에 대한 유효성 검사를 모두 수행합니다
이때 유일성 제약 조건에 대해서도 자동으로 체크가 이루어집니다
select query로 데이터베이스에 소문자 장고 데이터가 있는지 확인하고 현재 소문자 장고 데이터가 있기 때문에 장고가 validation error, 예외를 발생시켰고 예외 메시지로 지정 태그의 name이 이미 존재한다고 하네요
이렇게 유효성 검사가 실패한 경우에 데이터베이스로의 저장을 시도하지 않고 유저에게 에러 메시지를 전달하여 재입력을 받도록 합니다 
데이터베이스에 추가한 유일성 제약 조건은 데이터 무결성을 위한 최후의 안전장치인 것이고요.
장고 모델을 통해서 저장을 시도하기 전에, 이와 같이 유효성 검사를 미리 수행한 뒤에, 유효성 검사에 모두 통과한 경우에만 데이터베이스로의 저장을 시도하면 데이터베이스 부하를 줄이고, 오류에 대한 피드백을 유저에게 보다 빠르게 전달할 수 있습니다.
장고 쪽에서의 유효성 검사를 위해 별도의 로직을 추가하지 않아도 이렇게 유일성 검사를 장고 단에서 해주고 있습니다.
유효성 검사에 대해서는 이후 장고 폼에서 자세히 다루겠습니다.
새로운 파이썬 태그 모델 인스턴스를 생성하고 full_clean 메서드를 호출하여 유효성 검사를 수행합니다.
밸리데이션 에러 예외가 발생하지 않았으니 유효성 검사에 모두 통과한 것이고요.
현재 데이터베이스에 소문자 파이썬 태그는 없나 봅니다.
이때 save 메서드를 호출하여 데이터베이스에 저장을 시도합니다.
인서트 쿼리가 수행되었고, 오류 없이 데이터베이스에 잘 저장되었습니다.
이후 실습을 위해서 태그 데이터는 모두 삭제하겠습니다.

앞선 예시에서는 대소문자를 구별하면서 태그를 저장했지만 태그는 대소문자를 구별하지 않고 유일성을 체크해야 합니다
유니크 Constraint를 사용하면 임의로 변환한 값에 대한 유일성 제약 조건을 추가할 수 있습니다
Lower Database 함수를 이용하여 태그명을 소문자로 변환한 유니크 인덱스를 생성함으로써 대소문자를 구별하지 않는 유일성 제약 조건을 구현할 수 있습니다
인덱스 생성 쿼리에서도 이렇게 데이터베이스의 lower 함수가 적용됩니다.
이 방법을 사용하면 유효성 검사 시에도 태그의 name 값을 소문자로 변환하여 유일성을 검사하게 됩니다.
fields 인자를 제거하고 유니크 constraint 클래스 생성자의 첫 번째 위치 인자로 lower name을 지정합니다.
makemigrations 블로그 명령으로 모델 변경 내역에 대한 새로운 마이그레이션 파일을 생성하면 기존 유니크 제약 조건을 제거하고 새로운 유니크 제약 조건을 생성함을 알 수 있구요. 
SQL migrate 명령으로 수행될 query 내역을 살펴보면 기존 유니크 제약 조건을 제거하고 새 유니크 인덱스가 생성되며 lower database 함수가 적용될 것임을 확인하실 수 있습니다.
migrate 명령 명령으로 마이그레이션 파일을 데이터베이스에 적용하구요.
장고 셀을 구동하여 태그 내역을 확인해 보면 등록된 태그가 없고요.
소문자 장고 태그를 생성하고 첫 글자가 대문자인 장고 태그를 생성하면 유일성 제약 조건에 위배되어 IntegrityError 예배가 발생함을 확인할 수 있습니다.
대소문자를 구별하지 않고 유일성이 확인되고 있죠.
새로운 태그 모델 인스턴스를 만들고 full_clean 메서드를 호출하여 유효성 검사를 수행해 보면 lower database 함수를 통해 확인이 이루어짐을 확인할 수 있습니다.



이번 시간에는 **유일성 제약 조건(Unique Constraint)**을 데이터베이스 모델에서 설정하는 방법과 그 활용을 다뤘습니다. 주요 내용은 다음과 같습니다:

1. 유일성 제약 조건을 설정하는 방법
유일성 제약 조건은 데이터베이스 테이블에서 특정 컬럼의 값이 고유하도록 보장하는 제약 조건입니다.

두 가지 방법으로 유일성 제약 조건을 설정할 수 있습니다.

첫 번째 방법: 모델 필드에 unique=True 설정

예를 들어, name 필드에 unique=True를 설정하면 해당 필드는 중복되지 않도록 보장됩니다.
PostgreSQL에서는 문자열 필드에 대해 like, ilike 검색 성능을 향상시키는 인덱스가 자동으로 생성됩니다.
이 방법은 대소문자를 구별하여 유일성을 검사합니다. 즉, "Django"와 "django"는 서로 다른 값으로 처리됩니다. 대소문자가 같은 문자열을 저장하려고 하면 IntegrityError 예외가 발생합니다.
두 번째 방법: 모델의 메타 클래스 안에서 UniqueConstraint 사용

이 방법을 통해 다양한 옵션으로 유일성 제약 조건을 설정할 수 있으며, 자동으로 인덱스가 생성되지 않습니다. 필요 시 인덱스를 수동으로 추가해야 합니다.
2. 유일성 제약 조건을 적용한 예시
블로그 모델에서 name 필드에 유일성 제약 조건을 추가하고, 이를 마이그레이션하여 데이터베이스에 적용하는 과정이 소개되었습니다.
makemigrations 명령을 실행하면 새로운 마이그레이션 파일이 생성되며, 이 파일을 통해 유일성 제약 조건이 추가됩니다. 또한 PostgreSQL에서는 인덱스도 함께 추가됩니다.
만약 기존 인덱스가 이미 있다면, 인덱스가 이중으로 추가되는 것을 방지하기 위해 기존 인덱스를 제거하고 다시 마이그레이션 파일을 생성하는 방식으로 해결합니다.
3. 유효성 검사 및 예외 처리
유일성 제약 조건이 적용된 필드에 대해 장고에서 유효성 검사가 자동으로 이루어집니다. 예를 들어, tag.name에 대해 중복된 값을 저장하려고 하면 **IntegrityError**가 발생하고, 이를 처리하여 오류 메시지를 유저에게 전달할 수 있습니다.
full_clean 메서드를 호출하면 유효성 검사가 수행되며, 데이터베이스에 저장되기 전에 유일성 제약 조건을 포함한 여러 검사가 이루어집니다.
4. 대소문자 구별 없이 유일성 제약 조건 적용하기
대소문자 구별 없이 유일성 제약 조건을 적용하려면, UniqueConstraint에서 lower 데이터베이스 함수를 사용하여 태그명을 소문자로 변환한 후 유일성을 검사하도록 할 수 있습니다.
이 방법은 lower 함수를 통해 입력되는 값을 소문자로 변환하고, 이를 기준으로 유일성을 검사하므로 대소문자에 관계없이 유일성을 보장합니다.
마이그레이션을 통해 기존 유일성 제약 조건을 제거하고, 소문자 변환 후 유일성 제약 조건을 추가하는 쿼리를 확인할 수 있습니다.
5. 실습 과정
**소문자 "django"**와 대문자 "Django" 태그를 데이터베이스에 저장하려고 시도했을 때, 대소문자가 다른 값으로 처리되어 두 값이 각각 저장되었습니다.
이후 대소문자를 구별하지 않는 유일성 제약 조건을 설정하고 다시 테스트한 결과, 대소문자가 다른 "Django"와 "django"가 동일한 값으로 인식되어 IntegrityError 예외가 발생하며, 유효성 검사도 정상적으로 작동함을 확인할 수 있었습니다.
결론
유일성 제약 조건은 데이터의 무결성을 보장하기 위한 중요한 도구입니다.
두 가지 방법(unique=True와 UniqueConstraint)으로 유일성 제약 조건을 설정할 수 있으며, 이를 통해 데이터베이스 내에서 중복 데이터를 방지할 수 있습니다.
대소문자를 구별하지 않도록 유일성 제약 조건을 설정하려면, 데이터베이스 함수(lower)를 활용할 수 있습니다. 이를 통해 유효성 검사를 강화하고 데이터의 중복을 방지할 수 있습니다.