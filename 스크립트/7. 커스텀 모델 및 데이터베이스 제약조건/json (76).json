관계 필드 첫 번째로써, models.ForeignKey입니다.
models.ForeignKey는 1대 N 관계에서 n측의 모델에 명시합니다.
posting과 댓글 관계에서 댓글 모델에 명시하고, user와 posting 관계에서
posting 모델에 명시하고, user와 댓글 관계에서 댓글 모델에 명시합니다.
모든 관계 필드는 migration 시에 외래키 필드에 대한 인덱스를 자동으로 추가합니다.
1대 N 관계에서 1측의 모델을 부모 모델, N측의 모델을 자식 모델이라고 부르겠습니다.
models의 ForeignKey 모델 필드 정리에서 첫 번째 인자는 To 인자로서 부모로
지정할 모델 클래스를 지정합니다.
모델 클래스를 직접 지정할 수도 있고요.
문자열로서 모델명을 쓰면 같은 장고 앱에서 지정 모델을 참조하고, 앱 이름.
모델명을 쓰면 지정 앱에 지정 모델을 참조합니다.
셀프 문자를 쓰면 현재의 모델을 참조하고요.
이는 계층 구조를 설계할 때 사용합니다.
두번째 인자는 외래키의 키 제약 조건 적용 여부 설정으로서 db__constraint 설정이며
default로 참입니다.
이 설정을 켜면 웰의 키의 부모가 항상 존재함을 데이터베이스 수준에서 보장받을 수
있습니다. 서비스 여건에 따라 이 설정을 끄기도 합니다.
세 번째 인자는 부모 모델 객체가 삭제될 때 자식 모델 객체에 적용할 정책입니다.
대표적인 설정으로 CASCADE를 적용하면 부모에 대해 삭제를 시도했을 때 관련 자식을
먼저 삭제하고 나서 부모를 삭제합니다.
이외에도 부모가 삭제되면 자식 모델 객체의 외래 키 값을 자동으로 null로 설정하는
set null 정책이 있고요.
부모가 삭제되면 자식 모델 객체의 외래 키 값을 모델 필드의 default 값으로 변경하는
SET DEFAULT 정책도 있고, 부모가 삭제되면 자식 모델 객체의 외래 키 값을 지정
값으로 변경하는 SET 정책, 그리고 부모가 삭제되더라도 자식 모델 객체에 대해서는 아무런
작업을 하지 않는 DO NOTHING 정책도 있습니다.
이는 외래키 제약 조건이 적용된 상황에서는 IntegrityError 예외가 발생할 수
있고요. 외래키 제약 조건이 해제된 상황에서는 외래키 관계의 레코드는 없는데, 외래키 값은
그대로 유지됨으로써 데이터 무결성이 훼손됩니다.
그 다음으로 부모가 삭제되는 것을 무조건 막는 Protect 설정이 있고요.
Protect 설정이 적용되면 관련 자식을 먼저 삭제해야만 부모를 삭제할 수 있습니다.
Restrict 설정은 선택적으로 삭제를 허용합니다.
삭제를 시도하는 부모가 다른 외래키 컬럼을 통해 삭제가 가능할 때에만 삭제를 허용하거든요.
예시로써 가수 모델, 앨범 모델, 노래 모델이 있고요.
각 모델은 외래키 관계에 있습니다.
노래 모델은 앨범 모델에 대해서 Restrict 설정이 걸려 있고요.
앨범 1은 Restrict가 걸린 외래키 관계 외에 다른 삭제가 가능한 관계가 없기 때문에
노래 1이 삭제되기 전에는 앨범 1은 삭제가 불가능합니다.
앨범 2번도 노래 2번의 Restrict 정책으로 인해 노래 2번이 삭제되기 전에는 앨범
2번은 삭제할 수 없습니다.
가수 2번을 삭제하려면 Cascade 설정으로 인해 앨범 2번을 먼저 삭제하려 하지만 앨범
2번은 노래 2번에 의해 삭제될 수 없기에 가수 2번도 삭제할 수 없습니다.
가수 1은 앨범 1로 인해 삭제가 불가능해야 하지만, 노대 1과 노대 2의 Cascade
정책으로 인해 삭제가 가능합니다.
앨범 1의 ModelInstance.DeleteMethod 호출로는 노대 1에 대한
Restrict 정책으로 인해 앨범 1을 삭제할 수 없어요.
하지만 가수1의 modelInstance.delete 메서드를 호출하면 각 관계의
캐스케이드 정책으로 인해 가수1과 노래1, 노래2, 그리고 앨범1도 같이 삭제됩니다.
유저 모델은 장고 기본 앱 Auth에 의해서 제공이 되고 있고요.
프로젝트마다 커스텀 유저 모델을 지정할 수 있습니다.
관계 필드에서 올바른 유저 모델 지정 방법을 살펴봅시다.
장고 라이브러리를 개발한다면 그 라이브러리는 여러 프로젝트에 의해 사용될 수 있겠고요.
프로젝트마다 사용하는 유저 모델 클래스가 다를 수 있습니다.
그래서 유저 모델에 대한 관계 필드에 유저 모델 클래스를 하드 코딩으로 지정하지 말고요.
세팅스의 어스 유저 모델을 참조하면 유연하게 유저 모델을 설정할 수 있습니다.
장고 프로젝트를 개발할 때는 프로젝트 고유의 유저 모델을 만들어서 쓸 테니 그 유저 모델을
참조하는 모든 접근이 좋습니다.
관계 필드에 외래키 제약 조건을 걸지 않는 경우가 있는데요.
그러면 데이터베이스로부터 데이터 무결성을 보장받지 못하고, 데이터 무결성을 애플리케이션에서
직접 관리해야 합니다.
대표적으로 아래의 이유로 관계 모델 필드에 DB Constraint 인자를 지정하면 외래키
제약 조건을 끌 수 있습니다.
그 첫 번째로 분산 데이터베이스인데요.
하나의 장고 프로젝트에서 여러 데이터베이스를 사용하거나, 다른 종류의 데이터베이스에
데이터가 분산되어 있을 경우, 외래키 제약 조건을 적용하기 어려울 수 있습니다.
그 두 번째로, 파티셔닝된 데이터베이스 테이블에는 외래키 제약 조건을 지정할 수 없고요.
그리고 세 번째로, 데이터 마이그레이션입니다.
기존 데이터베이스의 데이터를 새로운 데이터베이스로 이전할 때, 외래키 제약 사항이 걸려
있으면, 그 제약 사항으로 인해 데이터 복제가 번거로울 수 있거든요.
이때 일시적으로 외래키 제약 조건을 끄면 데이터 이전을 보다 유연하게 처리할 수 있습니다.
블로그 앱의 Post 모델과 Comment 모델은 1대 N의 관계입니다.
N측인 Comment 모델에 Post 모델에 대한 외래키 필드를 추가하게 됩니다.
이 관계에서 한 댓글이 속한 포스팅을 조회하는 방법과 한 포스팅에 속한 댓글 목록을
조회하는 코드를 살펴보겠습니다.
코멘트 모델 인스턴스가 하나 있습니다.
외래키 필드명 언더바 아이디 속성을 통해 외래 키 값을 직접 조회할 수 있고요.
값 1은 포스트 모델의 기본 키 1을 뜻합니다.
그러면 기본 키가 1인 포스팅을 이렇게 조회할 수 있죠.
관련 포스팅 조회를 외래키 필드를 통해 손쉽게 조회할 수 있습니다.
코멘트 모델 인스턴스의 post 외래키 필드 속성에 접근하면 자동으로 데이터베이스 조회가
발생하고, post 모델 인스턴스를 직관적인 코드로 참조할 수 있게 됩니다.
이후에 다시 post 속성에 접근하면 현재 코멘트 모델 인스턴스에서는 이미 포스트 속성을
조회했기 때문에 추가 쿼리 없이 관련 포스팅 모델 인스턴스를 생성할 수 있게 됩니다.
이번에는 포스트 모델 인스턴스가 하나 있을 때 그 포스팅에 속한 댓글 목록을 조회하고자
합니다. 외래 키 값을 통해 조회할 수도 있고요.
외래 키 모델 필드를 통해서도 조회가 가능합니다.
수행되는 SQL 쿼리는 둘 다 동일하죠.
1 대 n 관계에서는 n 측 모델에 모델명 소문자 언더바 set 이름의 related
manager 속성이 자동으로 추가가 됩니다.
그럼 post 모델에는 comment 언더바 set이라는 이름의 related
manager 속성이 자동으로 추가되는 거죠.
이 RelatedManager 속성의 .all 메서드 호출을 통해서 현 포스팅에 속한 댓글
목록 쿼디셋을 생성하실 수 있습니다.
왼쪽에 외대 키 값을 통한 조회 혹은 외대 키 필드를 통한 조회에서 수행된 SQL 쿼디와
똑같은 쿼리가 수행이 되고 있죠.
이와 같이 특정 포스팅에 속한 댓글 목록을 직관적인 코드로 조회하실 수 있게 되었습니다.
장고 셀을 두 개 열어주시고요.
한 댓글이 속한 포스팅을 조회하는 두 가지 코드를 비교 실습해 보겠습니다.
코멘트 모델 인스턴스를 각각 한 개씩 조회했고요.
외래 키 값을 바로 출력해 보면, 값이 1이죠.
이 외래 키 값을 포스트 모델에 대한 코디셋 코드에 직접 활용하여, 이렇게 관련 포스트
모델 인스턴스를 조회하실 수 있고요.
코멘트 모델 인스턴스의 외래킷 필드인 포스트 속성에 접근하시면 포스트 언더바 아이디에
저장된 외래킷 값을 활용해서 자동으로 쿼리가 수행되고 포스트 모델 인스턴스가 자동
생성됩니다. 코멘트 모델 인스턴스에서 포스트 속성은 이미 조회된 속성이므로 해당 속성으로
제 쿼리가 수행되지 않고요.
앞서 생성된 포스트 모델 인스턴스를 그대로 참조하실 수 있습니다.
이번에는 한 포스팅에 속한 댓글 목록 코디셋을 생성하는 두 가지 코드를 비교해 보겠습니다.
현재 PostModel 인스턴스의 기본 키 값은 1입니다.
기본 키 필드명이 id이고요.
기본 키에 대한 별칭이 pk입니다.
기본 키 필드명이 변경되더라도 pk 이름으로 기본 키를 참조하실 수 있습니다.
코멘트 모델을 통해 쿼디셋을 생성했을 때 데이터베이스 컬럼명인 post_id를 통해서
조회를 하신다면 기본 키 값을 지정하시게 되고요.
외래키 필드를 통해서 조회를 하신다면 관련 모델 인스턴스를 지정하시게 됩니다.
지정하는 인자의 차이일 뿐, 수행되는 SQL 쿼리는 같습니다.
PostModel 인스턴스에는 CommentUnderbarSet 이름의
RelatedManager가 있습니다.
.all 메서드 호출을 통해서 지정 포스트에 속한 모든 댓글 목록을 조회할 수 있는
쿼리셋을 생성하실 수 있습니다.
CommentModel을 통한 쿼리셋과 수행되는 SQL 쿼리는 동일하지만, 보다 직관적인
코드로 쿼리셋을 생성하실 수 있게 됩니다.
디폴트로 생성되는 역방향 관계 이름은 모델명만을 사용해서 만들어집니다.
하나의 모델은 하나의 잔고 앱 내에서는 유일하지만, 잔고 프로젝트 내에서 여러 잔고 앱이
있을 경우 모델명이 겹칠 수 있습니다.
블로그 앱에 포스트 모델에 유저 모델에 대한 외래키로 작성자 필드를 추가했다면, 디폴트
역방향 관계 이름은 post__set이 됩니다.
그리고 샵 앱의 post 모델에 user 모델에 대한 외래 키로 작성자 author 필드를
추가했다면, 이 역시 default 역방향 관계 이름은 post__set이 됩니다.
모델 변경 사항이 발생했고, make migration 명령을 수행해 보면, default
역방향 관계 이름이 겹쳐서 충돌이 발생합니다.
장고 서버가 처음 구동될 때, 장고의 시스템 체크 프레임워크에 의해서 체크가 이루어지고,
충돌 상황을 감지해서 시스템 체크 에러가 발생했습니다.
모델을 변경하고 Make Migrations 명령 시에 이러한 오류를 만나시면 각 모델의
관계 필드에서 역방향 관계 이름에서 충돌을 제거해 주셔야 합니다.
블로그의 모델 스키마 내에 Post 모델의 User 모델에 대한 외래키 필드가 있습니다.
그럼 User 모델 인스턴스에는 Post__set 이름의
RelatedManager 속성이 있겠죠.
장고 셀을 띄워서 현재 프로젝트에 등록된 UserModel 클래스를 찾아서 그
UserModel 클래스를 통해 UserModel 인스턴스를 하나 생성하고요.
PostSet 속성도 확인하고, 현 유저의 블로그 포스팅 목록을 조회하는 QuerySet도
생성해 봅니다.
이제 샵 앱에 포스트 모델을 생성하고, 유저 모델에 대한 외래키 필드도 추가해 줍니다.
makemigrations 명령을 수행해 보시면, 시스템 체크 에러가 발생하고 있고요.
에러 메세지를 보시면 충돌을 해결하기 위해 RelatedName 설정을 추가하거나
변경하라고 안내되고 있네요.
역방향 관계 이름의 충돌을 피하기 위해서는 자동 생성되는 역방향 관계 이름을 쓰지 않고
모든 역방향 관계 이름에서 앱 이름을 포함시킨 이름을 RelatedName 속성으로
명시적으로 지정하시기를 추천드립니다.
BlogAppPost 모델의 User 모델에 대한 외래키 필드의 related_name
인자를 blog-post-set 문자열로 지정하시면, User 모델 인스턴스에서는
user.blog-post-set.all 코드로 그 유저의 BlogApp의 포스팅 목록을
조회하실 수 있구요.
샵 앱 포스트 모델의 유저 모델에 대한 외래키 필드의 related_name 인자를
shop__post__set 문자열로 지정하시면 유저 모델 인스턴스에서는
user.shop__post__set.all 코드로 그 유저의 샵 앱의 포스팅 목록을
조회하실 수 있습니다.
블로그앱과 샵앱의 PostModel 클래스가 추상화 모델 클래스를 상속받았고, 그 추상화
모델 클래스에서 외래킷 필드를 추가했다면, 추상화 모델 클래스가 어떤 모델 클래스에서
활용되는지 아직 알 수 없기에 RelatedName 인자의 에비던트과 모델명을 하드코딩으로
지정하기는 어렵습니다.
RelatedName 인자는 Format 문자열 문법을 지원합니다.
%AppLabelS 부분은 모델의 앱 이름으로 자동 대체되고요
%ClassS 부분은 모델 클래스 이름으로 자동 대체됩니다
그러면 이 추상화 모델 클래스를 상속받는 블로그앱과 샵앱의 두 PostModel 클래스는
슬라이드 왼쪽에 보여드린 PostModel 클래스와 동일한 외래키 필드를 가지게 됩니다
blog-app-post-model-user-model 외래키 필드의 related_name
인자를 abidm-model-sum-set 포맷으로 blog-post-set을 지정하고요,
shop-app-post-model-user-model 외래키 필드에도 동일한 방법으로
shop-post-set을 지정합니다.
다시 Make Migrations 명령을 수행해 보시면 이제 역방향 관계 이름 충돌이
해결되어 명령이 정상 동작하고요.
Migrate 명령도 수행해 주시고요.
두 역방향 관계 이름 확인을 위해 참고 셀을 열어주세요.
User Model Instance를 하나 생성하시고 User Model
Instance에서 역방향 관계 이름인 Blog-Post-Set을 통해
Blog-Posting 목록 코디셋을 생성하실 수 있고 #_post_set을 통해
샵 포스팅 목록 코디셋을 생성하실 수 있게 되었습니다.