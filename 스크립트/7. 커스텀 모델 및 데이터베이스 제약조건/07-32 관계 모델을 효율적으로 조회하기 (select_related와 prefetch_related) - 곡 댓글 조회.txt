핫트랙스 앱에 댓글 모델을 추가하고 각 곡에 대한 댓글을 남길 수 있도록 하겠습니다 유저
모델과 곡 모델을 외래키로 갖고 텍스트 메세지를 남길 수 있습니다
Python 코드로 랜덤 댓글 1,000개를 생성해 보겠습니다 등록된 를 생성하고 를 생성한
다음 매 댓글에서 랜덤으로 를 지정하겠고요 메세지는 Lorem Ipsum 기능을 통해 랜덤
생성합니다 Lorem Ipsum 기능은 지정 개수의 라틴어 랜덤 문자열을 생성해 주며 장고 빌트인
태그인 Lorem에서도 이 기능을 사용합니다 슬라이드 하단에 소스코드 링크를 제공해 드렸고요
그 페이지에서 코멘트 모델 코드를 복사해서 하트랙의 models.py 소스 파일에 붙여 넣습니다
유저 모델과 속 모델에 대한 외래 키를 가지고 있고요 길이 제한이 없는 텍스트 메시지를
저장할 수 있습니다
makemigrations 핫트랙 명령과 migrate 핫트랙 명령으로 마이그레이션 파일을
생성하고 데이터베이스에 적용도 해줍니다.
샘플 댓글 생성을 위해 장고 셀을 열고 코드를 복사해서 붙여넣겠습니다.
전체 유저 목록을 조회해서 리스트로 저장하고 choice() 함수로 랜덤으로 한 개의 레코드를
가져옵니다. 유저 목록을 리스트로 만드는 시점에 쿼리가 한 번 수행되고요.
초이스 함수를 호출하는 시점에서는 이미 메모리에 올려진 모델 인스턴스 중에서 하나를
랜덤으로 조회하기에 추가 코디는 없습니다.
노래 목록도 유저 목록과 마찬가지로 리스트로 조회하고, choice() 함수로 랜덤으로 메모리에서
한 개의 모델 인스턴스를 조회할 것입니다.
반복문을 1000번 순회 돌면서 댓글 모델 인스턴스를 생성하고, bulk create를
통해 한 번에 데이터베이스에 저장하겠습니다.
데이터베이스 탭을 새로 고침하시면 생성된 하트랙 코멘트 테이블을 확인하실 수 있고,
1,000개의 데이터도 확인하실 수 있습니다.
파이참에서는 데이터베이스 조회 시에 500개 단위로 레코드를 끊어서 보여줍니다.
곡 목록에서 각 곡마다 댓글 목록을 출력해 보겠습니다.
각 곡마다 Comment_set 속성을 통해 각 곡의 댓글 목록을 조회할
수 있습니다. 각 댓글을 출력만 하면 N+1 문제가 발생합니다.
Song_qs 코디셋의 prefetch-related 메서드에 댓글 목록을
조회하는 Comment Underbar Set을 지정하여 관련 댓글을 추가 코디 1개로
조회하도록 하여 M++1 문제를 해결합니다.
이번에는 댓글 작성자의 유저어명을 출력하려 합니다.
유저어명을 출력만 하면 M++1 문제가 발생합니다.
코멘트 모델에는 유저어 모델에 대한 외래키로 author 작성자 필드가 있죠.
prefetch_related 메서드에 comment__set__author를 지정하여
추가 쿼리 1개로 관련 유저를 조회하여 M++1 문제를 해결합니다.
속 모델 주도로 prefetch-related를 통해 댓글 작성자를 조회했었는데요 작성자
필드는 코멘트 모델의 외래키이므로 코멘트 모델에 대한 프리패치 수행 시에 작성자 필드를
조인 코디로 조회하실 수도 있습니다
프리패치 클래스를 통해 프리패치 시에 수행할 코디셋을 커스텀 지정하실 수 있습니다
여기에 어서 작성자 필드에 대한 select related를 지정합니다.
그러면 이렇게 comment-on-the-bar set에 대한 추가 코디를 수행할 때,
유저 모델과 join으로 처리가 됩니다.
각 곡을 순회 돌면서 각 곡마다 아티스트, 앨범, 그리고 장르까지 출력하는 코드가 있었죠.
with a key in artist field와 앨범 필드에 대해서는 select
related을 통해 즉시 로딩을 했고, with a key in artist field와
앨범 필드에 대해서는 select_related을 통해 즉시 로딩을 했고, with a
key in artist field와 앨범 필드에 대해서는 select related을
통해 즉시 로딩을 했고, with a key in artist field와 앨범 필드에
대해서는 select related을 통해 즉시 로딩을 했고, with a key in
artist field와 앨범 필드에 대해서는 select_related을 통해 즉시
로딩을 했고, with a key in artist field와 앨범 필드에 대해서는
select_related을 통해 즉시 로딩을 했고, with a key in artist
field와 앨범 필드에 대해서는 select_related을 통해 즉시 로딩을 했고,
with a key in artist field와 코멘트 언더바 셋은 역방향 참조
관계입니다 그러니
prefetch_related를 통해서 추가 커리 한계를 통해 즉시 로딩을 수행할 수 있습니다 추가로
댓글마다 작성자 유저 명을 출력해 보겠습니다 실행해 보면 각 댓글마다 유저 모델 조회가
발생하기 때문에 아주 많은 수의 데이터베이스 조회가 발생하고 있네요
prefetch_related을 통해서 댓글 모델의 author, 작성자 필드와의 외래키
관계에 대해서도 즉시 로딩을 수행하실 수 있습니다.
수행하면 댓글 목록에서의 user 외래키 값으로 추가 쿼리 1개를 수행하여 N+1 문제를
해결해 줍니다.
코멘트 모델의 외래키 필드로 author 작성자 필드가 있습니다.
코멘트 모델을 통한 쿼리셋에서는 select related를 통해 author 필드에 대한
즉시 로딩을 수행할 수 있습니다.
앞선 예시에서는 comment_set과 comment_set__author에 대한 즉시
로딩이 별도 코디로써 수행이 되었었는데요.
comment-set에 대한 즉시 로딩을 수행할 때 author, 작성자 필드에 대한 즉시
로딩을 같이 수행하도록 지정할 수 있습니다.
prefetch_related에 대한 인자를 지정할 때 필드명을 사용하지 않고
prefetch instance를 지정할 수 있고요.
이때 lookup 인자로 필드명, 코디셋 인자로 수행할 코디셋을 지정합니다.
comment_set의 경우 코디셋 인자로 author, field에 대한
select-related를 수행하도록 지정하는 거죠.
그러면 이렇게 comment_set에 대한 prefetch 수행 시에 join을 통해
author field에 대한 즉시 로딩이 수행됨을 확인하실 수 있습니다.