이후 암호 재설정 기능에서는 유저의 이메일 주소가 필요합니다.
현재는 유저로부터 이메일을 입력 받는 기능이 없는데요.
프로필 수정 기능에 이메일 필드를 추가해 보겠습니다.
프로필 수정 뷰에서는 프로필 폼, 모델 폼을 사용하고 있고요.
프로필 모델에 대한 모델 폼이죠.
이메일 필드는 유저 모델에 있기에 유저 모델에 대한 모델 폼도 같이 처리하고 싶은데요
업데이트 뷰, 클래스 기반 뷰는 단일 폼 처리에 포커스가 맞춰져 있기에 두 개 폼을
지원하려면 할 수는 있겠지만 코드가 조금 복잡해 보일 수 있습니다
그래서 함수 기반 뷰로 구현해 보겠습니다 유저 모델에 대한 모델 폼인 프로필 유저 폼 클래스
클래스를 선언하고 이메일 필드를 지정해 줍니다
프로필 에디트 함수 위에 프로필 유저 폼, 폼 클래스도 같이 처리될 수 있도록 폼
인스턴스로 생성해 주고요 두
개의 폼에 정의된 필드명들이 겹치더라도 따로 처리될 수 있도록 prefix 인자로 각각
설정해 줍니다.
폴필 폼 인스턴스 이름도 같이 맞춰 주겠습니다.
템플릿에서도 변경된 이름에 맞춰 변경해 주고요.
프로필 유저 폼에 대해서도 폼 렌더링을 추가해 줍니다.
그럼 이렇게 이메일 주소를 입력받는 폼 필드가 뜨고요.
이메일 값을 입력하시고 저장해 보시면 잘 저장이 됩니다.
그런데 유저 모델의 이메일 모델 필드를 보시면 이메일 필드 타입일 뿐 유일성 옵션은
없습니다. 즉, 여러 유저가 같은 이메일 주소를 입력할 수도 있어요.
프로필 유저 폼에 이메일에 대한 유효성 검사를 추가하여 유일성 체크를 추가해 주겠습니다.
이렇게 유저의 이메일 필드에 대해 대소문자를 무시하고 조회해 보면 유일성 체크가 잘
되는데요. 저장한 후에 다시 수정해 보면 해당 이메일 주소가 데이터베이스에 저장되어 있기
때문에 수정인 경우에는 유일성 체크를 하지 않아야 하는데 이메일 주소를 변경하지 않았음에도
이미 등록된 이메일이라고 나오죠.
조회 쿼리셋에서 현재 유저 인스턴스의 PK를 제외하도록 해주시면 유일성 확인 대상에서 현재
유저 레코드는 제외되어 이메일 변경이 없는 저장에서도 잘 동작합니다
쿼리셋은 모델의 메타의 모델 속성을 참조하도록 해서 이렇게 작성하실 수도 있습니다