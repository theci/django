장고 OSS 앱의 로그인 뷰 뷰에서 로그인을 지원해주고 있습니다.
로그인 뷰를 활용하는 것만으로 완전한 로그인 기능을 사용할 수 있는데요.
로그인 뷰의 핵심 로직을 살펴보므로서 로그인 과정에 대한 이해도를 높여보겠습니다.
유저가 로그인 페이지에 방문하면 HTML 폼을 통해 포스트 방식으로 유저명과 암호를
입력받죠. 이제 유저명과 암호를 검증해야 할 텐데요.
유저 모델을 통해 입력받은 유저의 유저 레코드가 있는지 찾고요.
유저 모델에서는 is_active을 통해 로그인 허용 여부를 결정합니다.
is_active가 거짓이면 로그인을 허용하지 않습니다.
유저명에 매칭되는 유저를 찾았다면 유저 모델의 check_password 메소드를 통해 암호의 일치
여부를 검사합니다.
암호까지 일치한다면 유저명 암호로 유저를 인증했으니 세션에 유저를 조회한 방법과 인증한
유저의 기본키 그리고 인증 해시 값를 저장합니다.
이제 로그인 과정이 끝났으니 다른 페이지로 이동을 시켜야 할 텐데요.
로그인 뷰에서는 기본적으로 Settings에 로그인 redirect URL 설정의 주소로
이동을 시킵니다.
그 설정의 디폴트 값은 Accounts 앱의 프로필 주소입니다.
이후 요청에서는 매번 세션에서 유저를 조회한 방법과 인증한 유저의 기본 키 그리고 인증
해시를 조회하고요.
인증 시에 유저를 조회한 방법으로 유저 레코드를 다시 조회합니다.
이때 유저의 기본 키만으로 유저 레코드를 조회하는 것에서 그치지 않고 유저 암호 문자열을
해싱한 값과 비교하여 일치되었을 때에는 현재 세션을 사용하고, 일치하지 않으면 현재 세션을
날리고 세션을 다시 생성합니다.
그럼 다시 로그인이 필요하겠죠.
인증 해시는 암호와 비밀키 문자열들을 묶어서 해싱한 값으로 세션의 유효성을 검증할
목적으로 사용됩니다.
인증 해시는 유저마다 유일한 값을 가지고요.
이미 로그인된 상태에서 암호가 변경되면 이 해시 값이 변경되므로 해당 유저의 기존 다른
세션들이 자동으로 만료되는 효과가 있습니다.
그리고 다른 유저의 세션이 재사용되는 것을 방지해줍니다.
인증 해시 생성에 사용되는 비밀 키는 settings의 시크릿 키 설정을 사용하는데요 settings의
시크릿 키 설정을 서비스 운영 중에 변경하시면 모든 유저의 인증 해시가 달라져서 각
유저들이 서버에 접속하는 시점에 그 유저의 서버 세션이 삭제되고 재로그인을 해야 하는
불상사가 벌어지니 주의해주세요
로그인 뷰를 직접 구현해 보고요.
OAuth 앱의 로그인 뷰, 클래스 기반 뷰로도 구현해 보겠습니다.
로그인 함수에서는 GET 요청에서는 유저명과 암호 필드를 입력받는 HTML 폼을 보여줄
테고요. POST 요청을 통해 유저 네임, 비밀번호 필드 값으로 아이디 암호 일치 여부를
확인하고 일치하면 인증 세션을 생성합니다.
아이디 암호에 대한 유효성 검사는 로그인 뷰에서는 AuthenticationForm
클래스를 통해서 이루어지는데요.
내부에서 Authenticate 함수를 활용합니다.
Authenticate 함수에서는 인자로 받은 유저 이름 패스워드에 매칭되는 유저 레코드를
찾으면 관련 유저 모델 인스턴스를 반환하고요.
찾지 못하면 None을 반환합니다.
인증 세션은 Auth 앱에 로그인 함수를 호출하면 자동으로 생성해 주고요 로그인 함수
호출만으로 세션 키가 생성되고요 세션 인증에 필요한 3개 값을 세션에 저장하고 CSRF
토큰도 재생성해 주고 유저 모델의 last_login 필드도 현재 시각으로 업데이트해 줍니다
유저명 암호가 아닌 다른 인증 방법을 쓰시더라도 인증에 성공한 후에 로그인 함수를
호출하시면 인증 세션을 생성하실 수 있습니다.
로그인 과정이 끝났으니 다른 페이지도 이동을 시켜야 할 텐데요.
로그인 뷰에서는 PostData 혹은 GetData에서 Next 이름의 인자가 있다면 그
주소를 이동할 주소로 활용하고요.
없다면 Settings에 로그인 redirect URL 주소로 이동을 시킵니다.
로그인 뉴다이렉터 URL 설정은 디폴트로 Account의 프로필 값을 가집니다
로그인 뷰에서는 3개의 장식자로 랩핑되어 있는데요 Sensitive Post
Parameters 장식자는 오류 메시지에서 모든 포스트 데이터 값을 별표로 표시하고요
CSRF Protect 장식자는 현장고 프로젝트에서 CSRF 체크가 비활성화되어 있더라도
항상 CSRF 토큰 값을 검사합니다
네버 캐시 장식자는 뷰 응답을 브라우저에서 캐싱하지 않도록 응답 헤더에 캐시 설정을
합니다. Oath 앱의 로그인 뷰, 클래스 기반 뷰에서는 로그인 인증과 관련된 기능들이
기본 설정으로 모두 구현되어 있습니다.
클래스 기반 뷰로 구현이 되어 있기에 동작을 변경하고 싶으신 속성이나 메서드를 재정의해서
구현하실 수 있습니다.
Form Class 속성은 유저명, 암호를 검증하는 Form Class이고요.
디폴트로 Authentication Form Class를 통해 처리됩니다.
인증 방법을 커스텀하고 싶다면 Authentication Form Class를 상속받은
Custom Form Class를 구현하시고 로그인 뷰의 Form Class 속성으로
Custom Form Class를 지정하시면 됩니다.
Next Page 속성은 로그인 성공 이후에 이동할 주소를 지정하고요.
URL 리버스를 지원합니다.
로그인 성공 이후에 이동할 주소는 총 3개의 값을 참조하는데요.
1순위는 PostData에서의 Next 이름의 값이고요.
2순위는 GetData에서의 Next 이름의 값이고요.
3순위는 NextPage 속성으로 지정한 주소입니다.
위 3개 값이 모두 없다면 ImprobablyConfigured 예외가 발생합니다.
Redirect to Authenticated User 속성은 디폴트로 거짓인데요 참
설정이라면 로그인 시도 시에 이미 로그인이 된 상태라면 로그인 시도를 허용하지 않고
Success URL, 성공 주소로 강제 페이지 이동을 시킵니다
템플릿 네임 속성은 디폴트로 registration.login.html 파일이고요
ExtraContext 속성은 추가 템플릿 컨택트 변수인데요 디폴트로 None입니다
Account 앱의 로그인 뷰를 함수 기반 뷰로 직접 구현해 보겠습니다.
Account 밑에 로그인 폼.html 경로의 템플릿을 통해 HTML 폼을 응답하겠고요.
Django 폼을 사용하지 않고 구현할 것이기에 유저 네임, 패스워드 인풋 요소는 이렇게
직접 입력합니다.
URL 패턴도 등록해 주면 웹브라우저로 Account의 로그인 주소로 접근하면 이렇게
로그인 페이지가 뜹니다.
입력 폼만 있을 뿐 아직 로그인 기능은 작동하지 않죠.
HTML 폼에서 유저명 암호를 입력 받고 폼 전송을 하면 같은 주소로 포스트 방식으로 폼
전송이 됩니다.
포스트 데이터에서 유저 네임과 패스워드 값을 꺼내어 Authenticate 함수 호출을
통해 인증을 수행합니다.
유저 네임의 유저를 찾아서 패스워드 일치 여부를 검사하여 일치하는 유저의 유저 인스턴스를
반환합니다. 논이면 유저 네임 값이나 패스워드 값이 일치하지 않는 거예요.
이제 인증에 성공했으니 이후 요청에서 아이디 암호 인증 없이도 인증 상태를 유지할 수
있도록 세션 인증에 필요한 세 가지 정보를 남깁니다.
이후 요청에서는 아이디 암호 추가 입력 없이도 쿠키를 통해 세션 아이디 값이 전달되고,
장고 미들웨어 단에서 세션 아이디 값을 통해 앞서 설정한 세 가지 세션 정보를 조회하여
유저를 매번 인증합니다.
GetSessionAuthHash 메서드 구현을 보시면 설트 문자열은 고정되어 있구요.
해싱 알고리즘은 SHA256, 비밀키는 default로 non으로 지정되는데요.
해당 해싱함수 구현을 보시면, 시크릿 인자가 non이면, settings에 시크릿 키
설정을 default로 사용하도록 구현되어 있습니다.
로그인에 성공했으니, 로그인 페이지에 머물러 있을 필요가 없죠.
다른 페이지로 이동을 해야 할 텐데요.
오셉의 로그인 뷰 구현에서는 포스트 데이터에서 Next 이름의 인자를 1순위로 찾고,
2순위로 Get 데이터에서 Next 이름의 인자를 찾고요.
3순위로 Settings의 Login Redirect URL 설정을 이동 주소로
사용합니다.
웹브라우저로 Account Login 주소에 접속하시어 로그인을 수행해 보겠습니다.
유저명 암호를 다르게 입력하면 이렇게 우리가 구현한 대로 인증 실패 응답을 받고요.
유저명 암호를 맞게 입력하면 프로필 주소로 이동을 했습니다.
현재 Next 이름에 Post 데이터도 없고 Get 데이터도 없어요.
그러니 3순위인 Settings의 Login Redirect URL 설정에 지정된 주소로
이동을 한 것이고요.
이 설정 값은 디폴트로 Account Profile URL 문자열입니다.
장고 디버그 툴바를 통해 세션 데이터를 보시면 우리가 앞서 설정한 세 가지 세션 데이터를
확인하실 수 있고요
쿠키에 세션 아이디도 있죠
장고 세션 데이터베이스 테이블을 여시면 장고 언더바키 컬럼에서 해당 세션 아이디의 세션
레코드를 찾으실 수 있습니다
Accounts의 프로필 요청을 처리하는 프로필 뷰를 간결하게 구현해 주고요 현재
요청의 유저명과 인증 여부를 응답으로 내어주겠습니다.



장고에서 로그인 기능은 기본적으로 Auth 앱의 로그인 뷰를 통해 제공됩니다. 이 뷰는 로그인에 필요한 핵심 로직을 구현하고 있어, 이를 활용하면 인증 기능을 쉽게 구현할 수 있습니다. 로그인 과정을 이해하기 위해서는 이 뷰의 동작을 살펴보는 것이 중요합니다.

로그인 과정
로그인 요청: 사용자가 로그인 페이지에 방문하면, HTML 폼을 통해 유저명과 암호를 입력받습니다.
유저 검증: 입력받은 유저명과 암호를 사용해 유저 모델을 통해 유저가 존재하는지 확인하고, is_active 필드가 True일 경우에만 로그인을 허용합니다.
암호 검증: 유저가 존재하면 check_password 메서드를 사용해 입력된 암호가 맞는지 확인합니다.
세션 생성: 유저명과 암호가 일치하면 해당 유저의 ID, 암호 해시 등을 세션에 저장하여 로그인 상태를 유지합니다.
리디렉션: 로그인 후, 기본적으로 Settings에 설정된 LOGIN_REDIRECT_URL로 이동합니다. 이 값이 없으면, 요청의 next 파라미터나 기타 설정에 따라 이동 주소를 결정합니다.
로그인 뷰의 구현 방식
GET 요청: 로그인 페이지를 보여줍니다. 유저명과 암호를 입력할 수 있는 HTML 폼을 제공합니다.
POST 요청: 폼을 통해 전송된 유저명과 암호를 이용해 인증을 진행합니다. 인증에 성공하면 세션이 생성되고, 인증 정보를 세션에 저장합니다.
클래스 기반 뷰 (CBV)와 함수 기반 뷰 (FBV)
클래스 기반 뷰: AuthenticationForm 클래스를 통해 유저명과 암호를 검증하며, 인증 후 세션을 자동으로 생성합니다. 로그인 성공 후 리디렉션 주소는 next 파라미터, LOGIN_REDIRECT_URL, 또는 next_page 속성을 참조하여 결정됩니다.
함수 기반 뷰: HTML 폼에서 유저명과 암호를 입력받고, authenticate 함수로 인증을 처리합니다. 인증이 성공하면 세션을 설정하고, 이후 요청에서는 세션을 통해 인증을 유지합니다.
세션과 인증 해시
세션 저장: 인증에 성공하면, 세션에 유저 ID, 인증 해시, 암호 해시 값을 저장합니다. 이를 통해 사용자는 로그인 상태를 유지할 수 있습니다.
인증 해시: 세션에서 인증 해시는 암호 해시와 비밀 키 등을 이용해 생성됩니다. 비밀번호가 변경되면 이 해시도 변경되어, 이전 세션은 만료됩니다.
시크릿 키: settings.py의 SECRET_KEY 값은 인증 해시 생성에 사용됩니다. 이 값이 변경되면 모든 유저의 세션이 만료되므로 주의가 필요합니다.
리디렉션과 세션
로그인 후, 유저는 설정된 URL로 리디렉션됩니다. 기본적으로 LOGIN_REDIRECT_URL에 설정된 주소로 이동하며, next 파라미터가 있다면 이를 우선적으로 사용합니다.
로그인 후의 세션 관리: authenticate 함수와 login 함수를 통해 로그인 상태를 유지하며, 세션 데이터를 통해 인증이 계속 유지됩니다.
세션 데이터 확인
장고의 디버그 툴바나 세션 데이터베이스 테이블을 통해, 현재 유저의 세션 데이터를 확인할 수 있습니다. 세션 ID와 관련된 데이터를 확인할 수 있으며, 세션에 저장된 인증 정보를 점검할 수 있습니다.
결론
장고의 로그인 기능은 기본적인 유저명과 암호 인증을 통해 세션을 생성하고, 이를 기반으로 로그인 상태를 유지합니다. 
클래스 기반 뷰(CBV)와 함수 기반 뷰(FBV)로 구현할 수 있으며, 인증 성공 시 세션을 사용하여 로그인 상태를 관리하고, 필요한 리디렉션을 처리합니다.