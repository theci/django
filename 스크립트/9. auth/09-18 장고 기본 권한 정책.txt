안녕하세요. 이번 시간에는 장고의 기본 권한 정책에 대해서 살펴보겠습니다.
핵심 용어 세 가지가 있습니다.
첫 번째로 인증이고요.
인증은 유저를 식별하는 행위입니다.
아이디 암호로 유저를 식별하고, 세션 아이디로도 유저를 식별하고요.
JSON 웹토큰을 인증 목적으로 사용할 수도 있습니다.
두 번째로 권한이고요.
권한은 특정 기능 또는 리소스에 대한 접근을 제어하는 규칙입니다.
별도 권한 정책이 없다면 인증만으로 모든 리소스에 대한 권한을 허용할 수 있습니다.
AuthApp에서는 모델별로 기본 권한 Add, Change, Delete, View, 즉
추가, 수정, 삭제, 조회 권한을 부여하고요.
오스 앱의 퍼미션 모델을 통해 각 권한을 관리합니다.
모델 단위의 권한마를 기본 지원하며, 각 레코드 단위의 권한은 장고 가디언 라이브러리을 통해
지원하실 수 있습니다.
세 번째로, 허가이고요.
유저에게 특정 권한을 부여하거나 제거하는 행위를 말합니다.
오스 앱에서는 유저 혹은 그룹 단위로 권한을 부여할 수 있습니다.
유저 모델과 퍼미션 모델은 매니투매니 관계이고요.
그룹 모델과 퍼미션 모델도 매니투매니 관계입니다.
해당 유저가 특정 권한을 가졌는지 여부는 hasperm 메서드를 통해 확인하실 수
있습니다. 코드에서는 특정 권한을 지정할 때 이렇게 문자열로 권한을 지정합니다.
권한명 문자열은 앱 레이블과 코드명으로 구성되는데요.
이를 분리하여 퍼미션 모델에서 이렇게 특정 권한에 대한 퍼미션 레코드를 조회하실 수
있습니다. 퍼미션 모델에는 컨텐트 타입 모델에 대한 컨텐트 타입 외래키 필드가 추가되어
있습니다 컨텐트 타입 모델은 장고 프로젝트 내 모델 클래스 목록들을 관리하고요
제네릭 외래키 구현에서 주로 사용합니다
유저 모델 클래스와 그룹 모델 클래스에 지정 이름에 권한을 부여하는 addPerm 메서드를
추가해 보겠습니다 유저 모델 클래스는 우리가 직접 구현했으니까 손쉽게 메서드를 추가하실 수
있고요 그룹 모델 클래스는 우리가 구현한 것이 아니라 OAuth 기본 앱 내에 있잖아요.
이때에는 setAttribute 함수를 통해 지정 클래스의 메서드를 동적으로 이렇게
추가하실 수도 있습니다.
지정 권한명의 Permission 인스턴스를 생성해서 유저의 Permission 목록이나
그룹의 Permission 목록에 이렇게 추가하실 수 있고요.
이제 유저 모델 인스턴스나 그룹 모델 인스턴스의 addPerm 메서드를 통해서 손쉽게
권한을 추가하실 수 있게 됩니다.
그룹에 권한을 추가하면 그룹 내 모든 유저들에게 그 권한이 부여되는데요 그룹에서 특정
유저를 제거하면 그 유저는 그 그룹의 권한이 모두 제거됩니다
그리고 어드민의 유저 모델과 그룹 모델에 대한 모델 어드민을 통해서도 손쉽게 권한을
부여하거나 삭제하실 수 있습니다 유저 모델의 헬지펌 메서드를 통해 유저가 지정 권한을
가지고 있는지 확인할 수 있습니다.
권한명 리스트를 지정하여 지정 권한들을 모두 가지고 있는지도 확인할 수 있습니다.
단 하나의 권한이라도 없다면 거짓을 반환합니다.
유저의 권한을 데이터베이스에서 조회해야 할 텐데요.
has_perm 메서드가 호출될 때마다, 매번 데이터베이스에서 권한을 조회하는 것은 데이터베이스의
부담일 수 있습니다.
장고는 user 객체의 has_perm 메서드 첫 호출에서 지정 유저의 권한 목록을 모두 조회해서 user
객체에 캐싱해 둡니다
이 user 객체를 그대로 사용하는 한, 추가 권한 목록 조회 없이 권한 체크를 수행하고요. 만약
유저의 권한이 변경된 상태에서 바로 이어서 has_perm 메서드 호출을 통해 변경된 권한을
확인하려면 이전 권한으로만 조회가 됩니다.
변경된 권한 목록을 데이터베이스를 통해 다시 조회하려면 user 객체를 이렇게 재생성해주셔야만 합니다.
주셔야만 합니다.
그리고 has_perm 메서드 호출 시에 User 인스턴스가 superuser 라면, 권한 조회 없이 모든 권한을
가지고 있는 것으로 항상 참을 반환하고요.
User 인스턴스가 로그인 불능 상태이거나 로그인이 안 된 상태라면 권한 조회 없이 항상
거짓을 반환합니다.
User 모델 클래스는 PermissionMixin 클래스를 상속받고요
PermissionMixin 클래스에서는 Group 모델과 Permission 모델에 대해서
각각 Many-to-Many 관계가 맺어져 있습니다
Group 모델은 이렇게 Permission 모델과 Many-to-Many 관계가 맺어져 있죠
이 관계를 활용해서 User 모델과 그룹 모델에 각각 add_perm 메서드를 추가해
보겠습니다
accounts 앱의 User 모델 클래스에 add_perm 메서드 코드를 복사해서 직접
적용하고요.
Group 모델 클래스는 auth 앱 내에 있죠.
우리가 Group 모델 클래스 코드를 수정하는 것은 불가능하지만 setattr
내장 함수를 통해 동적으로 Group 모델 클래스에 메서드를 추가하실 수 있습니다.
add_perm 함수를 따로 정의하시고 그 아래에서 Group 클래스에 add_perm 이름으로 해당 함수를
속성으로 등록해 줍니다
가독성을 위해 함수 이름은 group_add_perm 으로 변경해 주겠습니다 장고 셀을 구동해 주시고요
User 레코드도 하나 조회합니다.
이 유저는 슈퍼 유저가 아니어야 합니다
슈퍼 유저는 권한 체크 없이 모든 권한이 있는 것으로 처리되니까요. add_perm 메서드가
이렇게 있고요.
호출해서 해당 유저에게 blog.add_post 권한을 이렇게 추가해 줄 수 있습니다.
has_perm 메서드를 호출하니 데이터베이스에 권한 조회를 하구요. 권한이 있으니 True를
반환하네요. 저는 Group 레코드로 하나 조회하려니 등록된 그룹이 하나도 없습니다.
admin 페이지에서 새로운 Group을 하나 추가해 주시고요.
admin 페이지를 통해서도 이렇게 그룹에 권한을 추가/수정/삭제하실 수 있습니다.
이제 Group 레코드를 하나 조회하고요.
AddPub 메서드가 있죠.
User 레코드도 다시 하나 조회합니다.
이 유저가 blog.change_post 권한이 있는지 체크해 보니 없다고 하네요.
그룹에 blog.change_post 권한을 추가하고요.
이 그룹에 이 유저를 추가해주면 이 유저는 이제 blog.change_post 권한을
가지게 되겠죠.
그런데 이어서 권한을 체크해보면 아직 권한이 없다고 합니다.
그룹에 권한을 부여하기 전에 이 유저 객체에서 이미 권한 내역이 캐싱되었기 때문에
데이터베이스 조회 없이 이렇게 거짓을 반환합니다.
그럼 이렇게 다시 유저 객체를 생성해 주시면 이 유저 객체는 아직 권한 내역이 캐싱이
안 되어 있죠. 권한 조회를 해보시면 이렇게 데이터베이스 조회가 발생하고 blog.change_post 권한이
Post 권한이 있다고 참을 반환합니다.
권한 조회 타이밍과 캐싱에 대해서 설명을 드렸고요.
권한 재조회를 위해 유저 인스턴스를 여러분들이 재생성하실 일은 거의 없으실 겁니다.
왜냐하면 권한 부여 HTTP 요청을 처리하고 나서 별도의 HTTP 요청을 통해 요청이
처리될 테고 이때 새로운 유저 인스턴스가 생성될 테니까요.
함수 기반 뷰에서는 permission_required 장식자를 통해서 권한을 확인하실 수 있고요.
권한명 리스트도 지원합니다.
뷰 호출 시에 지정 권한이 없다면 로그인 페이지로 자동 이동하고요.
레이지 exception 인자에 참 설정을 하시면 지정 권한이 없을 때 로그인 페이지가
아니라 403 forbidden 응답을 합니다.
기본 403 응답은 이러하고요.
이 화면을 커스텀 하려면 403.html 경로에 템플릿 파일을 생성해 주시면 됩니다.
클래스 기반 뷰에서는 PermissionRequired Mixing 클래스를 상속받아서
구현합니다. 각 옵션의 동작은 위 PermissionRequired 장식자와 동일합니다.
PermissionRequired 속성으로 확인할 권한명을 지정하고요.
물론 권한명 리스트도 지원합니다.
레이지 익셉션 설정은 디폴트 거짓입니다.
각 장고 모델에서는 추가, 수정, 삭제, 조회 딱 4개의 권한을 기본 지원하고요.
각 모델에 대한 커스텀 권한을 추가하시려면 모델 클래스의 메타 설정에서
Permissions List를 통해 커스텀 권한을 추가하실 수 있고요.
Permission Record로 등록되기 위해서는 마이그레이션 과정이 필요합니다.
이후에 커스텀 권한을 모델 코드에서 제거하시고 마이그레이션 과정을 수행하시더라도
Permission Record에서 자동으로 제거되지는 않습니다.


이번 시간에는 Django의 기본 권한 정책에 대해 설명했습니다. 핵심 개념은 인증, 권한, 허가입니다. 각 개념에 대해 정리하면:

1. 인증 (Authentication): 유저를 식별하는 과정입니다. 유저는 아이디와 비밀번호로 식별되며, 세션 아이디나 JSON 웹토큰을 통해 인증할 수도 있습니다.

2. 권한 (Permission): 특정 기능이나 리소스에 접근할 수 있는지 제어하는 규칙입니다. Django에서는 기본적으로 모델별 권한(추가, 수정, 삭제, 조회)을 제공하며, 이를 Permission 모델을 통해 관리합니다.

3. 허가 (Authorization): 특정 유저나 그룹에게 권한을 부여하거나 제거하는 과정입니다. 권한은 유저나 그룹에 부여될 수 있으며, 이 과정은 Permission 모델을 통해 관리됩니다.

권한 시스템
Django는 기본적으로 User 모델과 Group 모델에 권한을 부여할 수 있으며, 이를 add_perm() 메서드를 통해 유저나 그룹에 권한을 추가할 수 있습니다.
Permission 모델은 ContentType 모델을 참조하여 특정 모델에 대한 권한을 관리합니다.
has_perm() 메서드를 통해 유저가 특정 권한을 가지고 있는지 확인할 수 있으며, 권한은 한 번 조회하면 캐싱되어 이후에 데이터베이스 조회 없이 빠르게 확인할 수 있습니다.

권한 관리
권한은 유저나 그룹에 다대다 관계로 부여됩니다.
그룹에 권한을 추가하면 그 그룹에 속한 모든 유저는 해당 권한을 가지게 되며, 그룹에서 유저를 제거하면 그 유저의 권한도 함께 제거됩니다.
add_perm() 메서드를 통해 유저나 그룹에 권한을 쉽게 추가하고, has_perm() 메서드로 권한 여부를 확인할 수 있습니다.

권한 확인
함수 기반 뷰에서는 permission_required 장식자를 사용하여 권한을 확인할 수 있습니다.
클래스 기반 뷰에서는 PermissionRequiredMixin을 상속받아 권한을 확인하고, permission_required 속성으로 확인할 권한을 지정합니다.
권한이 없는 경우 기본적으로 로그인 페이지로 리디렉션하거나 403 Forbidden 에러를 반환할 수 있습니다.

커스텀 권한
Django 모델에서 기본적으로 제공하는 4가지 권한(추가, 수정, 삭제, 조회) 외에도 커스텀 권한을 모델의 Meta 클래스에 permissions 속성을 통해 추가할 수 있습니다.
커스텀 권한을 추가하려면 마이그레이션을 통해 데이터베이스에 반영해야 합니다. 만약 이후에 해당 권한을 모델에서 제거하더라도, 데이터베이스에서 자동으로 제거되지 않으므로 수동으로 제거해야 합니다.

권한 캐싱
권한은 User 객체에 캐시되어 한 번 권한을 조회한 후에는 추가적인 데이터베이스 조회 없이 빠르게 권한 확인을 할 수 있습니다. 권한 변경 후 바로 권한을 확인하려면 User 객체를 재생성해야 합니다.
이러한 권한 시스템을 통해 Django 애플리케이션에서 세밀한 접근 제어와 보안을 관리할 수 있습니다.