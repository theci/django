기존의 코드는 적립 횟수만을 기록할 수 있었지만 리팩토링을 통해 다양한 상태를 담을 수 있도록 개선해 보겠습니다.
이를 위해 전역 변수명을 sessions로 변경하였고 이 변수는 사용자의 전화번호와 적립 횟수 상태 정보를 담고 있습니다.
각 상태 정보는 32글자의 랜덤 아이디를 키도 사용하며 이 아이디는 session-id 이름으로 쿠키에 저장할 겁니다.
커피 스탬프 뷰와 커피 프리뷰는 매 요청을 처리할 때마다 쿠키에서 Session ID 키를 조회하고요 
쿠키에 Session ID가 없다면 새로운 Session ID를 랜덤으로 생성합니다 
새롭게 생성한 Session ID가 중복된 Session ID라면 중복되지 않은 유일한 ID가 생성될 때까지 재생성을 반복합니다
이렇게 랜덤 ID를 사용함으로써 Session ID의 예측 가능성을 최소화해서 보완성을 강화했고요 
Sessions 전역 변수에서 Session ID로 유저의 상태를 조회합니다.
Sessions 전역 변수는 Default DIG 사전이기에 지전 Session ID에 키가 없다면 자동으로 새로운 사전을 생성합니다.
이렇게 생성된 Session 사전에서 전화번호와 적립 횟수를 조회하고 저장하면 Sessions 전역 변수에도 저장이 되어 관리됩니다.
새 Session이 생성된 경우, 쿠키에도 반영하여 이후 요청에서 활용될 수 있도록 합니다.
Sessions 전역 변수를 선언하고요.
쿠키에서 Session ID를 조회하고 없으면 새로운 Session ID를 생성하는 Session.getOrCreate 함수를 구현하겠습니다.
후키에서 Session ID가 없으면 32글자 랜덤 문자열을 생성하는데요.
알파벳 소문자 26글자와 0부터 9까지 숫자, 문자 10글자 중에서 랜덤하게 32글자를 뽑아서 새로운 Session ID를 생성합니다.
이렇게 랜덤하게 생성하더라도 아주 낮은 확률로 기존 Session ID와 겹칠 수 있으니 중복되면 재생성하겠습니다.
Session ID와 Session ID 생성 여부를 반환합니다.
커피 스탬프 뷰와 커피 프리뷰에서는 동일한 Session 처리를 할 텐데요.
뷰 함수 시작 지점에서 쿠키의 Session ID를 조회하고요.
조회된 Session ID로 등록된 Session이 없다면 새로운 Session을 생성합니다. 
이렇게 생성된 세션 사전을 참조하여 휴대폰 번호와 적립 횟수를 저장하면 세션 전역 변수에도 저장됩니다.
그리고 뷰 함수 끝부분에서 이 뷰에서 새로운 세션이 생성된 경우 쿠키의 세션 아이디를 저장합니다. 
커피 프리 뷰에도 동일하게 적용해주고요.
이제 정립을 하시고, 브라우저 개발자 도구를 통해 session-id 이름의 쿠키를 확인하실 수 있고요.
브라우저 콘솔에서 document.cookie 코드로 문자열 형태로서 쿠키 값들을 조회하실 수 있습니다. 
앞서 저장한 sessions 전역 변수를 우리는 웹 기술에서 session이라고 부릅니다.
서비스에 접속한 사용자의 로그인 등의 상태를 저장 유지할 목적으로 사용하고요.
사용자의 상태를 우리는 메모리에 저장했지만, 디스크나 데이터베이스 서버, 혹은 캐시 서버 등에 저장할 수도 있습니다.
장고에서는 동일한 인터페이스의 코드로 다양한 세션 스토리지 백엔드를 지원합니다.
디폴트원은 데이터베이스를 사용하고요.
레디스 서버를 세션 백엔드로 사용해서 높은 입출력 성능으로 세션을 활용할 수 있습니다.
메모리는 휘발성이 큽니다.
그 말은 서버가 재시작되면 데이터가 유실된다는 의미이고요.
대신 빠른 입출력 속도를 가지지만 용량에 비해 가격이 비쌉니다.
웹서비스에서 세션 데이터는 필연적으로 매 요청을 처리할 때마다 조회가 발생하고요
데이터베이스 데이터에 비해 변경 및 삭제가 많이 발생하니까 세션 데이터의 입출력 속도가 빨라야 서비스 응답 속도도 빨라집니다
메모리는 프로세스마다 격리되니 다른 프로세스, 다른 서버와 데이터를 공유할 수 없습니다
하나의 웹서비스는 여러 프로세스와 여러 서버를 통해 서비스되거든요.
세션 데이터가 메모리에 저장되어 있다면 각 프로세스별로 데이터는 격리될 것이고요.
요청이 어떤 프로세스에 의해서 처리되느냐에 따라 세션 데이터는 달라지게 될 것입니다.
디스크는 메모리에 비해 상대적으로 느린 입출력 속도를 가지지만 메모리에 비해 싸고 큰 용량을 지원합니다.
그리고 서버가 재시작 되더라도 데이터는 유지되고요.
한 서버 내 다른 프로세스와 데이터를 공유할 수 있지만 다른 서버와는 공유할 수 없습니다.
데이터베이스 서버는 대개 데이터를 디스크에 저장하니까 데이터베이스 서버가 재시작하더라도 데이터가 유지됩니다
하지만 메모리에 비해 상대적으로 느린 입출력 속도를 가지겠죠
데이터베이스 서버는 네트워크를 통해 접속할 수 있기에 다른 프로세스 및 서버와도 세션 데이터를 공유할 수 있습니다
Cache Server는 데이터베이스의 장점을 모두 가지면서 데이터를 메모리에 저장하기에 빠른 입출력 속도를 가집니다.
대신 메모리 기반의 Cache Server의 경우, 서버가 재시작되면 데이터가 유실됩니다.
이제는 Django에서 제공하는 Session 기능을 이용해 볼 차례입니다.
우리가 이전에 작성했던 코드와 인터페이스는 대부분 유사하므로 쉽게 적용할 수 있을 것입니다.
Django의 Sessions 앱과 그 안에 Session Middleware는 우리가 삭제한 코드들의 기능을 제공해 줍니다.
이를 통해 Session 관리가 훨씬 간편해지고요.
Sessions 앱은 다양한 Session 백엔드를 지원하며, 사용자는 Settings에서 간단한 설정 변경을 통해 Session 백엔드를 손쉽게 교체할 수 있습니다.
기본적으로 제공되는 세션 백엔드는 데이터베이스를 사용하고요 실제 서비스에서는 세션 입출력 성능 향상을 위해 Cache 서버를 활용합니다
하지만 Cache 서버가 재시작될 경우 세션 데이터가 유실될 수 있기 때문에 Cache와 데이터베이스와의 조합도 지원합니다
이 방식에서 세션 데이터는 캐시와 데이터베이스에 동시에 저장되며 세션 조회는 빠른 속도를 위해 캐시에서 이루어지고요
만약 캐시에서 세션 데이터를 찾을 수 없을 경우 데이터베이스가 백업 저장소로서 작동하여 세션 데이터를 제공합니다
Django 기본에서 제공해주는 세션 기능을 활용해 보겠습니다 
디폴트 세션 백엔드는 데이터베이스이고요
Django 언더바 세션 데이터베이스 테이블에 저장됩니다
sessions 전역 변수는 제거하시고요.
이제 request 객체의 session 속성을 활용하시기만 하면 됩니다.
쿠키에는 session id 이름으로 session id가 저장됩니다.
이제 적립을 하시면 세션 데이터가 생성이 되고요.
쿠키에서 세션 아이디 항목을 확인하실 수 있습니다.
이 세션 아이디는 Django에서 setCookie 생성 시에 http only 설정이 되어 있어서 자바스크립트로 document.cookie 코드로는 조회가 되지 않아요.
하지만 매 요청에서 브라우저를 통해 자동으로 쿠키 헤더로 서버로 전송이 됩니다.
Django에서 Session 객체는 Session Middleware를 통해서 생성됩니다.
Django 서버 구동 시에 프로젝트에 설정된 Session 백엔드를 로딩하고요.
디폴트로 Database 백엔드가 설정되어 있습니다.
매 HTTP 요청을 처리할 때마다 View 함수를 호출하기 전에 Middleware 단에서
Cookie로부터 Session ID를 읽어드려 Session 객체를 생성하고요.
Cookie에 Session ID가 없을 경우 Session Store 내에서 새로운 Session Key를 생성합니다.
이렇게 생성된 세션 객체를 통해 뷰 내에서 세션에 저장된 데이터를 로딩하고요.
세션에 데이터를 저장하실 수도 있습니다.
변경된 세션에 대한 저장은 뷰 함수 수행 중에 저장을 시도하진 않고요.
뷰 함수가 반환되고 나서 세션 미들웨어 단에서 세션이 비어있다면 세션을 삭제하고요.
세션이 변경되었다면 세션을 저장하고 만료 시간을 재계산하여 쿠키에도 반영합니다.
디폴트 만료 시간은 Settings에 Session Cookie Age 설정을 따르고요.
디폴트 2주로 설정되어 있습니다.
Session 변경 없이 2주가 지나면 Session ID를 저장하고 있는 쿠키가 만료됩니다.
데이터베이스나 파일 백엔드의 Session 데이터는 만료 시간 이후에 자동으로 삭제되진 않습니다.
Clear Sessions 명령을 통해 서버단에서 주기적으로 삭제해 주셔야 하고요.
Cache 백엔드의 Session 데이터는 Cache에서 만료 시간 지정에 의한 자동 삭제를 지원해 주므로 Clear Sessions 명령 시에 실제 수행되는 삭제 작업은
없습니다.