안녕하세요 이번 시간에는 Django Session 인증의 여러가지 기능들을 차근차근
하나씩 살펴보고 구현해 볼 수 있도록 하겠습니다
인증은 유저가 누구인지를 증명하는 과정입니다
인증은 크게 세 가지로 분류할 수 있습니다.
사용자가 알고 있는 것.
사용자는 사용자 명과 비밀번호를 알고 있습니다.
이는 가장 기본적인 인증 방법으로써 사용자는 자신이 누구인지 증명하기 위해 사용자 명과
비밀번호를 입력하죠.
대개의 서비스들이 사용하는 인증 방법입니다.
두 번째로, 사용자가 가지고 있는 것.
사용자는 스마트 카드나 디바이스를 가지고 있습니다.
이 방법은 유저가 무언가를 소유하고 있는 것을 통해 사용자를 인증합니다.
세 번째, 사용자의 생체 정보.
사용자는 지문과 같은 고유한 생체 정보를 가지고 있습니다.
생체 인식 기능은 사용자의 유일한 생체 특징을 스캔하여 인증하고요.
이는 고유한 신체적 특징을 통해 사용자를 식별하는 방법입니다.
스마트폰에서 지문 인식이나 얼굴 인식을 많이 사용하고 있죠.
참고로 MFA가 있습니다.
이는 두 가지 이상의 인증 방법을 동시에 사용해서 보안성을 높이는 방법인데요.
해커가 여러 개의 인증 정보를 동시에 알아내기는 매우 어렵습니다.
예를 들어, ID 암호 인증 후에 2단계 인증으로써 이메일이나 휴대폰으로 전송된 인증
코드를 추가 입력하는 방식으로 인증을 완료합니다.
이렇게 하면 누군가가 여러분의 아이디 암호를 알아내더라도 그 다음 단계에 인증 코드 없이는
접속할 수 없게 되는 거죠.
Django에서는 기본 앱인 Auth 앱을 통해서 아이디 암호를 통한 세션 인증을 지원해
줍니다. 물론 아이디를 이메일 포맷으로 입력 받으실 수도 있어요.
아이디 암호를 통한 로그인, 회원가입, 로그아웃, 암호 변경, 암호 재설정을 직접 구현해
보며 인증에 대한 이해도를 높여 봅시다.
유저 모델에서는 암호를 해싱하여 해싱된 문자열을 패스워드 필드에 저장합니다.
절대 암호 평문을 패스워드 필드에 저장하지 않습니다.
즉, 데이터베이스에 암호 평문이 아닌 해싱된 암호를 저장한다는 거죠.
해싱은 어떤 입력 값에 대한 고정된 길이의 해시 값을 생성하는 과정입니다.
입력 값에 대해 항상 동일한 해시 값을 반환합니다.
해시은 데이터의 무결성 검증, 비밀번호 저장, 데이터의 고유 식별 등에 사용됩니다.
암호를 변경 시에 PD 유저 모델의 setPassword 메서드를 통해 암호를 해시하여
패스워드 필드에 저장하고 로그인 시에 로그인 암호의 매칭 여부는 checkPassword
메서드를 통해서 입력된 암호를 해시하여 해시된
문자열 간의 동등 비교로 암호 매칭 여부를 확인합니다.
해싱에 사용되는 알고리즘은 단방향 해싱 알고리즘이기 때문에 역산하여 원본 암호를 복구할 순
없습니다 패스워드 필드에 저장된 문자열은 달러 문자를 구분자로 해서 4개 영역으로
나뉘는데요 순서대로 해싱 알고리즘 이름, 해싱 횟수, 솔트 문자열, 해싱된 문자열입니다
PBKDF2 SHA-256 알고리즘은 장고 버전 1부터 기본 변환 알고리즘으로 채택되었고요.
PBKDF2 알고리즘은 설정된 반복 횟수만큼 해싱을 수행하여 해싱 시간을 고의로 지연시켜
공격자가 비밀번호를 추측하거나 크랙하는데 필요한 시간을 고의로 늘려서 공격을 더 어렵게
만들기 위함입니다.
이를 통해 한 번의 새 패스워드 함수 호출에서는 수십 밀리 초 정도의 시간이
소요되었지만 가능한 모든 비밀번호 조합을 시도하는 해커에게는 공격의 효율성이 크게 저하될
것입니다. 하지만 컴퓨터 성능이 향상됨에 따라 해싱 속도도 점점 빨라지고 있습니다.
이에 대응하여 장고는 버전이 올라갈수록 해싱 반복 횟수의 기본값을 올리고 있습니다.
예를 들어 장고 1.4에서는 1만, 2.0에서는 10만, 3.0에서는 18만, 4.0에서는
32만, 그리고 4.2에서는 60만이 기본값으로 설정되어 있습니다.
서버의 처리 능력에 따라 이 값을 조절할 필요가 있을 수도 있죠.
이 경우, PBK-DF2 패스워드 해셔 클래스를 상속받아 새로운 클래스를 정의하고,
Iterations 속성에 원하는 반복 횟수를 지정한 후, settings에 패스워드 해셔
리스트 설정에 첫 번째 값으로 재정의한 클래스 경로를 지정하면 됩니다.
첫 번째 해싱 알고리즘이 디폴트로 사용됩니다.
Cert 문자열은 비밀번호에 추가적으로 더해지는 무작위 문자열입니다.
Cipher Sword 메서드를 호출할 때마다 매번 새로운 Cert 문자열이 랜덤하게
생성되거든요.
그래서 같은 비밀번호라 하더라도 다른 해시값이 생성됩니다.
레인보우 테이블 공격 같은 해킹 공격을 방어하는 데 도움을 줍니다.
유저 모델의 데이터베이스 테이블의 패스워드 컬럼을 살펴보시면, 해싱된 패스워드 값을
확인하실 수 있습니다.
구분자로 달러 문자열이 있구요,
해싱 알고리즘, 해싱 횟수, 썰트 문자열, 최종 해신된 문자열이 하나의 컬럼에 저장되어
있습니다. 패스워드 컬럼 값이 느낌표로 시작하는 레코드는 암호로 인증이 불가능한 문자열
패턴으로 설정된 암호이고요.
setPassword 메서드 후출 시에 인자를 non으로 지정하면 암호로 인증이 불가능한
문자열 패턴으로 저장이 됩니다.
창고 셀을 열고 첫 번째 유저 레코드에 대한 모델 인스턴스를 생성했습니다.
패스워드 속성 값을 보니 저는 느낌표로 시작하는 인증이 불가능한 암호로 설정이 되어 있네요
여러분들은 아마 PBK, DF2 문자열로 시작하실 겁니다
지금 패스워드 속성 값을 변경할 테니 이 값의 현재 값은 실습에 진행과는 상관이 없습니다
SetPassword 메서드로 암호를 qwer1234로 변경해 보겠습니다.
그럼 암호 qwer1234 암호를 해싱한 문자열이 패스워드 속성 값에 저장됩니다.
SetPassword, qwer1234 메서드를 한 번 더 호출해 보면, 같은 암호를
지정했음에도 해싱된 문자열이 다름을 확인하실 수 있습니다.
이는 setPassword 메서드를 호출할 때마다 salt 문자열이 매번 랜덤하게
생성되기 때문입니다.
데이터베이스에 저장하시면 이렇게 패스워드 필드에는 구분자로 달러가 있고요.
4개의 영역의 문자열이 데이터베이스에 저장이 됩니다.
유저 암호 인증 시 시에 이렇게 qwer1234 문자열과 직접 비교를 하면 해싱된 문자열과
학문 문자열과의 비교이니 거짓 판정이 되겠죠.
checkPassword 메서드를 활용하시면 인자로 전달된 암호 문자열을 현재 패스워드 속성에 사용된
해싱 알고리즘, 해싱 횟수 문자열을 사용하여 해싱을 수행해서 해싱된 문자열과 같은지 비교를
합니다. 참 판정을 받았으니 암호가 qwer1234가 맞습니다.


이번 강의에서는 Django Session 인증에 대해 여러 가지 기능을 차근차근 구현하고 이해할 수 있도록 설명하였습니다. 주된 내용은 사용자 인증 및 비밀번호 해싱 방식에 관한 것입니다. 이를 요약하면 다음과 같습니다:

1. 인증의 세 가지 유형
사용자가 알고 있는 것: 사용자명과 비밀번호를 통해 인증.
사용자가 가지고 있는 것: 스마트 카드나 디바이스와 같은 물리적 인증 요소.
사용자의 생체 정보: 지문, 얼굴 인식 등 생체 데이터를 통한 인증.
이 세 가지 인증 방법을 MFA (Multi-Factor Authentication) 형태로 결합하여 보안을 강화할 수 있습니다. 예를 들어, 비밀번호와 함께 인증 코드를 추가 입력하는 방식입니다.

2. Django에서의 인증
Django는 Auth 앱을 제공하여 아이디와 비밀번호를 통한 세션 인증을 지원합니다. 이 앱을 사용하면 로그인, 회원가입, 로그아웃, 비밀번호 변경 및 재설정 등을 쉽게 구현할 수 있습니다.

3. 비밀번호 해싱
Django는 사용자 비밀번호를 평문이 아닌 해싱된 값으로 데이터베이스에 저장합니다. 해싱은 입력값에 대해 고정된 길이의 고유한 값을 생성하는 과정으로, 비밀번호를 안전하게 저장하는 방식입니다.

3-1. 해싱 알고리즘: Django는 기본적으로 PBKDF2 SHA-256 알고리즘을 사용합니다. 이 알고리즘은 설정된 반복 횟수만큼 해싱을 수행하여, 공격자가 비밀번호를 추측하는데 드는 시간을 늘려 보안을 강화합니다.

3-2. Salt: 해시 값 생성 시 Salt를 추가하여, 같은 비밀번호라도 다른 해시값을 생성하도록 합니다. 이를 통해 레인보우 테이블 공격을 방지할 수 있습니다.

3-3. 비밀번호 해싱: Django에서는 setPassword() 메서드를 사용하여 비밀번호를 해싱하여 저장하고, 로그인 시에는 checkPassword() 메서드를 통해 입력된 비밀번호와 데이터베이스에 저장된 해싱된 비밀번호를 비교합니다.

3-4. 해시값 구조: 패스워드 필드는 알고리즘$횟수$salt$해싱된값의 형식으로 저장되며, 예를 들어 pbkdf2_sha256$320000$gFs8H...$HS6fg3...와 같은 형태입니다.

4. PBKDF2 알고리즘
반복 횟수: PBKDF2 알고리즘은 해싱을 여러 번 반복하여 공격자가 비밀번호를 추측하는데 드는 시간을 늘립니다. Django에서는 기본적으로 버전이 올라갈수록 반복 횟수를 증가시켜 보안을 강화하고 있습니다.
예: Django 1.4에서는 1만 회, 2.0에서는 10만 회, 3.0에서는 18만 회, 4.0에서는 32만 회, 4.2에서는 60만 회가 기본값입니다.

5. SetPassword와 CheckPassword 메서드
setPassword(): 비밀번호를 입력받아 해싱된 값을 생성하고, 이를 패스워드 필드에 저장합니다.
checkPassword(): 입력된 비밀번호와 현재 저장된 해시값을 비교하여 비밀번호가 맞는지 확인합니다.

6. 비밀번호 변경 예시
비밀번호를 qwer1234로 변경하고 setPassword()를 호출하면, 해싱된 비밀번호가 데이터베이스에 저장됩니다.
같은 비밀번호라도 salt가 달라서 해시값이 달라집니다. 이로 인해 같은 비밀번호라도 매번 다른 해시값을 생성하여 보안을 강화합니다.

7. 데이터베이스에서 패스워드 확인
데이터베이스에서 패스워드 컬럼은 해싱된 값이 저장되며, 이를 달러($)로 구분된 4개의 영역으로 나눕니다:
해싱 알고리즘,
해싱 횟수,
salt 문자열,
해싱된 비밀번호.

결론:
Django에서 제공하는 인증 시스템을 사용하여 비밀번호를 안전하게 해싱하여 저장하고, 로그인 시 해싱된 값을 비교하여 인증합니다.
PBKDF2 알고리즘을 사용하여 보안성을 강화하고, Salt를 사용하여 레인보우 테이블 공격을 방지합니다.
Django에서는 세션 인증 및 비밀번호 해싱을 쉽게 처리할 수 있는 Auth 앱을 제공하여, 보다 안전하고 효율적인 사용자 인증 시스템을 구현할 수 있습니다.