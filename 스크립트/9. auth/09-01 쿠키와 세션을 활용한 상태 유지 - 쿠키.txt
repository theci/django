안녕하세요. 이번 시간에는 장고에서 쿠키와 세션을 활용해서 상태값을 저장하고 유지하는 방법에 대해서 살펴보겠습니다.
커피 전문점에서 커피를 사 먹을 때 스탬프 쿠폰을 매번 가져가서 확인을 받죠.
스탬프 쿠폰을 가져가지 않으면 그곳에서 몇 번이나 구매를 했는지 알 수 없고 10회 적립 시에 무료 커피를 받을 수도 없습니다.
쿠폰을 통해 커피 적립 내역이라는 상태를 기록하고 있는 거죠.
웹브라우징을 할 때 쿠키는 카페의 쿠폰과 같은 역할을 합니다.
카페에 방문할 때마다 쿠폰을 가져가서 커피를 구매하면 스탬프를 받듯이 웹브라우저도 서버로부터 받은 쿠키를 저장해 두었다가 웹사이트에 다시 방문할 때마다 해당 쿠키 정보를 서버로 자동 전송합니다.
이 과정은 쿠키라는 요청 헤더를 통해서 이루어집니다.
서버는 사용자의 행동에 따라 새로운 쿠키를 발급하거나 기존 쿠키를 업데이트할 필요가 있을 때 응답 헤더에 setCookie 헤더를 포함시켜 쿠키 정보를 전달하면 브라우저는 이 쿠키를 저장합니다.
쿠키의 만료 시간도 함께 설정할 수 있고요.
브라우저에 저장된 쿠키는 브라우저가 해당 웹사이트에 요청을 보낼 때마다 쿠키 헤더를 통해 자동으로 전송됩니다.
쿠키는 발급된 도메인에 한해서만 유효하고요.
이는 마치 특정 카페에서만 사용 가능한 쿠폰과 같습니다.
이러한 도메인 제한은 쿠키를 안전하게 관리할 수 있도록 도와줍니다.
쿠키는 서버와 클라이언트 간의 정보를 공유하고 교환하기 위한 데이터 구조와 저장 방식입니다.
웹사이트로 보내는 모든 요청에서 쿠키는 자동 전송되는데요.
웹사이트 방문, 웹페이지 새로고침, 링크 클릭, 자바스크립트를 통한 HTTP 요청 모두에서 쿠키는 자동 전송됩니다.
장고 뷰에서는 요청 헤더에 쿠키 이름의 문자열에 여러 쿠키 값들이 저장되어 있는데요.
쿠키스 이름의 사전을 통해 쿠키 내역을 제공합니다.
쿠키스 사전은 쿠키 조회용 사전일 뿐이고요.
이 쿠키스 사전 값을 변경하더라도 브라우저의 쿠키 값에는 반영되지 않습니다.
브라우저와의 쿠키 값 추가 변경을 위해서는 뷰 응답 객체의 setCookie 메서드를 사용하시면 되는데요.
setCookie 메서드를 통해 설정된 쿠키 값은 유저가 브라우저의 개발자 도구를 통해 손쉽게 바꿀 수 있습니다.
만약 유저의 쿠키 값 변경을 막으려면 setSignedCookie 메서드를 통해 쿠키 값을 서명된 쿠키도 생성하실 수 있고요.
서명된 쿠키는 브라우저 단에서 값 확인은 가능하지만 값 변경은 불가능합니다.
setCookie의 첫 번째 인자로 변경할 쿠키의 이름과 두 번째 인자로 값을 지정합니다. 
추가로 만료 시간인 MaxAge 인자와 Expires 인자를 지정할 수 있고요. 
쿠키가 유효한 도메인을 지정하는 Domain 인자, HTTPS 프로토콜에서만 쿠키가 설정되는 Secure 인자, 다른 사이트로부터의 요청에서 쿠키 전송에 대한 정책을 지정하는 Same Site 인자를 지원합니다.
브라우저에서는 document.cookie 문자의 속성을 통해 브라우저의 쿠키 내역을 확인할 수 있는데요 
쿠키 생성 시에 HttpOnly 옵션이 설정된 쿠키는 자바스크립트를 통해서는 조회할 수 없고요 
브라우저의 개발자 도구로는 모든 쿠키를 확인하실 수 있습니다
쿠키는 브라우저의 개발자 도구 내 애플리케이션 탭에서 확인하실 수 있으며 이곳에서 쿠키의 값을 직접 수정할 수도 있습니다
웹에 대한 기본적인 지식만 있다면 유저가 직접 쿠키 값을 변경하는 것은 쉽습니다
커피 적립 횟수를 10으로 수정한다면 바로 무료 커피를 받을 수 있을 것입니다.
이런 이유로 커피 적립 횟수와 같은 정보는 쿠키에 저장하는 것은 적절하지 않습니다.
쿠키에 저장하기 적절한 예시로는 사용자 선호 언어, 테마 설정, 장바구니 정보, 최근 검색어, 최근 본 상품, 광고 추적 아이디 등이 있습니다.
이들은 대부분 민감하지 않은 사용자의 선호나 상태 정보입니다.
적립 횟수를 서버에 저장하는 것은 어떨까요?
서버 메모리에 한번 저장해 보겠습니다.
서버 메모리에 저장하면 이제 유저가 적립 횟수를 임의로 변경할 수 없습니다.
그런데 현재의 코드는 고객 A의 적립이 고객 B도 같이 적립이 돼요.
전역 변수는 현재 Python 프로세스 내에서 공유되기 때문이죠.
고객 A와 고객 B를 식별해서 따로 카운트 해야겠습니다.
고객 A와 고객 B를 식별하는 식별자로서 IP를 사용해 볼 수 있습니다
하지만 두 고객의 IP가 같다면 적립 횟수는 같이 개선될 것이고요
또한 고객의 IP 주소가 변경되면 적립 횟수는 0부터 다시 시작되는 문제가 발생합니다
이번에는 휴대폰 번호를 식별자로 사용해 보겠습니다.
적립할 때마다 휴대폰 번호를 입력 받도록 했고요.
이제 IP가 바뀌어도 휴대폰 번호만으로 적립을 받을 수 있게 되었습니다.
하지만 매 적립 시마다 휴대폰 번호를 입력해야 하는 번거로움이 있네요.
유저가 스탬프를 10번이나 찍었습니다.
이제 무료 커피 쿠폰을 신청할 수 있게 되었어요.
무료 커피 쿠폰 신청 링크를 클릭해서 해당 페이지를 방문하니 현재 페이지에서는 이전 페이지에서 입력받았던 휴대폰 번호를 알 수 없기에 쿠폰 사용을 위해 휴대폰 번호를 다시 입력해야만 합니다.
많이 번거롭죠?
HTTP에서는 다른 페이지와 상태를 공유하기 위해 쿠키를 사용할 수 있는데요.
스탬프 적립 시에 쿠키의 휴대폰 번호를 기록하도록 했고요.
무료 커피 페이지에서는 휴대폰 번호 추가 입력 없이도 쿠키에서 휴대폰 번호를 조회할 수 있게 되었습니다.
새로운 카페 앱을 생성하고, 카페에 urlspy 파일도 생성해주고요.
mysite의 urls.py 파일에서도 prefix를 지정하고 include를 해줍니다.
현재 Settings의 Installed Apps List에 카페 앱을 아직 등록해 주지 않았는데요. 
카페 앱에서는 현재 모델도 없고 템플릿도 없기 때문에 카페 앱 등록 없이도 urls에 맵핑된 뷰 함수 호출은 됩니다.
커피 스탬프 뷰 함수를 구현하겠습니다.
보다 간결한 예시를 위해 HTTP 리스판스 객체를 직접 생성해서 HTML 문자열을 직접 지정했지만 템플릿 시스템을 활용하셔도 됩니다.
GET 요청에서 입력 폼 HTML을 응답하겠고요.
input 요소에서는 name이 폰 이름으로 휴대폰 번호를 포스트 방식으로 전달받을 겁니다. 
urspy 파일에서도 뷰 함수를 맵핑해 줍니다.
localhost:8000 카페의 주소를 열어서 적립받을 휴대폰 번호를 입력해 보면 CSRF 검증 실패 오류 메시지가 뜨네요.
Django 프로젝트 기본 설정에서는 포스트 요청에서 항상 CSRF 토큰을 검사하죠.
현재는 템플릿 시스템을 활용할 것이 아니기에 CSRF 토큰 템플릿 태그를 사용할 수 없어요. 
간결한 실습을 위해 CSRF EXEMPT 장식자를 뷰에 적용하겠습니다.
서비스에서는 절대 CSRF_EXEMPT 장식자를 폼 처리에 적용하지 마세요.
이제 포스트 요청을 뷰에서 받을 수 있게 됩니다.
포스트 데이터에서 폰 휴대폰 번호를 입력받아서 적립 횟수에서 값을 꺼내어 횟수를 1 증가시키고 다시 저장합니다.
응답에는 적립 횟수를 포함시킬게요.
휴대폰 번호를 입력하고 전송하면 적립이 잘 됩니다.
이제 무료 커피를 제공할 커피 프리뷰를 만들어 보겠습니다.
커피 프리뷰에서는 무료 커피를 제공할 휴대폰 번호를 어떻게 알 수 있을까요?
카페의 urls 파일에도 뷰 함수를 등록하고요.
무료 커피 페이지를 방문해 보시면 페이지나 파운드가 뜨네요.
프리 커피 주소 끝에 슬러시를 제가 빼먹었네요.
브라우저에서의 요청 주소가 서로 맞지 않았었습니다.
주소를 맞춰줍니다.
적립을 할 때 쿠키의 휴대폰 번호를 한 번 저장해 두면 브라우저에서는 매 요청마다 쿠키로 휴대폰 번호를 전송합니다.
그러니 커피 프리뷰에서는 이제 쿠키에서 휴대폰 번호를 조회할 수 있습니다.
조회된 휴대폰 번호가 없으면 적립 페이지로 이동을 시킬게요.
적립 횟수가 10회 이상일 때 무료 쿠폰을 사용할 것인지를 묻도록 합니다.
잘 동작하네요.