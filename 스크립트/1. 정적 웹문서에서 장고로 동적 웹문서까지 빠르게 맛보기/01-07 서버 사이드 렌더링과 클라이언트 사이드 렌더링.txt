서버 사이드 렌더링과 클라이언트 사이드 렌더링입니다.
흔히 서버 사이드 렌더링, 즉 SSR이라고 하면은 요즘 리액트계의 Next.js를 많이 떠올리시는데요.
전통적인 웹 프레임워크의 응답도 서버 사이드 렌더링입니다.
즉 서버에서 이런 HTML을 다 작성해서 내려주면은 브라우저가 그대로 해석해서 보여주기만 하잖아요 
그쵸 그래서 서버에서 필요한 처리를 다 하는 것을 서버 사이드 렌더링 이라고 합니다 
우리가 앞서 작성을 한 거죠
그에 반해 CSR 즉 클라이언트 사이드 렌더링 이라고 한다면은 뷰와 함수는 똑같아요
템플릿 단에서 HTML을 만드는 게 아니라 UI 생성이 필요한 데이터만 만듭니다
이렇게만 쓰면은 실제 생성되는 HTML은 이렇게 JSON 코드로 JSON 데이터로 이렇게 만들어집니다 
이 데이터를 UI에 바로 뿌릴 수 있는 거 아니거든요
이거는 그냥 데이터일 뿐입니다
그리고 추가로 JavaScript 코드만 넣어줬습니다
이 코드가 브라우저 단으로 내려가서요 초기 응답에서는 이렇게 아무것도 없는 거죠
없는 상황인데 브라우저가 이 코드를 실행하면은 하면은 이 데이터를 해석해서 UI를 구성하는 겁니다 
클라이언트 단에서 UI를 만들었죠
이것이 CSR 입니다
서버에서는 HTML이 아니라 이렇게 JSON 데이터 즉 데이터만 응답하는 view함수를 따로 만들 수 있어요
이렇게 만들면은 우리가 index 함수에서는 데이터베이스 조회하는 거 아무것도 없습니다
템플릿 단에서는 패치라는 JavaScript API가 있어요
그걸 활용해서 앞서 본 이 데이터를 요청하는 거예요
그러면 이 패치가 제 손 응답을 받죠
응답을 받아서 이제 UI를 구성해서 뿌려주는 겁니다
그러면 CSR 첫 번째는 이 자바스크립트와 데이터가 같이 있었지만 두 번째는 이 데이터는
이 자바스크립트 없고 별도 요청을 통해서 데이터를 받아와서 뿌려주는 거죠
이 방식도 처음에는 UI가 비어져 있다가 여기에서 데이터 받아와서 UI를 구성하게 되면
이렇게 UI가 만들어집니다
별도 API들 웹 프론트 엔드 단에서 JavaScript가 API 호출을 해야 되니까 로드 목록 데이터 로딩이 필요하니 CSR1 보다는 약간 느린 렌더링이에요
자 화면에 보여지는 것은 ssl 처음이 제일 빠릅니다
여러분 그쵸 제일 빨라요
왜냐하면 서버에서 받자마자 뿐이니까 제일 빠릅니다
마지막으로 ui 를 구성하는 것을 자바스크립트 기본, 즉 Vanilla JS 라고 하는데요
기본 자바스크립트만으로 구성했던 것을 ui 를 리액트 코드를 쓸 수 있습니다
그래서 우리 웹페이지에서 리액트 자바스크립트 라이벌리스트 이렇게 추가를 하고요 추가하고
이렇게 컴포넌트를 쓰고 songlist라는 컴포넌트를 id가 songlist 테이블인 요소에 있는 티바디 요소에다가 이 컴포넌트를 렌더링 하겠다라고 해주면은 UI가 똑같이
그려집니다 그렇죠
이렇게 코드 쓰는 것을 이렇게 쓴 거에요
코드는 좀 길어 졌지만은 React를 쓰면은 좀 더 복잡한 UI를 구조적으로 잘 구성할 수 있다는 장점이 있는 거죠
CSR 첫번째 예시부터 한번 실습을 해 보겠습니다
일단 템플릿부터 열고요 
이제 테이블 태그에다가 아이디로 songlist_table 이라고 하나 넣어주겠습니다
이렇게 넣어주고요
tbody 에서 여기 내부 내용은 다 지우겠습니다 새로고침 해보시면 아무것도 없죠?
song list 잖아요
이렇게 넣어주시면 화면은 이렇게 보이십니다
쿼리셋 타입이죠
우리가 자바스크립트에서 이 데이터를 활용을 해야 되거든요
그래서 json script라는 이름에 템플릿 태그라고 합니다
이 문법도 잔고 템플릿 문법이에요
그래서 script라는 템플릿 필터를 호출하면은 첫번째 인자로 이 값이 넘어가고 두번째 인자로 이 값이 넘어갑니다
여기에 제가 songlist 데이터도 주겠습니다
그리고 새로 고침하면 오류가 나는데 코디 셋 타입의 객체는 제 손으로 직렬할 수 없다는 부분이 있습니다
song list data는 list 이렇게 해줍니다
코디 셋을 list 타입으로 변환한 거예요
여기 두 개도 변환해 주시면 이렇게 해주시고 songList를 songList data로 바꿔줍니다
그리고 새로고침 해보시면은 제가 코드 하나 빼먹었네요
여기에 이제 values까지 넣어주겠습니다
이렇게 넣어주시면은 자 이렇게 변환 가능한 형태로 변환한 것이고 페이지 소스 보기에 보시면은 이렇게 script 태그로 id는 songlist.json 즉 제가 템플릿에서
지정한 이름이죠
이름이고 type은 application/json이고 json 문자이디 이렇게 쭉 들어가 있습니다 
그쵸 자 데이터에요 데이터 그럼 이 데이터를 제가 JavaScript로 읽어서 뿌려줄 거에요
그래서 script 태그를 써주시고 여기에서 제가 document.querySelector라는 걸 활용해서 id가 songlist.json인 DOM 요소, 요소, element라고 하죠
요소를 참조하는데 그 스크립트 안에 있는 내용이 필요하잖아요
내용이니까 내용은 점 텍스트 컨텐트라고 합니다
이 자체가 뭐냐면 제이손 문자예요
즉 제이손 스트링입니다
그럼 JSON 스트링을 한번 출력을 해보시면은 자 출력을 한번 해보면은 자 개발자 도구엽니다 
개발자 도구는 여기 클릭에 도구도 보기에 개발자 도구가 있죠
도구의 콘솔 창을 여시고 새로 고침 해보시면은 요렇게 출력이 되요 
자 그 데이터가 보여집니다
근데 우리가 필요한 것은 JSON 스트링이 아니라 문자를 JavaScript 객체로 변환을 해야죠 
변환을 하는 것이 JSON.parse 입니다
이렇게 해주시면 이 값이 이제 song list 가 됩니다 하시고 새로고침 해보시면은 이렇게 자바스크립트 객체화가 되었죠
많이 사용하는 패턴이니까 알아두시면 좋구요
자 우리가 장구강이니까 파이썬 익숙하니까 제가 리스트하고 있지만 자바스크립트에서는 배열 즉
Array라는 타입입니다
그래서 Array에서는 for which라는 펑션을 지원하고요 여기에 함수를 등록합니다
그러면 그 함수 여기부터 여기까지가 함수에요 함수의 인자고 함수의 구현입니다
이 문법은 자바스크립트의 화살표 함수 arrow function 이라고 합니다
이렇게 되고 그러면 매 송마다 배열이니까 각각의 이 송 즉 오브젝트죠
파이썬으로 따지면 사전입니다
이렇게 넘어오구요
그럼 song.id, song.가수, song.곡명으로 접근하실 수 있겠구요
이제 티바디 안에다가 넣어 줄 것이기 때문에 자 document.createElement
즉 tr 요소를 하나 만들어 두고요 tr에 이제 inner html 로 자 backtick
입니다 호딴표 아니에요
호딴표와 backtick은 다릅니다
백틱은 열어줄 문자열을 정의하는 거고요 문자열인데 이렇게 색깔이 문법 강조가 되는 것은
타이참이 지원해 준 기능인 거예요
여기까지는 열어줄 문자열입니다
문자열이고 여기에다가 song의 곡명인 거죠
자 이렇게 쓰셔도 되고 이렇게 써도 됩니다
자바스크립트는 둘 다 지원합니다
이렇게 써주시고 곡명하고 가수라고 써줍니다
이렇게 쓴 문법은 Python의 f-string 문법하고 비슷한 거예요
이렇게 쓰시고 다음에 document.querySelector에서 id가
song,list,table이 있고 그 안에 있는 tbody에다가 append,tr을
추가해 주겠다죠
여기다가 추가를 해줍니다
그리고 새로 고침하시면 이렇게 추가가 됩니다
SSR 방식의 페이지와 UI는 같지만은 UI를 처리하는 방식이 다른 거죠
자 지금 보신 코드가 CSR 첫번째 방식입니다
웹 API 를 한번 구성을 해 보겠습니다.
index view 함수 외에 song list API 라는 view 함수를 따로 구성하는
거에요. index 에서 제가 여기 있는 코드를 복사합니다.
복사해서 그대로 주석을 하겠구요.
이 부분도 주석을 하겠습니다.
그러면 이제 데이터 조회하는 게 하나도 없죠.
랜더만 남았습니다.
그리고 SongList API라는 함수를 하나 만들고요.
여기에다가 아까 복사한 코드를 붙여 넣습니다.
그리고 아까 코드도 그대로 써 주겠습니다.
SongList 데이터에서 그리고 JSON Response라는 게 있어요.
뭐냐면 어떤 데이터를 또 JSON으로 직렬화를 해서 응답을 내주는 코드입니다.
아까 여기 JSON 스크립트도 이 값을 JSON으로 직렬하는 코드가 들어갔는데 여기도
JSON 직렬을 하기 때문에 제가 요 과정이 한 번 더 들어간 거에요
자 JSON Response Alt + Enter 눌러서 django.http JSON Response
import 해주시고 첫번째 인자로 song_list 데이터 즉 응답으로 줄 데이터를 써주고요
safe=False 라고 써주고 json dumps params 라고 해서 여기에는
insure ascii 거짓 이라고 씁니다
그리고 이제 컨텐트 타입은 application/json 이라고 쓰고 여기에 추가로
데이터의 인코딩까지 써주는 게 웹표준에 좀 더 맞아요
저장하시고 이 view 함수가 호출되기 위해서는 url 맵핑이 필요하거든요
내려보시면은 위에 urlpatterns라는 이름의 list에 path라는 이름의 인자가
하나가 있는데 아무것도 없는 문자일이죠
아무것도 없는 주소이기 때문에 이 주소 즉 이 서버로 바로 접근했을 때에 이
index함수가 호출되는 거고요
두번째는 뭘 쓰냐면 api에 songlist.json이라는 주소로 들어오면 songlist
api로 호출하겠다
여기서는 인덱스 뷰에서는 인자 다 빼줍니다
됐죠 그러면은 여기도 지금 코드가 의미가 없는 거죠
그쵸 왜냐면 이 데이터 자체가 없으니까 자 개발자 도구 열어보면은 이렇게 오류가 나 있네요
그쵸 song list인데 이 순에 돌렸는데 이 자체가 지금 배열이 아닌 거예요 배열이
아니기 때문에 for which가 함수가 아니다
이런 오디오가 뜬 상황입니다
아까 우리가 주소가 api의 songlist.json 이잖아요
이 주소를 슬러시하고 입력해 보시면 이렇게 응답이 오죠
저는 이런식으로 구조화된 형태로 보여지는데요
이런 형태로 보여지는 것은 크롬을 쓰시면은 jsonview 라는 크롬 확장을 설치하시면
되요 링크 클릭하시면 바로 설치하실 수 있구요 이 확장에 설치가 안되어 있으면 이렇게
보여집니다 이것이 원본 데이터인 거고 확장이 좀 스타일링해서 이쁘게 보여지는 것입니다
자 이번에는 CSR 두번째 예시입니다
앞서 JSON API를 만들었구요 그 JSON API 데이터를 JavaScript를
활용해서 로딩해서 UI에 뿌려주는 걸 만들어 보겠습니다
자 인덱스 함수에서는 템플릿에서 사용할 수 있는 값을 넘긴 게 없죠
그러니까 이 코드는 의미가 없습니다
데이터를 로딩해야 되잖아요
일단은 요 부분은 주석을 하겠습니다
패치라는 api 가 있습니다
주소로 api song list json 이라고 합니다
이렇게 den 이라는 함수를 통해서 그 응답을 받는데요
우리가 json path 를 한번 해주잖아요
그런 역할을 패치에서는 response.json 을 통해서 변환하실 수 있어요
자 그럼 변환된 값을 다시 받아 옵니다
여기에서는 이제 song list 가 되는 거에요
그럼 송 리스트가 이 부분이죠
이 코드를 그대로 가져와서 여기다가 붙여넣습니다.
새로고침 한번 해보시면은 요렇게 보여지죠
데이터는 없고 자바스크립트 코드만 있어요
그리고 화면에서 새로고침 해보시면은 요렇게 보이십니다
그렇죠 개발자 도구에서 네트워크 탭이 있습니다
patch xhr 클릭하신 다음에 새로고침
한번 해보시면은 한계가 있어요 클릭해 보시면 해당 주소로 자바스크립트가 따로 요청한 내역을
필터링해서 볼 수 있는 거 거든요
해당 주소로 요청을 했고 정상응답을 받았고 미리 보기하면 데이터도 이렇게 보여집니다
자 이번에 CSR 세 번째 예시로서 UI 부분을 이제 리액트 기술을 써서 한번 만들어
보겠습니다 현재 이 코드는 하단에 링크가 있으니까 이 스크립트 태그는 복사해서 쓰시면
되겠어요 슬라이드 하단에 코드가 여기 보여지고 있구요
이 세 줄의 코드를 복사하겠습니다
복사해서 여기에다가 붙여 넣을 거구요
패치 코드는 일단은 주석을 할게요
scraped 태그를 하나 추가하겠습니다
타입은 text/babel 이라고 줄 텐데요
이렇게 주시고 여기에 function songlist 라는 이름의 react 컴포넌트를
하나 구현할 거에요
그냥 리턴 한번 해볼까요
이렇게 쓰시면은 이제 곡 목록이라고만 써주고요
여기 다음에 react dom. 렌더라고 써주고 첫번째 인자로 songlist 다음에
document.querySelector 에서 이렇게 주시면은 id가 songlist
테이블인 티바디 안에다가 이제 우리가 UI를 그릴 겁니다
이렇게 쓰시고 웹페이지 새로고침 하시면 공목록 이라고 보여지죠
자 방금 우리가 리액트 기술로 UI를 한번 그려본 거에요
여러분 공목록 1 이라고 쓰고 저장하고 새로고침 해보셔도 정확하게 보여집니다
그쵸 자 그러면 이 React 컴포넌트가 처음에 화면에 그려질 때 딱 한 번만 우리가 이
데이터를 요청해서 화면에 반영하잖아요
그래서 그걸 하기 위해서 useEffect라는 함수가 있겠구요
첫번째는 함수를 주고 두번째는 빔 베어를 줍니다
주시면은 이 함수는 이 React 컴포넌트가 화면에 보여질 때 딱 한 번만 오출되는 거예요
자 보여지고 호출이 될 때에 앞 뒤에서 쓴 이 코드를 수행을 합니다
자 패치 코드죠
패치 코드를 수행합니다 수행을 해서 song list라는 배열을 받아오죠 받아오는데 화면에
보여지는 이 코드는 우리 Vanilla JS 코드 잖아요
이 코드는 빼시고요
빼시고 이 데이터가 있어요
그럼 이 데이터를 리액트를 통해서 보여줄 때에 리액트에는 상태값이라는 게 있는데 지금은 못
오셔도 돼요 그냥 한번 따라서 맛보기 하는 겁니다
song list라는 게 있고 set song list라는 게 있는데 리액트의 상태값을
참조한 이름이고 설정하는 함수인데요 좀 이름이 같으니까 헷갈리죠
그래서 여기는 언더바 앞에 붙여주겠습니다
이렇게 붙여주시고 여기에서 이제 값을 얻었으니까 setSongList를 통해서 함수를
통해서 이 값으로 상태값을 변경을 해줍니다
됐어요 그럼 지금 새로 고침을 해보셔도 화면에는 바뀐 것 없지만은 네트워크 탭을
열어보시면은 이렇게 요청이 가는 건 볼 수 있어요
지금 리액트를 통해서 요청이 가고 있겠구요
자 그럼 화면에 이제 뿌려 줄 텐데 이렇게 코드 블럭을 하나 만들어 주시고 자 우리가 송
리스트를 순회 돌면서 맵이라는 함수는 이 배열의 순위를 도는데 각각의 값마다 이 함수를
호출하고 그 함수의 반환값으로 이루어진 새로운 배열을 만듭니다
그러면 이 배열에서 한국식 정보를 받아오는 부분이 되겠구요
여기에서 함수입값을 리턴합니다
tr를 리턴할 거고 여기에 곡 제목이 아니라 여기에 우리가 곡명이 있고 여기가 이제
가수가 있죠 이렇게 해주시고요
키라는 부분인데 요 부분은 리액트에서 설명을 드릴 거에요
일단은 이렇게 지정을 해주세요 하시고 새로 고침하시면은 UI가 보이십니다
됐죠? 자 여러분들이 지금 리액트 활용해서 동일한 UI를 구현을 해보신 것입니다
리액트를 처음으로 해보신 거에요
리액트의 세상에 오신 걸 환영합니다
앞서 살펴본 모든 렌더링 방식은 계속 사용되어지는 방식입니다
패션이나 기술 모두 트렌드가 돌고 돕니다
트렌드만 쫓지 마시고 다양한 기술 라이브러리들 쓰는 재미가 있더라도 곧 백화점식 진렬이 개발
속도를 발목을 잡을 수 있어요 단순히 최신 트렌드를 쫓기보다 기술을 깊이 이해하고 조직과
서비스에 적합한 기술을 선택하는 것이 중요합니다



이 내용은 서버 사이드 렌더링(SSR)과 클라이언트 사이드 렌더링(CSR)에 대한 설명과 그 구현 예시를 다룹니다. 주요 개념을 정리하자면:

1. 서버 사이드 렌더링 (SSR)
SSR은 서버에서 HTML을 완성하여 클라이언트로 전달하는 방식입니다.
서버는 클라이언트 요청에 대해 필요한 모든 HTML을 생성해 응답으로 보내고, 브라우저는 그 HTML을 바로 렌더링하여 화면에 표시합니다.
장점: 서버에서 완성된 HTML을 받아 바로 렌더링하므로 초기 화면 로딩 속도가 빠릅니다.
단점: 매번 서버에서 HTML을 다시 생성해야 하므로 서버에 부담이 크고, 동적 콘텐츠를 처리하기 어렵습니다.
2. 클라이언트 사이드 렌더링 (CSR)
CSR은 서버가 HTML을 완전히 제공하지 않고, 데이터를 JSON 형태로만 전달합니다. 클라이언트(브라우저)에서 JavaScript로 UI를 구성하는 방식입니다.
초기 로딩 시 HTML은 비어있고, JavaScript가 데이터를 받아 UI를 구성합니다.
장점: 서버 부담이 적고, 클라이언트에서 동적으로 데이터를 갱신하거나 UI를 조작할 수 있습니다.
단점: 초기 화면에 아무것도 표시되지 않고, 클라이언트에서 데이터 처리 후 UI가 구성되므로 초기 렌더링 속도가 느릴 수 있습니다.
3. CSR 구현 예시
첫 번째 예시:
클라이언트에서 JSON 데이터를 받아와서 UI를 동적으로 구성하는 방식입니다.
서버에서 제공한 JSON 데이터를 JavaScript로 파싱한 후, document.createElement로 HTML 요소를 생성하여 UI를 구성합니다.
두 번째 예시:
API 호출을 통해 JSON 데이터를 받아오고, 이를 클라이언트에서 렌더링합니다. 이때 데이터를 요청하는 과정이 추가되어 초기 렌더링 속도가 느려질 수 있습니다.
세 번째 예시:
React를 사용하여 클라이언트 사이드에서 UI를 구성합니다.
React의 useEffect 훅을 사용해 컴포넌트가 처음 렌더링될 때 API를 호출하고, 데이터를 받아 UI를 업데이트합니다.
React를 사용하면 컴포넌트 기반으로 UI를 더 쉽게 관리하고, 상태(state)를 활용하여 UI를 효율적으로 업데이트할 수 있습니다.
4. 서버와 클라이언트 코드 예시
서버 측에서는 JSONResponse를 사용하여 데이터를 JSON 형식으로 반환하고, 클라이언트는 fetch API나 React를 사용해 데이터를 받아 화면에 표시합니다.
결론
SSR은 초기 로딩이 빠르고 SEO(검색 엔진 최적화)에도 유리하지만, 서버 부하가 크고 동적인 페이지 렌더링에 제약이 있습니다.
CSR은 클라이언트에서 동적으로 UI를 구성할 수 있고, 서버 부하가 적지만, 초기 화면 로딩이 늦어질 수 있습니다.
최신 프론트엔드 라이브러리인 React를 활용하면 UI 구성이 더 체계적이고 관리하기 쉬워지며, 클라이언트 사이드에서 데이터를 효율적으로 처리할 수 있습니다.