자 이번 시간에는 데이터베이스를 연동을 해보겠습니다.
SQLite 데이터베이스 파일을 제가 미리 준비해 둔 게 있습니다.
그래서 이 파일을 클릭해서 파일을 다운받으신 다음에 mydjango02 폴더에다가 복사를
해주세요.
복사하시고 나서 PyCharm에서 더블 클릭하시면 이렇게 PyCharm
Professional의 데이터베이스 SQL 지원 기능을 통해서 이렇게 데이터베이스 내용을
보실 수 있겠고요.
혹시 파이참을 사용하지 않으신 분은 VSCode 내에서도 SQLite 확장이 있습니다.
그걸 사용하셔도 되겠고 혹은 DB Browser for SQLite 라는 프로그램이
있어요. 클릭하셔서 받으실 수 있고 여기에 Open Database 메뉴를 통해서 파일을
열심히 하는 데이터베이스 안에 있는 데이터를 확인하실 수 있습니다.
현재 예시는 SQLite 데이터베이스를 기반으로 동작하지만 MySQL, MariaDB,
PostgreSQL, 다른 데이터베이스와 데이터베이스 연결 부분을 빼면 유사한 코드로
동작을 시켜 보실 수 있어요.
mydjango02 폴더에 melon20230906.sqlite3 파일을 이렇게 받아
뒀습니다. 파이참 Professional에서 더블 클릭하시면 이런 창이 뜨겠구요
에스켈라이트3 드라이버가 없다 라고 한다면은 드라이버 다운로드 그 링크가 있거든요
그거를 클릭하셔서 파이참에서의 드라이버를 설치하신 다음에 설치 이후에 연결 확인 연결
테스트를 하시면은 연결 확인이 되었고 ok 하시면은 오른쪽에 있는 두번째 아이콘이
데이터베이스 이거든요
클릭하시면 연결이 보이고 클릭 클릭해서 여시면 테이블 액이 보여집니다
테이블스 혹시 영어로 보이시면은 클릭하시고 새로고침 하시면은 아마 테이블 내역이 보여질
겁니다 이 중에 제가 만든 songs 라는 테이블이 있어요
더블클릭 하시면 이렇게 내역이 보여져요
그래서 현재 데이터베이스에 이렇게 총 100곡의 정보가 들어있구요
이 데이터베이스부터 데이터를 쿼리해서 이 화면에다가 이 DB내역을 보여주도록 하겠습니다
데이터베이스 데이터 조회하기 인데요
python 기본에는 sqlite3 라는 라이브러리가 기본에 포함되어 있어요
그래서 python만 설치되어 있으시면은 별도의 서버나 별도의 드라이버를 설치하지 않아도
이렇게 sqlite3 에 연결해서 sql 코디를 보내서 데이터를 조회하고 조회 결과 받아서
for loop를 통해서 출력하시고 연결 닫고 항상 연결을 열면은 연결을 클로즈 해줘야
됩니다. 해주시면은 이렇게 출력할 수 있습니다.
이 코드를 한번 실습해 보겠습니다.
새 파일을 만들겠습니다.
main02.py 라고 하나 만들어주겠구요.
import sqlite3 가 되겠구요.
연결은 connection은 sqlite3에 연결인데 파일명이 melon 이었죠.
멜론2023-0906.sqlite3 이구요
자 커넥션에 대해서 컷을 넣습니다.
컷을 통해서 이렇게 우리가 어떤 데이터베이스에다가 셀렉트 업데이트나 다양한 이제 쿼리를
수행할 수 있는 거예요
자 송 리스트는 커서점 패치 1이 있고 패치 올이 있는데 패치 1은 한 행만 가져오는
거고요 우리는 이제 전체 행을 다 가져올 거니까 패치 올을 합니다
그러면 한 번에 다 이제 db에서 조에서 python 메모리로 다 읽어온 거예요
그러면 한 곡씩을 이렇게 받아옵니다
제가 변수명을 song_tuple 이라고 지은 이유는 여기에서 받은 값이 tuple
타입이기 때문에 제가 알아보시기 좋으라고 이렇게 쓴 거구요
한번 출력을 해보겠습니다 서버가 켜져 있으면 잠깐 끄시고 python main02.py
라고 실행해 보시면 이렇게 쭉 출력이 됩니다
song_tuple은 투풀 타입이었는데 투풀이면은 각각의 값을 인덱스로 접근해야 되거든요
0 1 2 3 그렇게 접근하면은 인덱스만 봐서는 어떤 값인지 모르잖아요
그래서 db 조회할 때는 투풀로 값을 조회하기보다 사전의 형식으로 값이 조회되면 좋습니다
그래서 현재 코드에서 select 코드를 실행하시고 나서 cursor.description
에서 첫번째 컬럼의 값을 가져오면 그 컬럼의 값이 컬럼명입니다
그러면 song_to_dict 2pd 입니다.
columnNames는 조회한 테이블의 컬럼명을 list로 가지고 있으니까 Python
내에서 지원하는 함수인 zip을 이용하면 각각의 목록에서 값을 하나씩 꺼내 오는 목록을
만드실 수 있어요
첫번째 인덱스 값 첫번째 인덱스 값 꺼내 오고 그 다음에는 두번째 인덱스 두번째 인덱스
꺼내 오는데 그 목록을 이렇게 딕으로 감싸시면은 한번에 사전으로 만들어집니다
데이터베이스 컬럼명이 곡명, 가수였거든요
그러면 제가 song_dict에서 이제 곡명으로 키 접근하고 가수도 키 접근하면 이렇게 내가
원하는 컬럼만 출력하실 수 있는 거죠
훨씬 편리합니다
한번 실습해 보겠습니다
자 Cursor.execute 하시고 나서 Cursor.description 에서 한 행식
받아와서 0번째 컬럼을 이렇게 참조하시면은 이 자체가 ColumnNames 라는 리스트가
됩니다 한번 출력해 볼까요
column names를 출력하고 아래에는 출력하지 않겠습니다
그리고 다시 실행해 보시면 이렇게 출력이 되죠
자 그러면 Dig의 집이었죠?
column names와 song to pool 한행식 이렇게 사전으로 만드는 거예요
이렇게 만들고 song dig을 해보시면은 자, dig으로 한번 출력해보시죠 해보시면은
이렇게 사전으로 만들어집니다
그쵸? 그래서 가수 곡 일련번호고 이 값은 이렇게 데이터베이스의 컬럼명을 그대로 가져온
거예요 가져왔습니다
그러면 이제 송 딕에서 저는 곡명과 그리고 가수를 이렇게 출력을 한번 해봤죠 해볼
수 있죠 출력한거고 이렇게 하셔도 되고 송 딕이 사전이기 때문에 이렇게 song.dig을
쓰시면은 사전의 값을 이렇게 unpacking 해서 넘겨줍니다
그리고 이렇게 곡명 가수 쓰시면은 똑같이 출력이 되죠
이렇게 활용을 해보실 수도 있습니다
자 이번에는 데이터베이스에서 데이터를 검색을 해 볼 텐데요
select query에서 where 절로 조회 조건을 줄 거에요
자 여기에서 우리가 지정한 sql 이라는 문자열은 쿼리인데 우리가 만든 쿼리이지 실제로
동작되는 코디는 아니거든요
실제로 어떤 코디로 수행이 되는지 확인을 하기 위해서
connection.setTraceCallback 함수에다가 인자로 프린트 함수를
넘겨주면은 실제 쿼디가 수행이 될 때 이 함수가 호출이 됩니다.
그래서 이 Execute에서 실행하면은 실행했을 때에 이렇게 select
from...에서 실제 동작하는 쿼리를 우리가 살펴볼 수 있어요.
우리가 검색할 검색어는 악뮤입니다.
데이터베이스에서 조회할 때에 악뮤라는 문자열 아이디 포함이니까 앞과 뒤에 다 %를 붙여주면
이제 악뮤가 포함된 어떤 컬럼에 가수 컬럼과 곡명에 악뮤가 악뮤가 포함이 된 거에요.
오하니까 둘 중에 하나에만 매칭이 되면 되거든요
그래서 가수와 곡명에 악뮤가 포함된 곡만 조회하는 겁니다
자 이 코드를 한번 실행을 해보겠습니다
Query라는 이름의 인자로 검색어를 지정을 해주겠구요
그리고 검색어도 한번 출력을 해보겠습니다
검색을 출력하고 커서 다음에 connection.setTraceCallback을 통해서
실제 Query가 수행이 될 때 함수로 출력도록 했습니다
그리고 파람이라는 이름의 인자로서 앞에 %를 붙여서 검색어를 이렇게 조합을 합니다.
그리고 SQL이라는 이름의 문자로 이렇게 앞서 준비한 코디를 그대로 실행을 하겠습니다.
fstream 문법이고요.
그리고 SQL을 실행하겠습니다.
추가로 이제 사이즈를 한번 출력했었네요.
list-size는 길이로 해서 이렇게 출력을 해보면은 검색어 악뮤를 통해서 select
from songs where 악뮤가 가수에 포함이 되었거나 곡명에 악뮤가 포함이 되었거나
해서 총 행의 개수는 3개고 잘 출력이 되었습니다
SQL Injection 공격 방어하기 인데요
우리가 검색어 부분을 제가 그냥 악뮤가 아니라 뭔가 SQL 코드스러운 뭔가 코드를 넣었어요
자 현재 이 서비스의 취약점을 아는 유저는 검색어를 이렇게 입력할 수도 있습니다
이렇게 입력 하잖아요
아래 코드 똑같죠
실제 수행이 되면 뭔가 엉뚱한 검색어니까 노래가 하나도 검색이 안 되어야 될 것 같지만 총
100곡이 검색이 됩니다
이 실제 수행되는 코드에다가 SQL 언어에 대한 문법 강조를 한다면 뒤에 SQL에서는
하이픈 2개가 주성 문법이거든요
그래서 뒷부분은 실제 해석이 되지 않습니다
자 가수의 1로 끝나면 뒤에 %가 없죠
1로 끝나는 경우 이거나 혹은 1는 1이잖아요
그럼 이거 항상 참이거든요
그래서 이 조건이 항상 참이 되어서 전체 100곡이 수행된 것입니다
이렇게 동작하면 안되고 가수나 공명의 이 문자에 되었기 때문에 0으로 찍혀야 되죠
자 이러한 공격을 SQL 인젝션 공격이라고 웹 서비스에서 흔히 발생하는 해킹 공격 중에
하나입니다 그럼 이를 방지하는 것은 이미 수많은 라이브러리와 장구 기본은 이미 충분히 해킹
방어가 되어 있어요
예 근데 직접 이렇게 SQL 문자를 조합하면은 이런 공격이 취약해지는 건데 어떻게 하냐면
지금 SQL 문자를 f-string 으로 파라미타를 직접 조합했잖아요
이렇게 하지 않고 SQL 문자를 직접 조합하지 않고 인자가 들어갈 부분을
placeholder 라고 하는데 이렇게 물음표가 들어갈 부분 인자가 들어갈 위치만
지정하고 파라미타 준비한 다음에 execute 함수의 두 번째 인자로 플레이스홀더가
2개니까 인자 2개를 넘겨주는 거죠
이렇게 해주면 라이브러리가 알아서 sql 인젝션 공격을 방어를 해줍니다
방어를 해주기 때문에 여기에 수행되는 코디와 여기에 수행되는 코디가 다르죠
그래서 현재 코드는 가수라는 컬럼에 정확하게 이 문자일이 포함이 되었거나 혹은 공명에 이
문자일이 포함이 된 경우로써 동작을 합니다
자 SQL 문법 강조를 하면 이렇게 해석이 되요
그래서 여기가 다 노란색이죠
노란색입니다 그래서 실행을 하면은 리스트 사이즈가 0이 나오는 겁니다
자 검색어 부분을 이렇게 1 홉따옴표 OR 1는 1 띄우고 하이픈 2개 저장했어요
이렇게 하시고 다시 실행해 보시면 100곡이 나왔습니다
현재 SQL 인젝션 해킹 공격에 당한거에요
여러분 그래서 이런 방식으로 옛날 솔루션이나 직접 SQL 문자에도 조합한 서비스의 경우에
이 공격으로 인해서 유저들의 정보들을 이렇게 해킹해서 데이터 유출이나 그런 해킹 공격이
발생을 하게 됩니다
그래서 이를 막으려면 이렇게 직접 SQL 문자에도 조합해서는 안돼요
이렇게 조합해서는 절대 안되고 자 f-string도 안 썼죠?
안 썼고 여기에서 인자가 들어가는 부분만 어떤 표도 안 씁니다.
물음표 그리고 여기도 물음표를 써주고 실행할 때의 두 번째 인자로 이렇게 파라메타를 이렇게
넘겨주시면은 다시 실행하면은 이렇게 SQL 인젝션 공격을 우리가 방어를 한 것입니다