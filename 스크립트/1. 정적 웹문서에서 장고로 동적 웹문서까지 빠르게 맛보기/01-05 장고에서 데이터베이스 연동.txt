자 이번에는 장고에서 SQL 문자를 직접 조합해서 데이터베이스를 조회해 보겠습니다
자 이제 인덱스 함수가 있죠?
그 밑에 제가 getSongList라는 이름의 함수를 만들텐데 인자로 검색을
받아요 문자가 되니까 type도 한번 써볼까요?
이렇게 썼고 메인 공의에서 여기 커넥션부터 클로즈까지를 복사해서 여기에다가 붙여넣겠습니다
아이스크림 라이트 3 임포트를 해주죠
Alt 엔터 해서 해주시고 다 되고요
자 그럼 송 리스트인데 여기에서 있는 값은 튜플이잖아요
이 송 리스트를 패치 부분을 이렇게 바꿔주겠고요
이렇게 바꿔주고 여기 띄어쓰기 빼고 출력하는거 빼겠습니다
이렇게 빼고 제가 따로 songList는 빅리스트 만들어서 songList에다가 append
songdict 이렇게 해서 songList를 반환하는 식으로 이렇게 해볼 수 있죠
자 이 현재 코드에서 새로운 리스트를 만드는데 그 리스트의 값은 매 행마다 이 값이잖아요
그럼 이 문법을 어떻게 고치실 수 있냐면
그 값을 4 앞에 쓰고요 그죠?
콜론 지우고 이렇게 리스트를 이렇게 할당하시면은 이 문법이 리스트 컴플레이션 문법입니다
컴플레이션 문법 이렇게 쓰셔도 돼요
json 부터 해서 이 부분을 제가 빼는 겁니다
이렇게 넣어 주시면 getSongList 함수에 검색을 넣어주고 SongList를 받아와서
보여줍니다 그러면 인덱스 함수가 호출이 될 때마다 매번 getSongList를 통해서
데이터베이스에 접속하고 SQL 수행하고 결과 받아와서 값을 변환하고 그 값을
반환하면 템플릿을 통해서 응답을 주는 거죠.
새로 고침해 보겠습니다.
어? 서버를 구성 안했네요.
python manage.py runserver 하시고 새로 고침해 보시면 나오죠.
이렇게 나옵니다.
자 이제 검색어가 없는 상황에 대해서도 전체 곡이 잘 나오고 있는데요.
인자로 검색어가 빈 문자열인 경우에도 외열 조건적이 수행이 되잖아요.
검색어 없으면은 전체를 수행하는 것이며 where 없이 select all from
songs 까지만 실행되는 것이 데이터베이스 입장에서는 보다 성능에 유리합니다
그래서 if query 즉 검색어가 있다면 이렇게 수행을 하고요 검색어가 없으면은 그냥
cursor.execute에서 SELECT * FROM songs에서 where.jot
없이 수행하도록 하는 거죠.
새로 고침하시면 결과는 같지만 데이터베이스 입장에서는 WHERE 조건이 필요 없으면 안
쓰는 것이 좀 더 성능에 도움이 됩니다.
앞서서는 우리가 SQLite3 라이벌리를 활용해서 직접 연결을 맺고 query 수행하고
연결을 받았죠
이번에는 Django에서 지원해주는 데이터베이스 추상화계층을 통해서 연결을 얻어올 거에요
Django 데이터베이스 추상화계층을 사용하면은 Django가 지원하는 데이터베이스가 SQLite,
MariaDB, MySQL, PostgreSQL, Oracle 그리고 SQL 서버 등 여러
데이터베이스에 대해서 똑같은 코드로 연결을 얻어오고 똑같은 코드로 쿼리를 수행하고 실행할
수 있습니다 앞서 보신 코드는 이런 플레이스홀더 같은 경우는 SQLite 에서만
지원되는 문법이고 다른 BB에서는 조금씩 다르거든요
그리고 우리가 직접 연결을 맺었어야 했습니다
sqlite3를 사용하기 위해서는 databases라는 세팅스를 추가해 주시고요
sqlite3db를 쓰겠다라는 선언을 해 주십니다
이렇게 해 주시면은 우리가 직접 연결을 맺지 않아도요 맺지 않고 연결을 끊지 않아도 됩니다
클로즈도 안 쓰셔도 돼요
그리고 플레이 솔더는 이제 %s를 쓰셔야 돼요
물음표가 아니고 %s를 쓰시면 모든 데이터베이스에 대해서 동일한 코드로 커넥션을 맺고
실행을 하실 수 있습니다
한번 실습해 볼게요
자 코드에서 상단에 import sqlite3 이제 필요 없습니다
필요 없구요
settings 에서 이제 databases 라는 이름의 사전을 넣어 주십니다
첫번째 키로 default 를 넣어 주시는데 databases 가 사전이죠
사전은 여러 개의 값을 담을 수 있잖아요
이 말인즉 장고는 멀티 데이터베이스를 지원해 줍니다
하나의 Django 프로젝트에서 여러 개의 데이터베이스를 설정을 할 수 있다는 거고요
그때 한 개의 DB 엔진만 쓸 수 있는 게 아니에요
하나의 Django 프로젝트에서 MySQL, MariaDB, Oracle,
PostgreSQL, SQLite까지 여러 개의 엔진에 대해서 여러 연결을 정의해 두시면
우리가 원하는 데이터베이스를 지정하시면 장구가 지원해주는 커넥션을 받아서 똑같은 방식으로
sql을 실행하고 그 결과를 받아올 수 있게 됩니다
자 여기에 엔진이란 이름으로 sqlite3죠
3를 쓰겠다 이구요
그 다음에 네임을 써줍니다
이 네임은 뭐냐면 보통 마리아 DB나 MySQL DB에서는 데이터베이스 명인데
SQLite는 파일 데이터베이스이기 때문에 DB명이라는 게 따로 없구요
그 파일 경로입니다
파일 경로에요 우리 아까 SQLite3.connect 에서도 파일 경로였죠
이렇게만 지정을 해주시면 되겠고 connection echo도 필요 없고 close도 필요
없죠 그리고 set_traceback_callback은 SQLite에서만 지원되는 것이기
때문에 하면 안돼요 Connection은 Alt 엔터 눌러서 Import this
name에서 django.db.connection 입니다
이렇게만 하시면 자동으로 장고가 지원해주는 커넥션을 우리가 가져올 수 있는 거고 여기에
물음표 대신에 % 쓰시면 db 종류에 상관없이 수행되는 코드가 되는 거고요
다만 sql 자체는 db에 따라 다를 수 있으니까 sql은 db에 따라서 틀리다면 다르게
지정해 주셔야 되지만 나머지 코드는 db 종류에 상관없이 수행되는 코드가 되겠습니다
저장하시고 다시 실행해 보시면 잘 수행이 되죠
악뮤에 보셔도 잘 수행이 되고 있습니다
자 이번에는 Django ORM인 모델 모델을 활용해서 데이터베이스 조회를 해보겠습니다
Django 모델을 활용하면 직접 SQL을 작성하지 않고 데이터베이스 조회를 할 수 있어요
Django에 Models가 있고요 Models에 Model이라는 클래스가 있습니다
이 모델을 상속받은 이미의 클래스를 하나 만들어줘요
우리가 데이터베이스에 Songs라는 테이블이 있죠
그러니 이 song 클래스의 메타 클래스, 클래스 안의 클래스입니다
메타 클래스 안에 db 언더바 테이블 이름의 속성으로 이 songs라는 테이블명을 줍니다
주면 우리가 song을 활용해서 db 조열을 할 때 이 db 테이블로 조열을 하게 되고
songs 테이블에는 아이디 컬럼, 가수 컬럼, 곡 일련 번호 컬럼 등등등이 있죠
이 중에 순위는 인티저네요 좋아요도 인티저고 인티저고 나머지는 텍스트 텍스트 다 텍스트 입니다
아이디는 인티저 오토인크리먼트 입니다
자 그러면 데이터베이스 테이블 구조에 맞춰서 모델 클래스도 이렇게 정의하는 겁니다.
두 개 맞춰주는 거예요.
맞춰줘야지만 이 모델 클래스에서 생성되는 SQL이 이 DB 테이블에서 동작을 할 수
있겠죠. 그래서 컬럼명을 그대로 써주는 거죠 그대로 써주고 그리고 아까 인티저 였던 필드도
여기 인티저 필드 인티저 필드에서 맞춰주고요
db 연결하는 것도 다 없앴습니다
없고 음 함수에서 개속 리스트 함수 자체를 없앴네요
없고 인덱스 함수에서 SongClass.objects.all 하시면 제가 songlist
라고 했어요 지금은 리스트 이겠구나 이구나 라고 생각을 하셔도 되지만 실제 타입은
쿼리셋이라는 타입인데 이 쿼리셋에 대해서는 뒤에서 자세히 살펴봅니다
지금은 맛보기 시간이니까 그래서 songlist 가 있고요
이 songlist 를 템플릿에 넘기면 기존 코드 그대로 똑같이 동작합니다
다음에 검색어가 있으면 songlist.filter를 통해서 곡명의 코디가 포함이 포함이
되었거나, 가수 컬럼에 코디가 포함된 외열 조건을 추가하는 코드입니다
추가한 코디셋을 다시 같은 이름으로 반영하는 거죠
자 이렇게 하시면은 우리가 장고 모델을 활용하는 것이거든요
한번 해보겠습니다
현재 코드에서 GetSongList를 주석을 처리하겠구요
이 코드도 주석이죠 하겠고 위에서 커넥션 필요 없으니까 이 부분도 주석을 하겠습니다
그리고 클래스 송이었죠
모델의 모델을 이렇게 상속받은 클래스를 정리하고 임포트해서 장고 db 모델가 밑에
있네요 그래서 장고 db 모델스도 임포트합니다
그리고 클래스 메타 속성으로 db 테이블은 송스라고 쓰고 일단 mlabel 이라는 것도
지정해 줘야 돼요
자 그 내역대로 이렇게 값을 다 넣어 줬습니다
song list 는 song.object.only 라고 했고 이 타입은 제가 query
set 타입이라고 말씀을 드렸습니다
list는 아니에요
list는 아니지만 장고에서 일반적으로 on the bar list라는 이름을 많이 쓰긴
합니다 if query 해서 song list에서 검색어가 있으면 song
list.filter 리스트가 아니라 코디 세타입이니까 필터가 있는 거예요 리스트에는
필터라는 메소드는 없습니다
Q 객체고요 Q는 django.db.models의 Q입니다
이렇게 하시고 자 그리고 공명의 언더바 두 개입니다
공명컬럼에 Icontains 포함이 되었냐면 코디라는 문자 아이디가 포함이 되거나 가수의
쿼리가 포함이 되거나 서버가 죽었었는데 다시 실행하고 새로 고침 해보시면은 똑같이 잘
동작하고 있습니다
그쵸 보다 앞서 보신 이제 여러가지 방법 중에 가장 간결하게 우리가 코드를 수행했고 장고
db 커넥션에 대해서도 고민할 필요 없습니다 장고가 내부적으로 커넥션을 관리하고 있고
우리가 여러 개의 코드를 수행하면 그 커넥션을 재사용해서 데이터베이스 코디를 수행하게
됩니다



이번 내용은 장고에서 SQL 쿼리를 직접 작성하는 방법과 장고의 ORM(Object Relational Mapping)을 사용하는 방법을 비교하는 과정입니다. 아래에서 핵심적인 내용을 요약해드립니다:

1. SQL 직접 실행 (SQLite 사용)
처음에는 sqlite3 라이브러리를 사용하여 데이터베이스에 직접 연결하고 SQL 쿼리를 실행하는 방법을 설명합니다.
SQL 쿼리는 텍스트로 작성하고, 커서(cursor)를 사용하여 실행 후 결과를 처리합니다.
getSongList라는 함수에서는 SQL 쿼리문을 조건에 맞게 작성하여 데이터를 조회합니다.
이 함수는 사용자가 입력한 검색어를 바탕으로 조건을 추가하거나, 검색어가 없으면 전체 데이터를 조회합니다.
SQL에서 조건이 필요 없을 경우 WHERE 절을 생략하여 성능을 최적화합니다.
2. 장고 데이터베이스 추상화 계층 사용
직접 SQL을 작성하는 대신, 장고의 데이터베이스 추상화 계층을 사용하여 더 간결하게 데이터베이스와 상호작용할 수 있습니다.
settings.py에서 데이터베이스 연결 설정을 추가하여, 장고가 다양한 데이터베이스(MySQL, PostgreSQL 등)에 대해서도 동일한 코드로 연결하고 쿼리를 수행할 수 있도록 지원합니다.
쿼리에서 ? 대신 %s를 사용하는 점이 데이터베이스 종류에 맞게 변경된 사항입니다.
장고는 데이터베이스 연결과 종료를 자동으로 관리하므로, 개발자는 직접 연결을 처리할 필요가 없습니다.
3. 장고 ORM 활용
장고 ORM을 사용하면 SQL 쿼리를 직접 작성하지 않고도 데이터베이스와 상호작용할 수 있습니다.
models.Model을 상속받은 클래스를 정의하여, 데이터베이스 테이블과 매핑됩니다. 예를 들어, Song 클래스는 songs 테이블에 대응합니다.
쿼리를 수행할 때 Song.objects.all()과 같은 방식으로 데이터베이스를 조회할 수 있습니다.
검색어가 있을 경우 filter()를 사용하여 조건을 추가할 수 있습니다. 이때 조건은 Q 객체를 사용하여 다중 조건을 작성할 수 있습니다.
예시:
python
코드 복사
song_list = Song.objects.all()
if query:
    song_list = song_list.filter(Q(song_name__icontains=query) | Q(artist_name__icontains=query))
이 방식은 SQL을 직접 작성하는 것보다 코드가 간결하고, 데이터베이스의 종류에 상관없이 동일한 방식으로 작동합니다.
4. 결과
Song.objects.all()을 사용하여 데이터를 조회하고, filter()를 사용하여 조건을 추가합니다. 장고 ORM은 SQL 쿼리를 자동으로 생성하여 수행하며, 결과는 QuerySet 객체로 반환됩니다.
장고의 ORM은 SQL을 작성하지 않고도 데이터베이스 조작을 가능하게 하여 코드의 가독성을 높이고, 다양한 데이터베이스 엔진을 쉽게 사용할 수 있게 도와줍니다.
핵심 요약:
SQL 직접 작성: 직접 SQL을 작성하여 데이터베이스와 상호작용할 수 있지만, 각 데이터베이스 엔진에 맞는 문법을 알아야 하고, 연결과 종료를 관리해야 합니다.
장고 데이터베이스 추상화 계층: 설정만으로 여러 데이터베이스를 지원하고, ?와 %s를 사용하여 쿼리를 안전하게 작성할 수 있습니다.
장고 ORM: SQL 쿼리를 작성하지 않고 모델을 사용해 데이터베이스를 조작할 수 있으며, 코드가 더 간결하고 직관적입니다.



