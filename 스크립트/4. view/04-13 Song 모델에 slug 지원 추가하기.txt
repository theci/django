안녕하세요. 이번 시간에는 송 모델에 slug 필드를 추가하고 디테일 뷰 뷰에 slug를 지원해 보겠습니다.
워싱턴포스트의 기사처럼 SEO가 중요한 서비스에서는 URL에 slug 필드와 함께 생성, 연,월,일을 같이 노출합니다.
핫트랙 서비스에서도 연,월,일과 함께 slug 필드를 같이 노출해 보겠습니다.
먼저, 디테일 뷰 뷰에서 slug를 통한 조회를 수행해 보겠습니다.
디테일 뷰 뷰에서는 PK 혹은 slug를 통한 조회를 기본 지원합니다.
url-captured-value에서 slug 인자만 song-date-detail-view에 넘겨주면 됩니다.
뷰 코드는 변경이 없습니다.
기본 slug 컨버터의 정규 표현식 패턴은 ASCII 코드만을 지원하고 한글 등의 유니코드를 지원하지 않습니다.
유니코드 slug 지원을 위해서 직접 정규 표현식으로 패턴을 정의하겠습니다.
유니코드 slug 패턴은 Django, Quartz, Validators.py에 정의된 slug-unicode-ally 패턴을 차용했습니다.
템플릿에서 앞서 정의한 slug 패턴의 url을 조합하기보다 모델의 파이썬 코드를 통해 계산하도록 하겠습니다.
Song 모델의 getAbsoluteURL 메서드를 구현하고, 네임 필드의 slugify 메서드를 통해 slug 패턴의 문자열로 변환합니다.
slugify 호출 시에 allowUnicode 인자가 거짓이면 알파벳 숫자 언더바 하이픈이 아닌 문자는 제거됩니다.
한글 지원을 위해 allowUnicode 인자를 참으로 지정합니다.
song 모델의 getAbsoluteURL 메서드는 인자가 없는 메서드이기에 장고 템플릿에서도 호출할 수 있습니다.
장고 템플릿에서 인자 없는 함수를 호출할 수 있으며 소괄호 없이 함수 이름만 쓰면 호출이 됩니다. 
slug field로 조회를 해보면 이렇게 slug field가 없다는 오류가 발생합니다.
하트웨그의 urlspy에서 song, date, detail, view에 대한 url 패턴 정의 코드를 복사하고요.
주석 처리하고 아래에 위에서는 pk에 대한 패턴이었는데 slug에 대한 패턴을 추가를 해보겠습니다. 
직접 정규표현식 지정을 위해서 alipass를 쓰시고요.
row, string을 쓰시고 패턴의 시작과 끝도 지정을 하고 이어의 부분이 숫자가 4글자 month 부분은 숫자가 한 글자 혹은 두 글자, day 부분도 숫자가 한 글자 혹은 두
글자, slug 유니코드 패턴도 정의를 해줍니다.
하트웨그 인덱스 페이지에서 이 디테일 링크는 현재 PK만으로 조회가 되도록 되어 있는데, 이 부분의 링크를 이 주소로 변경을 해 보겠습니다.
underbar song.html 파일 열어주시고요.
여기에서 링크 부분이 있죠?
이 부분의 코드를 지우고 song.getAbsoluteURL()이라는 이름을 사용하겠습니다.
Song 모델에 getAbsoluteURL 메서드를 구현합니다.
Song 모델에 getAbsoluteURL이라는 이름의 메서드를 구현하고 반환값은 문자열로 반환하고요.
Reverse를 통해서 URL 문자열을 완성합니다.
이름이 songDateDetail이었죠.
그리고 필요한 인자가 순서대로 4개입니다.
year, month, day, slug이니까 self.releaseDate의 year, month, day. slug가 필요한데 slug라는 필드는 현재 없으니까 동적으로 name 필드의 값을 slug 코멧으로 변경을 해주겠습니다.
slugify라는 함수를 장고에서 지원을 해주고요.
slugify라는 함수의 인자는 allowUnicode라는 인자를 지원하는데 디폴트로 거짓이죠. 
이 인자를 참으로 지정을 해주셔야만 한글 문자도 slug로 변환이 됩니다.
이렇게 하시고 인덱스 페이지 새로고침 하시고요
그리고 디테일 페이지를 열어보시면 이와 같이 하트에게 년, 월, 일, 그리고 slug 이 주소로 들어왔는데 
SongDateDetailView에서 slug 인자를 받아서 Song 모델에 대해서 slug 필드로 쿼리셋을 하려고 하는데 slug라는 이름의 모델 필드가 없다는 에러가 되겠습니다
송 모델에 slug 필드를 추가하고 한글 지원을 위해 Allow Unicode 옵션도 켜줍니다. 
slug 필드를 통해 조회를 하니까 index로 추가해 주고요.
slug 필드는 name field 값을 변환하여 저장하려 합니다.
그러니 save 메서드를 재정의해서 slug 필드 값이 비었을 때에만 name field 값을 변환하여 slug 필드에 반영하도록 slugify라는 메서드를 추가해 줬습니다.
디테일 URL 계산 시에도 slug 필드 값으로 URL을 계산하도록 할게요
이렇게 Song 모델에 slug라는 모델 필드를 추가했고요 Song 모델과 관련된 데이터베이스 테이블에 slug 컬럼을 추가하기 위해서는 장고의 마이그레이션 기능을
활용합니다 파이썬 manage.py MakeMigrations 명령을 수행하면 이와 같이 새로운 마이그레이션 파일이 생성됩니다
이 마이그레이션을 적용하면 Song 모델과 관련된 데이터베이스 테이블에 slug 필드만 추가하고, 관련 인덱스도 추가됩니다.
이 마이그레이션을 적용하면 Song 모델과 관련된 데이터베이스 테이블에 slug 컬럼이 추가되고, slug 컬럼에 대한 인덱스도 추가됩니다.
그런데 slug 컬럼에는 빈 문자열이 저장되어 있습니다
현재 마이그레이션은 모델에 있는 save 등의 function이 호출되는 것이 아니라 순수하게 데이터베이스 스키마만 변경을 한 거예요
이제 커스텀 마이그레이션을 생성해서 일괄적으로 slug 필드 값을 채워주겠습니다.
makemigrations 명령 시에 Empty 옵션을 지정하면 빈 마이그레이션 파일이 생성이 되고요.
Name 옵션을 통해서 마이그레이션의 이름을 지정할 수 있습니다.
빈 마이그레이션에서 Forward Underbar 코드 함수를 정의해서 해당 마이그레이션 적용 시에 수행될 파이썬 함수를 구현하고요 해당 마이그레이션을 롤백 시에는 특별히 수행할
작업이 없으므로 리버스 코드 인자로 NOP를 지정합니다
포워드 코드 함수 내에서는 Song 모델 클래스를 가져와서요 slug 필드 값이 없는
record만 조회해서 song 인스턴스를 만든 다음에 slug 파일을 직접 호출해서
name 필드 값을 slug 필드 값으로 저장하고요.
song-object.bulk-update 호출을 통해서 일괄적으로 slug 필드를
업데이트 하도록 하겠습니다.
이렇게 두 개의 마이그레이션 파일이 생성이 되었고요.
python manage.py migrate hartl 명령으로 앞서 생성한 두 개의
마이그레이션 파일을 실행하시면 데이터베이스에 slug 컬럼도 생성이 되고, slug 컬럼의
값도 모두 채워지게 됩니다.
송 모델에 slug 필드를 추가해 보겠습니다
모델에서 slug 필드고요 한글 허용을 위해서 allow unicode true 그리고
블랭크 true라고 넣어주겠습니다
메타 클래스를 통해서 인덱스를 추가해 주는데요 이렇게 인덱스 지정을 하시면 장고의
마이그레이션 기능을 통해서 데이터베이스에 변화를 가할 때 slug 필드에 대해서 인덱스도
추가가 됩니다
slugify라는 이름의 메서드를 만들고요 강제 옵션이 주어지면 무조건 네임 필드의 값을
slug 필드로 값을 반영하는 거고요 강제 옵션이 주어지지 않으면 slug 필드의 값이
없을 때 네임 필드의 값을 slug 필드로 변환해서 저장토록 합니다
save 메서드를 재정의하는데 save 전에 저는 self.slug 파일을 호출해서요
slug 필드의 값이 없을 때에만 slug 필드의 값을 채워주도록 했습니다
이제 get-absolute-url에서는 매번 slug 파일을 할 필요가 없죠
이 부분은 제거하시고 self.slug를 직접 지정해 줍니다
이제 python manage.py makemigrations hottrack 이라는
명령을 통해서 방금 생성된 파일은 hotrack에 migrations에 000이 여기에
있겠고요 song
모델에 slug라는 필드를 추가하고 그리고 song 모델에 slug 필드에 대한 인덱스를
추가하는 migration 파일이 이렇게 생성이 되었습니다
해당 migration 파일을 수행하면 어떠한 SQL이 수행되냐면 이렇게 SQL
Migrate 명령을 통해서요 어떤 앱에 있는 어떤 Migration이 수행이 되었을 때
어떤 SQL이 수행되었는지도 이렇게 확인하실 수 있고요
실제 수행되는 SQL은 데이터베이스마다 다릅니다
현재 장고 프로젝트에는 SQLite 데이터베이스가 설정되어 있죠
그래서 여기에 출력되는 SQL도 SQLite 기준으로 생성을 해주는 것이고요
현재 바라보는 데이터베이스가 MySQL이나 PostgreSQL이나 Oracle 등이면 그 데이터베이스에
맞춰서 SQL이 출력이 되는 것입니다.
자, 이제 파이썬 매니지먼트 파이, Make Migrations, 핫트랙에 Empty,
Name 인자까지 지정을 해주시고요.
이제 3번 마이그레이션이 생성이 됩니다.
3번을 보시면 해당 마이그레이션에서 오퍼레이션 즉, 수행하는 작업이 하나도 없어요.
파이썬 함수를 수행하도록 할 거예요.
forward 코드란 인자를 지정을 해주고요.
리버스 코드는 수행할 것이 없기 때문에 nop를 지정을 해줬습니다.
런 파이썬에 지정하는 함수는 항상 모델을 임포트 하실 때는 apps.get_model을
쓰시고요. 앱 이름과 모델명을 써서 모델 클래스를 가져오셔야 되고요.
마이그레이션이 수행될 시점에 song 모델 클래스 내역을 가져와서 수행을 해야 됩니다.
마이그레이션 할 때는 song.objects.filter slug가 없는 비문자일인 것만
가져와서 포송인 퀘스 송점 slug는 네임 필드의 값으로 slug 필드 값을 채워줍니다.
채워주고요.
여기에서 송점 세이브를 하시면 매 곡마다 점 세이브가 호출되기 때문에 비효율적입니다.
버이크 업데이트를 수행하도록 합니다.
장고 마이그레이션에서는 모델 필드에 대한 히스토리 관리만 할 뿐 모델 메서드에 대해서는
히스토리 관리를 하지 않습니다
그래서 갭 모델을 통해서 Song 모델을 가져오면 필드 내용만 가져오고요
이와 같이 Song 모델에 있는 slug 파일과 같은 함수는 이 코드 내에서 참조할 수
없기 때문에 이 마이그레이션 파일에서는 slug 파일을 직접 호출했던 것입니다
파이썬 메시파이 Show Migrations 핫트랙 명령을 하시면 현재 이 앱에서 이
앱에서의 마이그레이션 적용내역을 확인하실 수 있고요
현재 0001 마이그레이션만 적용이 되어 있고 두 개는 적용이 안 되어 있습니다
마이그레이트에 핫트랙 명령을 내리시면 이렇게 미적용 마이그레이션을 순차적으로 수행을
해줍니다 그리고 Show Migrations에 보시면 두 개가 적용이 되어 있고요 그리고
개발 서버가 꺼져 있으시면 다시 구동해 주시고 페이지 새로 고침하시면 이렇게 slug를
통한 조회도 잘 동작을 하고요 이 데이터베이스 파일도 직접 열어보시면 하트엑스
언더바 송이라는 테이블이 있습니다
이렇게 열어보시면 slug라는 컬럼의 필드 값이 모두 이렇게 잘 채워져 있음을 확인을 하실
수 있습니다


이번에는 Django 프로젝트에서 slug 필드를 추가하고, 이를 **DetailView**에서 사용하여 URL 경로를 동적으로 생성하는 과정을 살펴봤습니다. 이를 통해 SEO를 고려한 URL을 만들어주고, 장고의 slugify 함수와 마이그레이션 기능을 활용하여 데이터를 일괄 처리하는 방법을 다뤘습니다.

주요 내용 요약:
Slug 필드 추가:

Slug 필드를 Song 모델에 추가합니다. 이 필드는 주로 SEO를 위해 URL에 사용되는 문자열로, 이름(name) 필드를 기반으로 생성합니다.
slugify 함수 사용:
slugify는 문자열을 슬러그 형태로 변환합니다. 한글을 지원하려면 allow_unicode=True로 설정해야 합니다.
Song 모델에서 get_absolute_url() 메서드를 통해, URL을 동적으로 생성합니다. 여기서 slug는 name 필드를 기반으로 변환하여 생성됩니다.
Slug로 조회하는 DetailView:

DetailView에서 기본적으로 PK를 사용하여 조회하지만, slug 필드를 사용하도록 URL 패턴을 수정합니다.
URL 패턴에서 slug를 캡쳐하여 slug 기반으로 Song 객체를 조회하도록 구현합니다.
urls.py에서 slug를 사용하는 URL 패턴을 새롭게 정의하며, 정규 표현식을 통해 연도, 월, 일과 slug를 포함한 경로를 처리합니다.
URL 패턴 수정:

urls.py에서 기존의 PK 기반 URL 패턴을 slug 기반으로 수정합니다.
정규 표현식에서 연도, 월, 일 그리고 slug를 캡쳐하는 방식으로 새로운 URL 패턴을 추가합니다.
get_absolute_url() 수정:

Song 모델에 get_absolute_url() 메서드를 구현하여, 모델 인스턴스의 slug를 사용해 URL을 생성합니다.
이를 위해 self.slug 값을 직접 사용하고, slugify를 통해 변환된 name 필드를 기반으로 URL을 동적으로 생성합니다.
마이그레이션:

slug 필드를 데이터베이스에 추가한 후, 마이그레이션을 수행하여 테이블에 컬럼을 추가합니다.
마이그레이션 파일을 통해 데이터베이스에 변경 사항을 반영합니다.
makemigrations 명령을 통해 새로운 마이그레이션 파일을 생성하고, migrate 명령으로 적용합니다.
기존 데이터에 대해 Slug 값 채우기:

마이그레이션 파일을 통해 기존의 Song 객체들에 대해 slug 필드를 채워주는 작업을 합니다.
이를 위해 커스텀 마이그레이션을 작성하여, slug 필드가 비어있는 객체들에 대해 name 필드를 기반으로 slug 값을 채워주는 코드를 추가합니다.
이 작업은 bulk_update를 사용하여 효율적으로 처리됩니다.
결과 확인:

마이그레이션을 완료한 후, 데이터베이스 테이블을 확인하여 slug 필드에 값이 잘 채워졌는지 확인합니다.
Song 모델의 객체들이 slug 필드를 기준으로 조회되고, URL 패턴도 정상적으로 동작하는지 검증합니다.
구체적인 구현 내용:
Song 모델에 slug 필드 추가:

python
코드 복사
from django.db import models
from django.utils.text import slugify

class Song(models.Model):
    name = models.CharField(max_length=100)
    slug = models.SlugField(unique=True, blank=True)
    release_date = models.DateField()

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name, allow_unicode=True)
        super().save(*args, **kwargs)
    
    def get_absolute_url(self):
        return f"/songs/{self.release_date.year}/{self.release_date.month}/{self.release_date.day}/{self.slug}/"
URL 패턴 설정 (urls.py):

python
코드 복사
from django.urls import path, re_path
from .views import SongDetailView

urlpatterns = [
    re_path(r'^(?P<year>\d{4})/(?P<month>\d{1,2})/(?P<day>\d{1,2})/(?P<slug>[-\w]+)/$', SongDetailView.as_view(), name='song_date_detail'),
]
마이그레이션 생성 및 적용:

마이그레이션 명령:
bash
코드 복사
python manage.py makemigrations hottrack
python manage.py migrate hottrack
기존 레코드에 대해 slug 값 채우기 위한 커스텀 마이그레이션 생성:
bash
코드 복사
python manage.py makemigrations hottrack --empty --name populate_slug
커스텀 마이그레이션 코드:

python
코드 복사
from django.db import migrations

def forward_code(apps, schema_editor):
    Song = apps.get_model('hottrack', 'Song')
    for song in Song.objects.filter(slug=''):
        song.slug = slugify(song.name, allow_unicode=True)
    Song.objects.bulk_update(song_list, ['slug'])

class Migration(migrations.Migration):
    dependencies = [
        ('hottrack', '0002_auto_20240101_1234'),
    ]

    operations = [
        migrations.RunPython(forward_code),
    ]
결론:
Slug 필드를 추가하여 SEO 친화적인 URL을 생성하고, 이를 통해 사용자가 URL을 통해 더 직관적으로 정보를 찾을 수 있도록 했습니다.
Django의 slugify 함수를 활용해 한글과 같은 유니코드 문자가 포함된 슬러그를 생성할 수 있게 했으며, 마이그레이션을 통해 기존 데이터를 처리하는 방법도 소개했습니다.


