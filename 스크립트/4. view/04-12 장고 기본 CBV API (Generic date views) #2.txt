투데이 아카이브 뷰입니다.
앞서 살펴본 데이 아카이브 뷰와 동일한데 투데이 아카이브 뷰는 기준 날짜가 오늘로 강제
적용됩니다.
Year, Month, Day라는 인자가 필요하지 않고요.
나머지 처리는 똑같습니다.
TodayArchiveView 클래스를 상속받은 SongTodayArchiveView
클래스를 정의했고요.
Song 모델이고, release 데이트 필드를 통해서 처리하죠.
이렇게 세 줄만 구현하시고, 추가적인 인자 없이 잘 동작합니다.
요청 주소를 하트웨어계의 Archives에 Today 이 주소로 요청하시면은 오늘 날짜로
조회되는데, 오늘 날짜에 데이터가 없는 경우에는 404 예외가 발생합니다.
오늘 날짜로 조회하는 부분의 코드가 어디에 있냐면, TodayArchiveView
클래스에서 getDatedItems라는 이 메서드 내부 코드에서 언더바
getDatedItems를 호출할 때에 Today라는 인자가 하도 코딩되어서 전달이
되거든요. 개발 환경일 때.
테스트를 위해서 가짜 오늘 날짜를 한번 지원을 해보겠습니다.
Query 파라메타로 fakeToday라는 인자로 이 날짜를 오늘 날짜로 사용을 한번
해보겠다는 거죠.
settings.debug 값이 참일 때, 즉 개발 환경에서만 getDatedItems라는
메서드가 이 클래스에서 지원이 되도록 이런 문법도 파이썬은 가능합니다.
쿼리 파라메타에서 FakeToday가 있으면 가져오고 없으면 빈 문자열을 반환받고요
만약 FakeToday가 빈 문자열이면 split의 결과도 리스트 안에 빈 문자열
하나거든요 그럼 빈 문자열을 int로 변환하는 부분에서도 ValueError가 발생하고요
하이픈으로 구분했을 때 구분된 값이 정수 형태가 아니라면 ValueError가 발생하고요
Year, Month,Day 값이 3개인데 3개가 아닌 값으로 만들어질 때에도 ValueError
Error가 발생합니다.
그래서 Value Editor가 발생하면 Fake Today 파라미터가 없거나 날짜 형식이
잘못되었을 경우라고 판단해서 기본 구현 을 호출해서 처리를 하겠고요.
Year, Month,Day로 정수 변환이 정상적으로 수행이 되었을 때에는 날짜 객체를
생성해서 언더바 GetDatedItems 메서드를 호출해주면 이렇게 FakeToday 쿼리
파라미터를 통해 오늘 날짜를 테스트 목적으로 지정을 해 보실 수 있게 됩니다.
송 투데이 아카이브 뷰 클래스 딱 세 줄만 복사해서 붙여넣기 하겠고요 투데이 아카이브 뷰도
임포트해 주겠습니다
하트랙의 urlspy에서 코드도 복사해서 하단에 붙여넣고요 이 요청에서는 송투데이 아카이브
뷰를 통해서 요청을 처리합니다
카트랙의 Archives에 Today로 요청을 해보시면은 Page Not Found
404, No Songs Available이라고 해서 조회된 데이터가 없다는 거죠
오늘 릴리즈된 노래가 없다는 의미가 되겠습니다
그러면 Fake Today 지원을 위해서요 여기 If Settings, Settings는
임포트하실 때 장고 conf의 Settings고요
여기 Debug가 참일 때에만 저는 getDatedItems라는 메서드를
재정의하겠습니다
그러면 이 코드를 이제 복사해서 한번 붙여넣을게요
getDatedItems라는 메서드를 구현을 했습니다
fakeToday라는 query 파라미터 값을 가져오고 그 문자열에서 하이픈을 구분자로
해서 최대 3개를 쪼갠 다음에 각각의 값에 대해서 정수로 변환해서 year, month,
day라는 각각의 변수에다가 값을 담고 이렇게 3개의 변수에 값 담기에 성공한다면 데이트
객체를 생성해서 underbar getDatedItems 호출을 통해서 지정 날짜로 조회를
하고요. 값 조회에 실패하면 기본 구현을 호출해서 처리를 하도록 합니다.
Today 요청에서 Query 파라메타로 Fake Today를 2022-10-7로 지정해서
요청해보면 이렇게 song-today-archive-view에 의해서 요청이 잘
처리되었음을 확인하실 수 있습니다
이번에는 week-archive-view입니다 특정 주에 대한 목록입니다
week-archive-view라는 클래스를 상속을 받고요 song-model에 대해서
처리하고 release, date하는 필드에 대해서 필터링하고 정렬하겠습니다
week-archive-view에서는 week-format이라는 속성을 추가로 지원하는데요
이 속성은 한 주의 시작을 일요일로 할 것이냐, 한 주의 시작을 월요일로 할 것이냐인데요.
디폴트어는 한 주의 시작을 일요일로 하는 %U 설정인데, 저는 한 주의 시작을 월요일로
하는 %W 설정을 넣었습니다.
그 이유는 우리가 템플릿 단에서 이런 URL을 만들 텐데요.
그때 Date라는 템플릿 필터를 통해서 해당 날짜가 몇 주 차인지를 뽑아냅니다.
그런데 이 Date 필터에서 해당 날짜가 몇 주 차인지 알려주는 대문자 W 포맷은 ISO
8601에 따라 한 주의 시작을 월요일로 간주합니다.
일요일로 처리하는 기능이 없어요.
URL 생성할 때는 한 주의 시작을 월요일로 처리하는데 그 요청을 받아서 처리하는 뷰에서는
한 주의 시작을 일요일로 처리하면 요청과 다르게 엉뚱한 데이터가 보여지거든요.
그래서 한 주의 시작을 월요일로 통일해서 처리하도록 위크 포맷을 %W로 처리했고요 그리고
요청을 처리할 때는 이열 위크 인자가 필요합니다
여기도 속성으로 제공해서 고정시킬 수도 있고 url-captured-values를 통해서
가변 처리 혹은 쿼리 파라미터를 통해서 가변 처리하실 수 있는데
url-captured-values를 통해서 처리하도록 url-pattern 정의 시에
이열 위크 정의를 추가했습니다
song-archive-week.html 템플릿에서도 앞서 살펴봤던 템플릿과 구조가
똑같습니다.
year, month, day 대신에 week가 제공되는 형태가 되겠고요.
데이트하는 템플릿 필터에서는 대문자 W주, 대문자 W가 ISO 8601에 따라 한 주의
시작을 월요일로 간주해서 몇 주 차인지, 해당 날짜가 몇 주 차인지 알려주거든요.
SongWeekArchiveView 클래스를 복사해서 뷰스파이 하단에다가 붙여놓고
week-archive-view-class도 이렇게 import를 해주겠습니다.
그리고 path 부분을 복사를 해서 하단에 붙여넣고요.
url-capture-value로 year과 week를 받고요.
song-week-archive-view-class를 통해서 처리합니다.
핫트랙의 archives에 2022 week에 46 주소로 요청해 보시면 song의
archive-week.html 템플릿이 없다는 오류가 발생하고요.
소스코드 페이지에서 템플릿 코드를 복사하신 다음에 적용을 하시고 새로고침하시면 이렇게
화면에 잘 보여지게 됩니다
아카이브 인덱스 뷰 클래스는 최신 목록 외에 지정 단위의 날짜 목록을 제공받습니다
아카이브 인덱스 뷰 클래스를 상속받은 song_archive_index_view 클래스를
정의했고요 song 모델에 대해서 releaseDate라는 필드에 대해서 필터링하고 정렬을
수행하겠고 이렇게 세 줄만 적용을 하시면 해당 페이지에는 전체 노래가 보여지고요.
그리고 각 곡이 있는 연도 목록을 제공을 받습니다.
그런데 한 페이지에 전체 목록을 보여주는 것은 데이터가 많으면 좀 부담스럽잖아요.
그래서 Archive Index View에서는 PageNumber 속성을 지정하셔서 꼭
페이징 처리를 해주시는 것이 좋고요.
오른쪽에 제공되는 데이터가 있는 연도 목록 외에 데이터가 있는 월 목록, 데이터가 있는
날짜 목록 혹은 데이터가 있는 위크 목록이 필요하시다면 DateListPeriod라는 이
속성에서 디폴트가 Year인데 Month, Day, Week로 바꾸시면 됩니다
클래스 변수로 지정하면 해당 뷰에서는 고정이 되는 거고요.
요청 주소에 따라서 이월로 처리하거나, month로 처리하거나, day로 처리하거나,
week로 처리하시려면 이 변수명 앞에 get underbar를 붙인
getDateListPeriod라는 메서드 내에서 문자열 이월이나 month나 day나
week를 반환하시면 되거든요.
저는 이 메서드 구현해서 url-captured-value에서 datelist.period
값이 있으면 그 값을 쓰고, 없으면 이 datelist.period 속성을 활용하도록
하겠습니다. aripath로 정규 표현식 방식으로 url 패턴을 정의하실 수 있는데,
datelist.period라는 이름으로 문자열을 뽑아낼 텐데 그 값이 year이거나
month이거나 day이거나 week인 경우 값을 뽑아서 이 뷰에다가 넘겨주는데 그럼 이
뷰에서는 self.keyword argument 사전을 통해서 url captured
value 값을 참조하실 수 있고요
뒤에다가 물음표 붙였죠?
물음표는 이 패턴이 0회 혹은 1회, 즉 없을 수도 있고, 있다면 한 번 나온다는 거죠.
하트웨어 아카이브스로 요청을 하면 이
DateList.Period.UrCaptureValue가 없는 상황이니까 그때는 이
DateList.Period 속성 값을 활용해서 이열로 처리가 된 거고, archives에
year로 요청을 하시면은 url-captured-value에서 year 값을 가져와서
적용이 된 거고 months로 지정하시면은 여기에서 months로 가져와서 적용된 거고
day, week도 마찬가지가 되겠습니다
그 다음에 적용된 dateList period 값을 context 데이터에도 호출해서
적용을 해 줄 거예요
이렇게 적용해 줘야만 화면에 제가 2열로 뽑았는지, month로 뽑았는지, day로
뽑았는지, week로 뽑았는지 보여줄 수 있을 테니까 데이트리스트 피디어드를 보여주는데 첫
글자가 자동 대문자 처리되도록 title이라는 장고 템플릿 built-in 필터를 호출해서
첫 글자가 대문자로 보여지도록 처리했고요.
데이틀리스트 피리어드, 데이틀리스트 피리어드, 이렇게 보여지고 있습니다.
데이틀리스트 피리어드가 2월일 때는 연도로 처리해서 링크로 보여줄 것이고, month는
월, day는 day, week는 주 단위로 보여줄 거고요.
페이징 처리를 했기 때문에 클래스 기반 뷰의 리스트 뷰와 마찬가지로 페이지 오브젝트라는
컨텍스트 데이터도 제공이 됩니다
페이지 오브젝트 값이 있으면 현재 페이징 처리 중인 거죠
페이징 처리 중일 때에 부트스텝 페이지네이션을 통해서 여기 하단에다가 페이징 내비게이션을
출력하도록 했습니다
ArchiveIndexView에서는 호스팅 목록은 Latest를 통해서 코디셋을 제공하고 있습니다
SongArchiveIndexView 클래스를 이렇게 세 줄만 복사해서 한번 붙여넣기를 해
보겠습니다 아카이브 인덱스 뷰로 임포트 해 주시고요
이 aripath를 그대로 쓰는데 이렇게 붙여넣기 해 주시고 DateListPeriod라는
이름의 urlCaptureValue는 현재 song-archive-index-view에서
사용하고 있지는 않습니다
일단 패턴만 이렇게 정의해 놨어요
하트에게 archives로 호출해 보시면 이렇게 song-archive.html 템플릿을
찾는데 없다고 나오죠
정상 호출된 것이고요
코드를 복사해서 이렇게 적용을 합니다
그리고 새로고침 하시면 이렇게 나옵니다
현재 전체 곡이 릴리즈 데이트 필드 역순으로 전체가 다 보여지고 있죠
템플릿 단에서 제가 date list period 값을 기준으로 이렇게 연, 월, 일, 주를
분기해서 처리해 주도록 했는데 현재 데이트 리스트 피디워드 값이 없으니까 이렇게 보여지는
건데 근데 기본 처리는 2열로 처리되고 있잖아요
contextData 메서드를 재정의해서, datelistPeriod란
이름으로 사용된 dateListPeriod 속성값을 할당해 주시고 새로고침하시면 디폴트로
연도별로 목록이 보여지고 있습니다
그러면 Month로 지정해주면 월 목록을 보여주고 싶고요.
So 목록은 안 바뀌고요.
날짜 목록만 바뀌는 거예요.
Day 해주시면 데이터가 있는 날짜 목록을 보여주고 싶고 week 하시면 데이터가 있는 주
목록을 보여주고 싶습니다.
그러면 여기에 있는 해당 코드를 그대로 복사해서 이렇게 적용하시면 이렇게 주로 나오죠.
디폴트는 Year, Month, Day로 처리가 되고 있습니다.
한 페이지에서 전체 데이터를 모두 렌더링 하는 것은 데이터가 많으면 아주 비효율적이니까
페이징 처리를 위해서 Pagination, by 10 혹은 원하는 숫자로 이렇게 지정을
하시고요. 새로 고침하시면 이렇게 페이징 처리가 되어서 잘 처리가 되고 있습니다.
detailView는 PK 또는 Slug 필드를 이용해서 레코드를 조회합니다.
dateDetailView는 PK 혹은 Slug 조회 조건 외에 Year, Month,
Day 조회 조건을 추가하여 레코드를 조회합니다.
URL에 연, 월, 일 정보가 들어가면 여러 가지 이점이 있습니다.
첫째로, 검색엔진이 컨텐츠의 시간적 측면을 더 정확하게 이해할 수 있습니다.
둘째로, 사용자도 URL만 보고도 해당 컨텐츠가 언제 만들어졌는지 쉽게 알 수 있습니다.
예를 들면, 화면 오른쪽에 주소처럼 해당 페이지는 Click Like 노래의 상세 페이지로
2023년 8월 30일에 공개된 노래임을 쉽게 알아챌 수 있습니다.
이러한 URL의 접근 방식은 SEO, 즉 검색 엔진 최적화에 좀 더 민감한 해외 언론
사이트에서 많이 확인하실 수 있게 됩니다.
데이터베이스 측면에서 볼 때 PK는 이미 레코드를 유일하게 식별할 수 있기 때문에 추가적인
연, 월, 일 필터링은 반드시 필요하지 않을 수 있습니다.
하지만 슬러그 필드의 경우 같은 슬러그를 가진 레코드가 다른 날짜에도 있을 수 있으므로 이
경우에는 반드시 연, 월, 일을 추가 조건으로 사용해야 합니다.
슬러그 지원에 대해서는 이후 강의에서 살펴볼 수 있도록 하겠고요.
dateDetailView 클래스를 상속받은 songDetailView 클래스를 정리하고,
song 모델에 대해서, 그리고 년월일 조회는 releaseDateField에 대해서
조회를 하고, 월이 있으니까 month 포맷도 %m으로 숫자 포맷으로 처리하도록 해줍니다.
코드는 이렇게만 해주시면 되겠고요 템플릿은 디테일 뷰에서 사용하는
song-detail.html 템플릿 경로가 디폴트로 사용이 됩니다
song-dateDetailView 클래스 코드를 복사하셔서 이렇게 붙여넣고요 그리고
임포트로 해주겠습니다
urlspy에서 해당 패스도 붙여넣기 하겠습니다.
연도, 월, 데이, 그리고 pk값 이렇게 4개의 숫자가 지정이 되면
songDateDetailView 클래스를 통해서 처리를 하고요.
year, month, day 값을 조합해서 releaseDate 필드에 대해서 조회
조건을 넣고 그리고 pk 필드는 이 모델의 pk 필드에 대해서 조회 조건을 넣어서 서로
end 조건으로 조회를 수행하게 됩니다.
하트에게 2023-08-30-62라는 주소로 접근해 보시면은 이렇게 클릭 라이크 하는
노래가 조회가 됨을 확인을 하실 수 있구요
만약 날짜를 엉뚱하게 지정하시면 이렇게 페이지 not found가 처리가 되고요 현재
페이지에서 수행된 SQL 내역을 장고 디버그 툴바로 확인해 보시면 릴리즈 필드에 대해서
2023.8.30으로 이렇게 조회 조건이 들어갔고요 그리고 PK 필드에 대해서 60이라는
이 값도 조회 조건으로 들어갔음을 확인하실 수 있습니다