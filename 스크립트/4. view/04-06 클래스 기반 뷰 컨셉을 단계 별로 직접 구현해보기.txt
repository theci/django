클래스 기반 뷰 컨셉을 단계 별로 구현해보겠습니다.
1단계로써 함수 기반 뷰이고요.
매 함수 뷰마다 기능을 매번 구현하는 거예요.
이는 간단하고 직관적이지만, 비슷한 동작의 뷰 함수가 여럿 있을 때에는 이렇게 코드 중복이
발생을 하게 됩니다.
사용하는 모델, 사용하는 템플릿 명, 템플릿 내에서 참조하는 이 모델 인스턴스 이름을
제외하고는 기본적인 동작이 똑같죠.

2단계로서 같은 동작의 뷰 함수를 생성하는 방식입니다.
GenerateViewFn이 하는 함수가 있고요.
호출이 되는 시트로 시점에 뷰Fn이라는 함수를 생성을 하는 거예요 생성을 하고 생성된
함수를 반환합니다
클래스 안의 함수와 함수 안의 함수는 달라요
이 함수가 호출되는 시점에 이 함수가 동적으로 만들어지는 겁니다
이러한 함수를 우리가 클로저라고 부릅니다
중복 기능을 가진 뷰 함수들의 공통 기능을 별도 함수로 분리하여 생성하는 방식이에요
오른쪽과 같이 PostDetailView 함수와 ArticleDetailView라는 뷰 함수를
GenerateViewFn 함수를 통해서 만들어서 활당하는 방식입니다
앞서 봤던 같은 로직이 하나의 함수 내에서 구현이 되어 있겠고요
여기 인자로 넘긴 포스트 모델, 인자로 넘긴 아티클 모델, 인자 모델 클래스가 있죠
뷰 동작이 이 모델 클래스 값을 참조해서 모델 인스턴스 조회하고 모델 클래스의 모델네임을
읽어와서 인스턴스 네임을 만들어내고 그리고 모델 클래스의 앱 레이블과 인스턴스 네임을
참조해서 템플릿 이름을 만들어내고 그리고 템플릿 응답을 렌더링하는 방식인 거예요 함수를
활용하기 때문에 기존에 만들어진 이 GenerateViewFn이라는 함수를 새롭게 정의하지
않는 한 기능 확장이 불가능합니다

세 번째 방식은 클래스로 같은 동작의 뷰 함수를 생성하는 건데요
두 번째 방식과 기능적으로는 비슷하지만 클래스를 활용한다는 점이 다릅니다
뷰 함수의 기능을 세분화해서 개별 메소드로 구현합니다
개별 메소드로 구현했기 때문에 특정 기능을 변경하거나 확장할 수 있는 유연성이 제공됩니다
새로운 클래스, detailView라는 클래스를 정의했고요 생성자에서는 모델 클래스를
받습니다 모델 클래스가 non이 아니라면 모델 클래스를 이렇게 instance 변수로써
값을 할당해 주겠고요 getObject와 getTemplateName,
getDispatch라는 3개의 메서드를 정의했고, getObject에서는 뷰 인자를 통해
전달된 PK를 이용해서 모델 인스턴스를 조회하고 반환합니다.
getObject는 지정된 PK 값을 활용해서 데이터베이스로부터 해당 모델 인스턴스를
조회하고, 없다면 404 예외를 발생시키는 책임만 있는 거예요
두 번째로 getTemplateName이라는 메서드는 모델 클래스의 메타 속성을 활용해서
즉 모델 클래스의 AppLabel과 모델네임이라는 걸 활용해서 템플릿 경로를 생성해주는
책임만 있는 거고요
Dispatch 메서드는 뷰 요청을 실질적으로 처리하는 메서드입니다
리퀘스트 인자가 있고 추가로 뷰 인자를 받을 수 있는데 디테일 뷰가 여러 뷰에 의해서
사용이 될 수 있기 때문에 argument와 keyword argument로 인자를 받아서
getObject로 받은 대로 그대로 넘겨줬습니다.
Dispatch 함수 호출 시에 getObject 메소드를 호출해서 관련 모델 인스턴스를
조회하고 getTemplateName 호출을 통해서 관련 템플릿 경로를 생성하고 렌더를
통해서 템플릿 응답을 만들어내는 거죠.
추가로 asView란 이름에 class 메서드를 추가합니다.
클래스 메서드로 정의된 메서드는 class 이름.classMethod 이름 형태로
호출할 수 있습니다.
asView라는 함수가 호출되면 새로운 함수를 만들고, 새롭게 만들어진 뷰 함수를 이렇게
리턴을 하죠. 그럼 asView에 반환 값은 새로운 뷰 함수가 됩니다.
PostDetailView가 호출이 되면 뷰 함수가 호출이 될 테고 뷰 호출이 심하다
DetailView 인스턴스를 생성해서 요청을 처리해요
클래스 메서드의 첫 번째 인자는 이 클래스입니다
클래스를 호출하는 형태로 코드를 쓰면 인스턴스를 생성하는 것이고요
instance.dispatch 호출을 통해서 뷰 요청을 실질적으로 처리하고 그 반환 값을
리턴을 하게 됩니다
이렇게 PostDetailView를 구현을 했고요.
ArticleDetail의 경우에는 get_object의 구현을 조금 변경을 해보고자 합니다. 
기본 DetailView에서는 PK값, PK 필드를 기준으로 조회를 했는데, Article에서는 Slug 필드를 기준으로 조회하고 싶어요.
그러려면 get_object의 구현이 바뀌어야 되는 거죠.
이럴 때에는 디테일 뷰를 상속받은 새로운 클래스를 정의하고 이 클래스에서 해당 메서드를 재정의하고 원하는 형태로 구현을 하면 됩니다
ArticleDetailView는 이 Class.as_view를 호출해서 뷰 함수를 생성하면 이 GetObject로 동작하는 뷰 함수를 사용하시게 되는 겁니다
앞서 구현한 DetailView를 장고 기본의 빌트인 클래스 기반 뷰로서 DetailView가 제공이 되고 있어요 
이외에도 ListView, CreateView, UpdateView, DeleteView 등이 지원이 되고 있겠고요 
디테일 뷰.mixins.View 호출 시에 모델이라는 이름으로 모델 클래스를 지정해 주면 이렇게 포스트 디테일 뷰가 만들어지고 모델 클래스를 지정해서 아티클 디테일 뷰를 만들어낼 수 있습니다
ArticleDetailView에서 이렇게 발행된 article에 대해서만 조회되도록 제안을 하려고 합니다 
그러려면 DetailView에서는 쿼리셋을 만들 때 getCordiSet()이라는 메서드를 통해서 쿼리셋을 만들거든요 
발행한 article에 대해서만 조회되도록 하려면 생성되는 쿼리셋을 변경하면 될 테니까 getCordiSet()라는 메서드를 재정의하겠고요 
부모의 GetCordiSet을 호출해서 기본 쿼리셋을 얻어내고 이 쿼리셋에 필터 조건을 추가해서 반환을 합니다
PublishedArticleDetailView 클래스 클래스, 이 클래스의 AsView를 통해서 뷰 함수가 만들어지면 이 뷰 함수는 발행한 아티클에 대해서만 조회를 하는 뷰 함수가 됩니다
클래스 기반 뷰는 DRY 원칙을 따르는 뷰 기술이며 함수 기반 뷰는 레거시가 아닙니다가 아니며 여전히 유효합니다
클래스 기반 뷰는 클래스 기반 뷰가 정한 관례대로 개발할 경우 최소한의 코드로 설정과 같은 코드를 통해 효과적으로 구현이 가능하고요 
클래스 기반 뷰를 효과적으로 사용하려면 사용하려면 클래스 기반 뷰의 상속 구조와 각 메서드의 역할을 잘 정리하는 사이트가 있습니다
이 사이트를 열어보시면 오른쪽과 같이 특정 클래스 기반 뷰의 부모 클래스의 종류와 지원하는 속성과 그리고 지원 메서드들을 이렇게 일목요연하게 확인을 하실 수 있습니다
클래스 기반 뷰 사용 시에도 함수 기반 뷰 구현을 연습하시면 뷰의 작동 원리에 대한 이해가 향상됩니다
클래스에서 재정의할 메서드의 이름과 그 메서드가 어떤 인자를 지원하는지 모두 기억할 수 없잖아요 
IDE의 method override 기능을 사용하면 아래와 같이 재정의할 메서드를 UI를 통해서 선택하실 수 있고, 해당 메서드를 선택하면 필요한 인자가 자동으로
채워지기에 개발하실 때 편리합니다.
장고 기본에서 지원하는 클래스 기반 뷰 사용에만 그치지 마시고요.
구현하시다 보면 클래스 기반 뷰를 사용해서 구현하시더라도 여러 클래스 기반 뷰에 걸쳐서 반복되는 기능들이 있습니다.
그런 기능들이 생기시면 커스텀 클래스로 추출해서 코드 중복을 최소화하세요.


이 설명은 Django에서 함수 기반 뷰(Function-Based Views, FBV)와 클래스 기반 뷰(Class-Based Views, CBV)를 활용하여 뷰를 구현하는 과정과 그 차이를 단계별로 설명한 내용입니다. 각 단계별로 핵심적인 내용은 다음과 같습니다:

1단계: 함수 기반 뷰 (FBV)
특징: 가장 기본적인 방식으로, 각 뷰에 대한 처리를 별도의 함수로 구현합니다.
장점: 간단하고 직관적이며, 작은 프로젝트에서 유용합니다.
단점: 비슷한 기능을 가진 뷰가 여러 개 존재할 경우 코드 중복이 발생할 수 있습니다.

2단계: 동적 함수 생성 (클로저 활용)
특징: GenerateViewFn 같은 함수를 활용하여 동적으로 함수를 생성합니다. 이 방식은 함수 내부에서 클로저를 사용하여 중복된 로직을 하나의 함수로 추출합니다.
장점: 중복 코드를 최소화하고, 반복적인 동작을 함수화하여 효율성을 높입니다.
단점: 함수가 동적으로 생성되기 때문에 기능 확장에 한계가 있으며, 코드 이해도가 떨어질 수 있습니다.

3단계: 클래스 기반 뷰 (CBV)
특징: 클래스를 이용하여 뷰를 구현합니다. 공통적인 동작을 메서드로 분리하여 구현하며, 상속과 메서드 오버라이딩을 통해 기능을 확장합니다.
구성:
get_object: URL 파라미터를 통해 해당 모델 인스턴스를 조회하는 메서드.
get_template_name: 모델 정보에서 템플릿 파일 경로를 생성하는 메서드.
dispatch: 요청을 처리하는 메서드로, 실제로 뷰를 렌더링하고 응답을 생성합니다.
장점: 코드의 재사용성과 유연성이 높으며, 기능 확장과 변경이 용이합니다. 예를 들어, 특정 뷰에서 get_object를 재정의하여 다른 필드로 조회할 수 있습니다.
단점: 구조가 복잡할 수 있으며, 클래스를 이해하고 사용하는 데 시간이 필요할 수 있습니다.

클래스 기반 뷰의 커스터마이징
상속을 통한 커스터마이징: 예를 들어, ArticleDetailView에서 get_object 메서드를 수정하여 기본 동작을 변경할 수 있습니다.
as_view 메서드: 클래스를 기반으로 뷰 함수를 동적으로 생성하는 역할을 합니다. 이 메서드는 클래스에서 정의된 동작을 호출하여 뷰를 실행합니다.
Django의 기본 클래스 기반 뷰:
Django는 이미 DetailView, ListView, CreateView, UpdateView, DeleteView 등을 기본적으로 제공하여, 대부분의 CRUD 작업을 쉽게 처리할 수 있습니다.
이러한 클래스 기반 뷰는 DRY (Don't Repeat Yourself) 원칙을 따르며, 코드 중복을 줄이고 가독성을 높입니다.
커스터마이징과 확장
클래스 기반 뷰는 상속과 메서드 오버라이딩을 통해 매우 유연하게 기능을 확장할 수 있습니다.
예를 들어, get_queryset 메서드를 재정의하여 특정 조건에 맞는 쿼리셋을 반환하거나, get_context_data를 수정하여 추가적인 데이터를 템플릿에 전달할 수 있습니다.

결론
**함수 기반 뷰(FBV)**는 단순하고 직관적인 방식으로, 작고 단순한 프로젝트에서 유용합니다.
**클래스 기반 뷰(CBV)**는 유연성과 재사용성이 뛰어나며, 상속과 메서드 오버라이딩을 통해 더 복잡한 요구사항을 처리할 수 있습니다.
클래스 기반 뷰를 효과적으로 사용하려면, Django의 클래스 기반 뷰의 구조와 각 메서드가 담당하는 역할을 잘 이해하고 사용하는 것이 중요합니다.
Django에서 제공하는 클래스 기반 뷰를 잘 활용하면 코드의 중복을 최소화하고 유연한 기능 확장을 할 수 있습니다.