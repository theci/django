안녕하세요. 이번 시간에는 뷰 함수와 URL 맵핑에 대해서 살펴보겠습니다.
Vue 함수는 HTTP 요청을 처리하며 하나의 함수가 여러 URL에 연결될 수 있습니다.
이 연결은 URL 패턴즈 리스트에서 관리되는데 각 항목은 요청을 처리할 뷰서와 그 요청을 처리할 View 함수를 맵핑합니다.
정규 표현식을 활용한 re_path 함수나 미리 정의된 패턴을 활용하는 패스함수를 통해 URL 패턴을 상세하게 설정할 수 있습니다.
패스나 re_path 패스에서 캡처한 값을 뷰 함수에 인자로 전달할 수 있고요.
프로젝트 레벨의 URL 패턴의 리스트를 시작으로 include 함수를 통해 하위 URL 패턴즐 리스트를 통합합니다.
이렇게 구성된 최상위 URL 패턴의 리스트에는 프로젝트가 실행될 때 모든 URL 패턴을 등록하고 각 정규 표현식들을 컴파일하여 매칭 속도를 높입니다.
http 요청이 들어오면 장보는 이 리스트를 처음부터 끝까지 순서대로 검색해서 매칭되는 URL 패턴을 찾습니다.
첫 번째로 매칭되는 패턴의 view 함수가 호출되어 요청을 처리하고 이후 패턴은 검사하지 않습니다. 
매칭되는 패턴이 없을 경우 404 error 응답이 반환됩니다.
Settings의 디버그 설정 값에 따라서 404, 403, 400, 500과 같은 HTTP 오디오 응답 화면이 달라집니다.
Settings.debug 설정이 참인 경우에는 디버깅 정보가 포함된 노란색 화면이 표시가 되는데요. 
디버그 설정이 거짓인 경우에는 관련 템플릿을 찾습니다.
404 오류인 경우에는 404.html 템플릿을 찾고 500 오류는 500.html 템플릿을 찾습니다.
관련 템플릿 파일이 존재하면 그 템플릿 파일을 통해 응답을 생성하고 템플릿 파일이 없을 경우 잔여 내에 미리 정의된 응답이 반환됩니다.
GitHub의 404 페이지처럼 서비스를 완성도를 높이기 위해 404.html 템플릿 파일을 작성하는 것을 권장드립니다.
흔히 실수하는 뷰응답 예시입니다.
미들웨어는 뷰 반환 값이 HttpResponse 인스턴스임을 기대하고 동작합니다.
이 부분을 기억하시구요.
자, index라는 뷰 함수에서 문자열을 반환토록 이런 실수를 종종 하기도 하는데요.
이 표함수가 동작을 하면은 이런 오류가 발생합니다
attribute error 문자열 객체는 get 속성이 없다 라고 되죠
그래서 이 오류만 보면은 이 부분이 문제인지 잘 파악하기가 힘들어요
근데 이 오류가 뜨면은 무조건 이 문제입니다
자 이 에러가 뜨는 지점은 어디냐면은 미들웨어 단에서 발생합니다.
미들웨어는 view 반환 값이 HTTP response 인스턴스임을 기대하고 동작하기 때문에 이 응답이 이 타입임을 기대하기 때문에 somecat 메서드을 호출한 거거든요 
근데 문자에 되는 이 method가 없으니까 이 오류가 발생한 거예요
이 오디오면은 내가 view함수에서 문자를 반환했구나 라고 해당 부분을 찾으시면 될 거고요
그리고 view함수에서 리턴하실 때 렌더 함수가 http 리스판스의 인스턴스를 반환하는데 지금 코드의 문제가 뭐냐면요 렌더함수가 끝나고 콤마 쓰고 중괄호 썼죠
렌더함수의 세 번째 인자로 중괄호를 넘겨 주려고 했는데 이 안에 안 쓰고 이 함수 밖에 선언이 된 거죠
그러면 반환 값이 무슨 타입이냐면 튜플이 됩니다.
파이썬의 튜플은 여러 개의 값을 콤마로 구분을 하면 튜플이거든요
여기도 위와 똑같이 튜플 오브젝트는 get 속성이 없다고 나오죠
이 두 개가 흔히 처음 장고를 시작하시는 분들이 자주 겪는 오류니까요 잘 기억하시구요
그리고 인덱스 함수에서 None을 return한 경우 혹은 그냥 pass에서 return한 값이 없을 경우 둘 다 이제 non을 return한 상황입니다
그리고 인덱스 함수에서 return을 썼는데 return이 어떤 조건 하에서만 반환이 되는 거에요
그럼 이 조건이 아니면 return 값이 없잖아요
그러니까 위와 똑같이 non인 상황이 되어서 이와 같이 어떤 view 함수는 http response object를 return한 것이 아니라 non을 return했다는 에러가 발생을 하겠구요 
이 에러가 발생되는 지점은 장고의 베이스 핸들러에서 정답이 None 이면 이와 같이 Value Error 를 발생하는 코드가 있습니다
http 요청응답패킷 예시입니다
우리가 서버로 localhost:8000의 핫트랙에?query는?악뮤라는 주소로 요청을 받잖아요? 
?뒷부분이 ?string입니다.
브라우저가 해당 서버로 요청을 보낼테고 이렇게 http GET 요청이 날아갑니다
모든 http 요청과 응답에서는 헤더와 바디가 있어요 GET 요청에서는 헤더만 있고 바디는 없습니다
바디는 POST, PUT, PATCH 요청에는 요청 바디가 있겠구요
그리고 HTTP 헤더에서는 첫번째 줄에서는 요청의 종류 POST냐, GET냐, PATCH냐, PUSH냐, DELETE냐 등이 있겠구요 
어떤 주소로 어떤 프로토콜로 요청 되는지가 적혀있구요
두번째 줄부터는 요청 헤더 값이 쭉 있어요
긴 줄이 하나 있고 그 다음 줄부터 바디가 시작합니다.
view 함수는 리퀘스트하는 인자를 통해서 모든 요청 내역을 조회할 수 있는데요.
지원되는 속성 값이 많지만 view함수에서 일반적으로 사용하는 속성들을 나열해 봤습니다.
request 메소드라고 한다면 현재 요청 메소드를 출력하는 것이고요.
이 값이 이 값이 되는 것이고요.
Request.META의 REMOTE_ADDR로 접근하시면 요청 클라이언트의 IP 주소를 얻어오실 수 있고 Request.META의 HTTP_USER_AGENT라고 한다면 요청 헤더에
UserAgent라는 헤더가 있습니다
현재 요청 브라우저의 종류이고요
이 문자열을 이렇게 얻어오실 수 있고요 그리고 Query Parameter입니다..
이 물음표 뒤에 있는 이 문자열을 Query String이라고 부르고 이 Query String 을 가공해서 개별 값으로 뽑아내면은 Query Parameter 라고 부르는 것이구요 
그 여러 개의 query parameter를 request.get이라는 속성을 통해서 사전 타입으로 접근하실 수 있어요
기본 사전 타입에 확장 타입이 되겠구요
사전이니까 .get 메소드를 지원합니다
그래서 사전에서 이 지정 키가 있는지 보고 값이 있으면 반환하고 없으면은 디폴트 값을 반환하겠구요 
그리고 사전에 점겜
메소드에서 디폴트 값을 지정하지 않으면 해당 값이 있으면 반환하고요 문자로 반환합니다 
값이 없으면 None을 반환합니다
자 그리고 바디 데이터가 있죠
바디 데이터는 겟 요청에는 없는데 포스트나 푸트 패치에는 있다고 말씀드렸죠
그래서 점 바디는 이 원본 바디 데이터가 되겠구요
.post.files 라고 한다면 이 바디에 담긴 포스트 내역 그리고 이 바디에 담긴 업로드 된 파일 내역을 접근을 하실 수 있고 
그리고 HTTP의 리스폰스 객체에 대해서 키 벨류도 접근하시면 커스텀 헤더를 설정하실 수 있습니다
커스텀 헤더에는 보통 앞에 X로 시작을 합니다
응답 헤더에도 X 커스텀 헤더라고 그리고 지정된 값이 지켜있음을 확인하실 수 있습니다
상태 코드별 응답 예시인데요.
view 함수에서 http response를 통해서 응답을 생성하는 것은 가장 저수준의 응답이 되겠구요.
이걸 활용해서 다양한 포맷의 응답을 만들 수 있습니다.
이 응답 컨텐츠로는 문자열이나 혹은 이미지나 PDF나 Excel 파일이나 어떤 데이터든지 HTTP 리스폰스에다가 데이터를 지정해서 응답을 줄 수 있겠어요
여기에 지정한 값이 응답 바디에 담겨서 라이언트로 전달이 되는 것입니다
템플릿을 통해서 우리가 뷰응답을 만드실 때에는 렌더 함수를 사용하시면 편리해요.
렌더를 안 써도 직접 저수준의 API를 가지고 템플릿 응답을 만드실 수 있겠지만 렌더가 shortcuts라는 이 모듈 안에 정의가 되어 있습니다.
shortcuts에 정의가 되어 있는 이런 펑션들은 최대한 활용해 주시면 코드를 보다 간결하게 사용하실 수 있겠구요.
상태 코드 200은 현재 요청이 정상 처리되었음을 의미하는 OK 응답이 되겠습니다
그리고 301 응답과 302 응답이 있는데요
둘 다 페이지 이동 응답입니다
301은 해당 리소스가 영구히 다른 주소로 이동했음을 의미하고 새로운 주소로 응답을 주는 것입니다 
그래서 뷰 주소를 변경했거나 혹은 다른 서비스나 다른 뷰에서 092 처리하게 되었을 때 301 응답을 주는 것이 좀 더 의미에 맞겠고요 
그때는 redirect에 permanent true라는 옵션을 지정하면 되겠고요 
혹은 302는 다른 주소에서 092가 아니라 임시로 처리하고 있음을 의미할 때입니다 
로그인에 성공했을 때 혹은 포스팅을 생성하고 나서 다른 주소로 이동할 때 그런 경우에 302 응답을 씁니다
해당 요청을 처리한 후에 결과 페이지 등의 다른 주소로 이동을 시키는 거죠
이때는 그냥 redirect만 쓰시면 되겠습니다
자 그리고 404가 있겠는데요
404-page-not-found 혹은 not-found인데 이는 요청할 리소스가 없을 때입니다 
그래서 http의 response를 통해서 status라는 인자의 404 지정에서 응답을 줄 수도 있겠지만 흔히 이 세 가지를 사용하는 경우는 잘 없구요
네번째인 http404라는 이 예외를 raise 발생입니다.
return이 아니에요
예외를 발생시키면 장고 코어 단에서 404 응답을 생성합니다
그래서 404인 경우는 이렇게 예외를 수동으로 발생시키거나 혹은 우리가 뷰 함수 내에서 404 예외를 발생시키는 주된 케이스는 데이터베이스를 조회했을 때 해당 리소스가
없을 때죠 없을 때 이제 404 예외를 발생시키는 것이 일반적입니다
그럴때마다 데이터를 조회하고 없을 때 이 예외를 발생시키는 코드를 작성하는 것은 번거롭잖아요. 
매번 같은 코드가 반복이 되니까 그때 get_object_or_404를 쓰시면은 내부적으로 지정된 레코드가 없을 때 이 예외를 발생시켜 줍니다.
좀 더 편리하게 쓸 수 있고 이 펑션도 숏커스에 정의가 되어 있습니다.
그리고 500 Internal Server Error 인터널 서버 에러 같은 경우는 뷰 함수가 처리되는 중에 우리가 미처 처리하지 못한 오류가 발생을 했을 때에 오벡 에러로 기록이 됩니다
Internal Server Error가 보여지지 않도록 뷰 함수를 트라이 캐치로 꽁꽁 싸매지 마세요
미처 처리하지 못한 오류는 노출되어야 되고 그 오류를 우리가 인지할 수 있어야 그 버그를 확인할 수 있습니다.
에러를 100% 없앨 수는 없습니다.
오류를 100% 없앨 수는 없고 오류 상황을 잘 관리해서 유저가 불편함이 없도록 만들어주는 것이 중요하겠어요.
404 Bad Request와 403 Forbidden은 일반적인 웹페이지 환경에서 사용하는 상태코드는 아닙니다.
API 응답에서 많이 사용이 되겠고요.
일반적인 웹페이지에서도 이러한 상황이 발생하더라도 흔히 200 응답을 주는 경우가 많습니다. 
400 Bad Request 응답은 클라이언트 요청이 잘못되었을 때고요.
그리고 403 Forbidden은 요청 권한이 없을 때 발생을 시킵니다.