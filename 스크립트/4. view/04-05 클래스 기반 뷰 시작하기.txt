안녕하세요 이번 시간에는 클래스 기반 뷰 시작하기 입니다.
장고는 DRY 원칙을 핵심 가치로 채택하고 있습니다.
이는 중복된 코드의 반복을 피하고 재사용성을 강화하여 개발의 효율성을 높이고 유지 보수를
용이하게 하기 위한 원칙입니다.
장고는 이 원칙을 실현하기 위해 다양한 기능을 제공하는데 그 중 클래스 기반 뷰는 반복되는
뷰 패턴을 쉽게 재사용하고 확장할 수 있도록 도와줍니다.
이러한 접근 방식을 통해 개발자는 더 깔끔하고 유지보수가 간편한 코드를 구성할 수
있습니다. 클래스는 상속을 통해 쉽게 확장하고 재정의할 수 있습니다.
이는 코드의 재사용성과 유지보수성을 크게 향상시킵니다.
상속을 사용하여 공통기능을 부모 클래스에 정의하고 자식 클래스에서는 상속하여 공통기능을
활용하고 재정의을 통해 특정 기능의 동작을 변경할 수 있습니다.
함수는 절차적인 프로그래밍에 적합하며 간단한 로직이나 일회성 로직을 구현할 때 용이합니다.
한 번 정의된 함수는 새롭게 정의하지 않는 한 내부 구현을 변경할 수 없기 때문에 클래스에
비해서 재사용성이 상대적으로 부족합니다.
양쪽의 뷰 코드는 동일한 동작을 합니다.
왼쪽의 코드는 함수로 구현한 뷰이며 오른쪽의 코드는 장고 기본에서 제공해주는
ListView 클래스를 통해 구현한 뷰입니다.
함수 방식의 Vue에서는 절차적으로 구현되었기에 코드의 흐름을 한눈에 파악하기가 좋습니다.
클래스 방식의 Vue에서는 소스코드 임포트 시점에 클래스의 AsVue 클래스 함수를 통해
Vue 함수를 생성합니다.
설정에 가까운 코드로 Vue를 구현하는 것이 특징이며 변경을 원하는 기능이 있을 경우
클래스 상속과 메소드 재정에 일통해 손쉽게 적용할 수 있습니다.
앞서 구현한 두 개의 뷰에다가 검색 지원을 추가한다면요 클래스 구현에서는 각 기능이 메소드
단위로 분리가 되어 있습니다
그래서 가독성이 높고 유지 보수가 용이한데요 리스트 뷰에서는 getUnderBar
코디셋이라는 메소드가 있습니다
이 메소드를 통해서 해당 리스트 뷰에서 사용할 코디셋을 준비하는데요 이 메소드를 재정의해서
검색 로직을 이렇게 구현을 해볼 수 있습니다
이에만의 함수 기반의 Vue에서는 기존의 구현에다가 이렇게 검색 코드를 중간에 끼워 넣어야
됩니다 함수 방식에서는 코드의 길이와 복잡성이 증가하게 되고요 코드의 검색 로직을 기존의
페이징 로직과 이렇게 결합을 했죠
그래서 함수의 길이와 복잡성이 증가하고 재사용성이 감소합니다
기존 함수에다가 끼워 넣었으니까 만약에 다른 리스트뷰에서도 검색이 필요하면 이 코드를
복사해서 또 가져가야 되잖아요
그래서 재사용성이 감소합니다
그리고 검색 로직이 특정 함수에 이렇게 내장 되어 이 로직을 다른 뷰에서 재사용이 어렵고
그리고 이렇게 복사해서 넣었으니까 반복적인 코드를 여러 함수에 걸쳐 재작성하게 됩니다
이 로직을 함수에 바로 넣지 않고 별도 함수로 구현해서 이 함수 내에서 호출토록 하더라도
이 함수 내에서 그 함수를 호출하는 코드는 들어가는 거니까 그러니까 반복적인 코드를 여러
함수에 걸쳐 재작성하게 됩니다
그리고 가독성이 낮은데요 한 함수 내에 여러 기능들이 혼합이 될 수밖에 없죠
각 기능의 경계가 모호해져
코드를 읽고 이해하는 것이 좀 어려워질 수 있습니다 함수는 문법적으로 확장이 불가능하거든요
로그인이 필요한 시점에 단순히 로그인 페이지로 이동만 시키는 것이 아니라 로그인이
필요하다는 에러 메세지를 이렇게 추가로 보여주려고 하려면요 함수 기반 뷰에서는 이렇게
로그인 리퀘이어드 장식자를 붙이면 해당 뷰가 호출이 되는 시점에 로그인이 안되어 있으면
로그인 페이지로 이동을 시키거든요 로그인 리퀘어드 데코레이터에서는 이렇게 커스텀 메시지를
추가하는 기능은 없습니다 로그인 리퀘어드 데코레이터가 함수로 구현되면 확장하기는 불가능합니다
로그인 리퀘어드 데코레이터를 흉내낸 새로운 데코레이터를 만들어야 되겠고요 혹은 뷰 코드 내에서
이렇게 로그인 여부를 직접 검사하고 그리고 반복적인 코드를 여러 함수에 걸쳐 작성을 해야
되는 거죠.
이에만해 클래스 기반 뷰에서는 로그인 리퀘어드 장식자와 유사한 기능을 제공해주는 로그인
이콰이어드 믹스인이라는 클래스가 있습니다.
이 리스트 뷰에다가 이 기능을 섞을 때에는 이 두 개의 클래스를 상속받은 새로운 클래스를
이렇게 정리하고요 믹싱 클래스는 ListView 클래스보다 앞에 위치시켜야 됩니다
이는 Python 클래스 상속에서 mro라고 하는 상속에서의 메소드 호출 순서가 있습니다
mro의 기반에서 ListView의 메소드보다 앞에 지정한 클래스의 메소드가 먼저 호출이
될 수 있도록 이렇게 앞에다가 지정을 해주는 것이구요
LoginRequiredMixin 클래스를 상속받은 새로운 클래스를 만드는데요
LoginRequiredMixing 클래스는 로그인하지 않은 사용자를 접근하면
HandleNoPermission이라는 메소드를 호추합니다
이 메소드에서 로그인하지 않은 사용자를 접근하면 로그인 페이지로 이동을 하는 코드가
구현되어 있어요
기본 동작 외에 로그인이 필요하다는 에러 메시지를 추가하려고 하는 것이니까 해당 메서드를
재정의하고 부모의 메서드를 호출하면 기본 구현으로 호출 시점에 로그인 페이지로 이동합니다
부모의 HandleNoPermission을 호출하기 전에 이렇게 에러 메시지를 추가를
해주게 되면요 호출 시점에 로그인이 필요하다는 에러 메시지가 추가가 되는 거예요 함수 기반
기반뷰와 클래스 기반뷰를 간단하게 비교해 보겠습니다.
함수 기반뷰에 대한 충분한 이해 없이는 클래스 기반뷰 학습만 하는 것은 사상 누각입니다.
함수 기반뷰는 뷰 구현 학습의 기본입니다.
함수 기반뷰에 대한 충분한 이해가 클래스 기반뷰 구현의 기초를 형성하는데요.
이는 함수 기반 뷰 구현이 먼저 이루어진 후에 클래스 기반뷰를 통한 중복 코드 제거 및
재사용성을 높이거든요
이렇게 구현하는 것이 클래스 기반 뷰이기 때문에 필이 함수 기반 뷰로 여러분들이 기능을
구현할 수 있어야 클래스 기반 뷰를 더 잘 사용할 수 있게 됩니다
함수 기반 뷰는 함수이기 때문에 절차적인 흐름으로 뷰 동작을 구현하고 그렇기에 한눈에
이해하기가 쉽습니다
클래스에서는 여러 기능들을 메소드 단위로 구현하기 때문에 그리고 상속을 여러 번 하죠
해당 코드를 봤을 때 한 번에 이해하기는 어렵습니다
중복 제거 방식에서는 함수 기반 뷰는 함수이기 때문에 장식자를 통해서 기능을 추출할 수
있겠구요 클래스 기반 뷰에서도 장식자를 활용할 수 있지만 보통은 상속을 통해서 기능을 추출을
하게 됩니다.
확장성 및 재사용성 측면에서는 함수 기반 뷰는 함수이기 때문에 확장 및 재사용이 어려워요.
일회성 뷰를 구현하는 데는 적합합니다.
일회성 뷰는 재사용성을 고민할 필요가 없으니까 함수 기반 뷰로 작성하는 것이 관리하는
측면에 나을 수도 있어요.
클래스 기반 뷰는 클래스 상속과 메소드 오버라이딩을 통해 유연한 확장성을 제공합니다
아래 보시는 코드와 같이 함수 기반 뷰는 이렇게 절차적으로 코드를 작성하고요 클래스 기반뷰는
부모로 사용할 클래스를 여러 개 지정한 다음에 상속을 받고요 해당 부모에 있는 속성 혹은
메소드를 재정의하는 방식으로 구현을 하고 그 클래스에 제네릭 뷰 라는 클래스 함수 호출을
통해서 뷰 함수를 만들어내는 형태로 사용을 하게 됩니다
클래스 기반 뷰는 DRY 철학에 입각한 재사용 가능한 뷰인데요 상속과 믹스인(Mixin)을 통한 높은
재사용성입니다
속성만 재정의하는 경우에는 설정에 가까운 코드가 되요 장고 기본에서 다양한 빌트인(Built-in) 제네릭
뷰를 제공해 주는데요
기본 CRUD 즉 생성 조회 업데이트 삭제를 위한 뷰로서 리스트 뷰 디테일 뷰 크리에이트 뷰(CreateView)
업데이트 뷰 삭제 뷰(DeleteView)를 지원해 주고요 그리고 연월 주일 날짜 단위로 조회할 수 있는 뷰도
지원을 해주고 있습니다
메서드 오블라이딩을 통해 유연함을 지원해 주는데요
아래와 같이 해당 클래스에서 부모에 있는 메서드 중에 동작을 바꾸고자 하는 메서드를 이렇게
재정리하고 동작을 추가하고 부모의 메서드를 호출해서 원래의 동작을 수행하거나 부모의
메서드를 호출하지 않고 자식의 메서드만 수행하는 형태로도 구현을 하실 수 있습니다


클래스 기반 뷰 (CBV) 시작하기
장고는 DRY(Don't Repeat Yourself) 원칙을 핵심 가치로 채택하고 있으며, 이를 실현하기 위해 **클래스 기반 뷰(CBV)**를 제공합니다. CBV는 코드의 중복을 줄이고 재사용성과 확장성을 높이는 데 유리합니다. 클래스는 상속을 통해 공통 기능을 정의하고, 이를 자식 클래스에서 재사용하며 수정할 수 있어 유지보수성이 향상됩니다.

1. 함수 기반 뷰 (FBV) vs 클래스 기반 뷰 (CBV)
함수 기반 뷰(FBV):
절차적인 방식으로 구현됩니다.
코드 흐름이 간단하고, 한눈에 이해하기 쉽습니다.
재사용성 측면에서 제한이 있으며, 코드 중복이 발생할 수 있습니다.
클래스 기반 뷰(CBV):
클래스 상속과 메서드 오버라이딩을 통해 기능을 확장하고 재사용할 수 있습니다.
여러 기능을 메서드 단위로 나누어 관리할 수 있어 가독성과 유지보수성이 높습니다.
ListView, DetailView 등 장고에서 제공하는 기본 뷰를 상속하고, 필요한 기능만 수정할 수 있습니다.
2. 코드 구현 방식 비교
1) FBV 예시
python
코드 복사
def my_view(request):
    items = Item.objects.all()
    return render(request, 'my_template.html', {'items': items})
2) CBV 예시 (ListView 사용)
python
코드 복사
from django.views.generic import ListView
from .models import Item

class ItemListView(ListView):
    model = Item
    template_name = 'my_template.html'
CBV에서는 ListView를 상속받아 model과 template_name만 지정하면 기본적인 리스트 기능을 제공해줍니다.
추가적인 기능이 필요할 경우, get_queryset 등의 메서드를 오버라이딩하여 쉽게 확장할 수 있습니다.
3. 검색 기능 추가 비교
FBV에서 검색 기능을 추가하려면 기존 로직에 검색 로직을 삽입해야 하므로 코드가 길어지고 복잡해집니다. 재사용성도 떨어지며, 다른 뷰에서 검색 기능을 추가하려면 동일한 코드를 복사해야 합니다.

CBV에서는 get_queryset 메서드를 오버라이드하여 간단하게 검색 기능을 추가할 수 있습니다.

python
코드 복사
class ItemListView(ListView):
    model = Item
    template_name = 'my_template.html'

    def get_queryset(self):
        queryset = Item.objects.all()
        search_query = self.request.GET.get('search', '')
        if search_query:
            queryset = queryset.filter(name__icontains=search_query)
        return queryset
CBV는 기능을 메서드 단위로 분리하여 가독성과 유지보수성을 높이며, 중복 코드를 줄일 수 있습니다.
4. 로그인 필터링
FBV에서 로그인 여부를 처리하려면 데코레이터를 사용하여 로그인 여부를 확인한 후, 로그인하지 않은 경우 리디렉션을 해야 합니다.

CBV에서는 LoginRequiredMixin을 상속받아 로그인 필터링을 간편하게 처리할 수 있습니다.

python
코드 복사
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import ListView
from .models import Item

class ItemListView(LoginRequiredMixin, ListView):
    model = Item
    template_name = 'my_template.html'
    login_url = '/login/'
LoginRequiredMixin을 상속받은 클래스에서는 로그인하지 않은 사용자가 접근할 경우 자동으로 로그인 페이지로 리디렉션됩니다.
5. 클래스 기반 뷰의 확장성
FBV는 함수로 이루어져 있어서 기능을 확장하거나 재사용하는 데 한계가 있습니다. 필요할 때마다 코드를 복사하여 재사용해야 하며, 다른 기능을 추가할 때도 코드가 길어집니다.

CBV는 클래스 상속과 메서드 오버라이딩을 통해 확장성과 재사용성을 제공합니다. 예를 들어, 기본적인 CRUD(View) 기능을 제공하는 제네릭 뷰들을 쉽게 활용할 수 있습니다:

ListView: 객체 리스트를 표시하는 뷰
DetailView: 객체의 상세 정보를 표시하는 뷰
CreateView: 객체 생성 뷰
UpdateView: 객체 업데이트 뷰
DeleteView: 객체 삭제 뷰
이러한 제네릭 뷰들은 기본적인 동작을 제공하며, 필요한 부분만 오버라이드하여 사용할 수 있습니다.

6. 메서드 오버라이딩을 통한 유연성
CBV에서는 기본 제공되는 메서드를 오버라이드하여 동작을 수정할 수 있습니다. 예를 들어, get_queryset 메서드를 오버라이드하여 특정 필터링 로직을 추가할 수 있습니다.

python
코드 복사
class ItemListView(ListView):
    model = Item

    def get_queryset(self):
        queryset = super().get_queryset()  # 부모의 get_queryset 호출
        # 필터링 로직 추가
        return queryset
7. 클래스 기반 뷰의 장점
재사용성: 클래스를 상속하고 메서드를 오버라이드하여 기존 뷰를 쉽게 확장하고 재사용할 수 있습니다.
유지보수성: 코드가 잘 분리되어 있어 가독성이 높고, 유지보수가 용이합니다.
DRY 원칙 준수: 중복된 코드를 줄이고, 필요한 부분만 재정의하여 코드의 반복을 피할 수 있습니다.
8. 결론
FBV와 CBV의 차이점을 잘 이해하고, 클래스 기반 뷰의 유용성을 잘 활용하는 것이 중요합니다. FBV는 간단한 뷰 구현에 적합하고, CBV는 중복을 줄이고 재사용성을 높이며 유지보수가 쉬운 코드 작성을 가능하게 합니다. CBV를 활용하려면 FBV에 대한 이해가 먼저 필요하며, 이후 기능을 클래스로 확장하고 필요한 메서드만 수정하는 방식으로 구현하면 효율적인 개발이 가능합니다.



