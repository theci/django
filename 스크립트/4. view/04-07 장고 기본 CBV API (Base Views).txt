안녕하세요 이번 시간에는 장고 기본 클래스 기반뷰 api 중에 기본 뷰에 대해서 살펴보겠습니다.
장고 기본에서 지원해주는 클래스 기반뷰 api는 총 4개 카테고리입니다.
기본 뷰, 제네릭 조회 뷰, 제네릭 날짜 기반의 조회 뷰, 제네릭 수정 뷰가 되겠습니다.
기본 뷰로서 뷰, 템플릿 뷰, 리디렉트 뷰에 대해서 살펴보겠습니다.
View 클래스는 클래스 기반 View의 기본이 되는 클래스입니다
요청 HTTP 메소드 이름에 메소드 호출하여 요청을 처리하거든요
예를 들어 get 요청인 경우에는 get 메소드를 호출해서 요청을 처리하고요 post 요청의 경우에는 post 메소드를 호출해서 요청을 처리합니다
템플릿 뷰 클래스는 뷰 클래스와 컨텍스트 믹싱 클래스, 템플릿 리스폰스 믹싱 클래스를 상속받아서 구현이 되는데요
템플릿 응답을 렌더링 시에 사용을 하고 Redirect 뷰는 뷰 클래스를 상속을 받았으며 다른 주소도 이동 응답을 할 때 사용을 합니다
뷰 클래스는 클래스 기반 뷰 요청 처리에 기반이 되는데요 함수 기반 뷰에서 우리가 지정 pk에 포스팅을 조회해서 삭제하는 뷰 코드를 이렇게 작성을 해봤습니다 함수 기반 뷰를
이렇게 구현하시면은 포스트 요청을 비롯한 모든 타입의 HTTP 메소드 요청에서 이 뷰
암수가 호출되어 이 포스팅이 삭제가 됩니다
GET 요청에서도 포스팅이 삭제가 될 수 있어요 아래와 같이 view 함수 내에서 요청
메서드를 체크해서 post 요청일 때만 삭제하고 그 외에 요청에 대해서는 요청을 거부하도록
작성하는 것이 안전합니다
이와 같이 구현을 하시면은 POST 요청을 제외한 요청은 405 method not allowed 응답으로 거부하고요.
이는 잘못된 요청이나 의도치 않은 get 요청으로부터 애플리케이션을 보호할 수 있습니다.
require_http_methods라는 장식자를 통해 간결하게 허용할 HTTP 메서드를 제한할 수 있습니다.
이외에도 require_GET, require_first, require_safe 장식자가 지원됩니다.
함수 기반 뷰에서의 http 메소드를 제한하는 방법에 대해서 살펴봤고요
클래스 기반 뷰에서는 지원할 메소드 이름의 메서드만 구현하면 끝입니다
이 클래스 기반 뷰에서요 post 메서드를 구현했습니다
그러면 나머지 메소드에 대한 요청은 뷰 함수에 dispatch 메서드 구현해서 405 메서드 not allowed 응답으로 거부됩니다
우리가 주로 구현할 메서드는 get, post, put, patch, delete 이렇게 다섯 개입니다
이렇게 구현하신 각 메서드에는 함수뷰에서 받는 인자가 그대로 전달됩니다
즉, request 인자 외에 urlcapturedvalue 값이 인자로 전달되기 때문에 이와 같이 urlcapturedvalue 값을 인자로 받을 수 있습니다
파이썬 클래스에서의 속성 검색 순서에 대해서 살펴보겠습니다.
클래스 변수는 같은 클래스로 만들어진 모든 인스턴스와 클래스 자체에서 공유되는 값입니다.
반면에 인스턴스 변수는 그 인스턴스에만 적용되는 값이죠.
인스턴스에서 속성을 찾을 때에는 먼저 인스턴스 변수를 찾아보고 없으면 클래스 변수를 참조합니다 
인스턴스 변수와 클래스 변수는 서로 별개의 변수이기에 인스턴스 변수를 설정한다고해서 클래스 변수를 오버라이트 하는 것은 아닙니다 
예시코드로 person 클래스를 하나 만들었습니다
name 이라는 이름에 클래스 변수를 하나 설정했구요
그에 대한 값으로 익명이라는 문자를 할당했습니다 생성 잠수에서는 name이란 이름의 키워드
인자가 있으면 그 값이 있다면 instance 변수 name을 생성하도록 했습니다
아래의 코드에서 class를 통한 속성 조회에서는 class 변수만을 찾습니다
그렇기 때문에 출력에서는 class 변수가 출력되어 익명이라는 문자 아이디 출력이 되겠구요
instance를 통한 속성 조회에서는 instance 변수를 먼저 찾고 없다면 class
변수를 찾습니다
person 이라는 클래스의 인스턴스를 만들 때 인자로 name 이라는 인자를 넘겼죠
그러면 이 인스턴스가 생성되는 시점에 name 이라는 인스턴스 변수가 생성이 됩니다
p1.name 을 출력하면은 클래스 변수가 아니라 인스턴스 변수 값인 이 값이 참조가 되어
time 을 출력하는 것이구요
P2 인스턴스에서는 name 이라는 키워드 인자 지정이 없었죠
그렇기 때문에 인스턴스 변수 name이 없기에 클래스 변수인 익명이 이렇게 출력이 되는
것입니다 새로운 Python 클래스 DynamicAttribute 라는 클래스를 만들고
생성자에서 인자로 만든 키워드 인자들을 개별 인스턴스 변수로 저장하는 코드를 작성했습니다
이 Person 클래스의 생성자에 대한 일반화된 구현이 되겠습니다
setattr 함수를 사용하여 해당 인스턴스에 해당 이름으로 값을 설정하여 새로운 인스턴스
변수를 저장하는 것이고요.
같은 이름의 클래스 변수가 있다면 속성 참조 시에 우선순위를 갖는 인스턴스 변수들을 생성할
목적으로 이 코드를 작성했습니다.
클래스 변수의 값을 오버라이트 하는 것이 아니라 단지 우선순위를 먼저 갖는 인스턴스 변수를
생성하는 것입니다.
아래의 Person 클래스는 DynamicAttributes라는 클래스를 상속을 받았죠
그리고 클래스 변수로서 Name이라는 클래스 변수를 선언하여 익명이라는 디폴트 값을 지정을
했습니다 자 이제 같은 이름의 Name 클래스 변수보다 우선순위를 갖는 인스턴스 변수
Name이 생성이 되도록 Person 클래스의 생성자에다가 Name이라는 이름의 인자를
넘깁니다 name을 지정한 이유는 해당 person 클래스에 name이라는 클래스 변수가
있기 때문에 이 이름과 맞춰서 이름을 지정한 거예요
이렇게 지정하시면 name이라는 이름에 클래스 변수가 있지만 이 속성 참조에서 인스턴스
변수가 더 우선순위를 가지기 때문에 time이라는 문자에 출력이 되는 것이고요 아래
코드에서는 인스턴스 변수 네임 생성이 없었죠
그렇기 때문에
.네임속성참조에서
클래스 변수 네임값을 참조하기 때문에 이 출력에서는 익명이라는 문자일이 출력되게 됩니다.
장고 기본에서 지원해주는 Vue 클래스는 앞서 살펴보신 DynamicAttribute
클래스의 생성자와 마찬가지로 인자로 전달받은 키워드 인자들을 개별 인스턴스 변수로 저장하는
이러한 로직이 동일하게 구현이 되어 있습니다
이 로직이 수행이 되면은 같은 이름의 클래스 변수가 있으면은 그 클래스 변수보다 우선순위를
갖는 인스턴스 변수들을 생성할 목적이죠
클래스 변수들의 값을 오버라이팅 하는 것이 아니라 별개의 변수인 인스턴스 변수를 만드는
것입니다 그리고 Vue 클래스에서는 asVue 단 이름의 클래스 메소드가 구현이 되는데요
AsVue 클래스 메소드가 호출이 될 때에 인자로 전달받은 키워드 인자가 실제 view
호출이 되어서 요청을 처리할 때에 해당 클래스의 인스턴스를 만들 때 인자로 받은 키워드
인자를 그대로 전달합니다
즉, as view를 통해서 전달받은 키워드 인자들이 그대로 개별 인스턴스 변수로 저장이
되어서 해당 클래스만 view의 속성값으로 활용이 되는 거죠
템플릿 뷰 클래스는 뷰 클래스를 상속 받았기 때문에 생성자로 전달된 키워드 인자들이 개별
인스턴스 변수로 저장됩니다.
템플릿 네임 클래스 변수를 하나 정리했구요.
슬라이드 코드에서는 생략했지만 템플릿 뷰 클래스를 템플릿 네임 속성 값을 활용해서 템플릿
응답을 만들 것입니다.
그런데 템플릿 네임 클래스 변수는 디폴트 값이 non이니까 값 지정이 필요한 상황입니다.
해당 속성 값을 정의하는 첫 번째 방법으로 인스턴스 변수 템플릿 네임 값을 따르는
index1 view 함수를 생성할 수 있습니다
템플릿 view.asview 함수 출시에 템플릿 네임 인자를 지정했으니 이 값은 인스턴스
변수도 지정되어 템플릿 네임 속성 참조 시에 사용이 됩니다
해당 속성 값을 정의하는 두 번째 방법으로 템플릿 뷰 클래스를 상속받은 새로운 클래스
인덱스 뷰를 정의하고 템플릿 뷰의 클래스 변수 템플릿 네임을 재정리할 수 있습니다.
이렇게 정의된 인덱스 뷰 클래스의 index 뷰를 통해 생성된 index2 view 함수는
as view 함수 호출 시에 인자를 정의하지 않아도 템플릿 네임 속성 값을 조회할 때
index view 클래스의 클래스 변수, 템플릿 네임 값을 사용하게 됩니다.
템플릿 뷰 클래스 소스 코드를 살펴보면서 내부 동작에 대해서 이해를 해보겠습니다.
템플릿 뷰는 GET 요청을 받으면 GET context data 함수를 호출하여 템플릿에
전달할 사전 값을 구성하고 렌더 툴 리스판스를 호출하여 뷰응답을 생성합니다.
템플릿 뷰는 ContextMixin 클래스를 상속받고 있고, 이 클래스를 통해
GetContextData 메서드가 제공됩니다.
extra_context 클래스 변수는 정적인 ContextData를 설정할 목적입니다.
self 호출 시에 ExtraContext 값을 설정할 수 있습니다.
만약 조회하거나 계산된 값을 ContextData로 넘겨줘야 한다면
GetContextData 메서드를 재정리해서 구현합니다.
날씨였습니다. 템플릿 뷰는 템플릿 리스폰스 믹싱 클래스를 상속받고
있고 이 클래스를 통해 렌더 툴 리스판스 메소드가 제공됩니다.
렌더 툴 리턴스 메소드에서는 GetTemplateNames 메소드를 통해 렌더링할 템플릿
파일을 찾고 있고 GetTemplateNames 메소드에서는 템플릿 네임 설정 값으로
템플릿 경로를 반환합니다.
그러니 템플릿 리턴스 믹싱 클래스에서는 템플릿 네임 속성 정의가 필수겠네요.
렌더 툴 리턴스 메소드에서 템플릿 경로를 계산하고 나서 리턴스 클래스 속성을 호출하여
뷰응답을 생성하는데요 리턴스 클래스 속성은 디폴트도 템플릿 리턴스 클래스입니다
템플릿을 통해 뷰응답을 생성하며 뷰생성 방식을 변경하려면 리턴스 클래스 속성을 재정리해서
변경하실 수 있습니다
템플릿 뷰 예시입니다.
거의 모든 클래스 기반 뷰는 템플릿 뷰를 상속 받습니다.
그만큼 자주 사용하실 코드입니다.
함수 구현부터 살펴보겠습니다.
index1 함수 기반 뷰는 인자로 pk를 받습니다.
렌더 함수 호출 시에 템플릿에서 사용할 컨텍스트 데이터를 사전으로 이렇게 정리했고 정적인
데이터 성격으로서 name 이라는 키로 파이썬 사랑방 문자를 지정했습니다
그리고 pk란 이름으로 pk 값을 전달했는데요
이 pk 값은 view 호주 시점에 결정되는 데이터죠
이번에는 템플릿 view.asview 호출을 통해서 index2라는 view 함수를 만들어
보겠습니다 사용할 템플릿은 이 값은 정적인 데이터죠
그렇기 때문에 as_view 함수 호출시에 이렇게 지정하실 수 있습니다
extra context라는 이 값도 as_view 호출시에 이렇게 지정을 했는데요
name이라는 값은 정적인 데이터이기 때문에 As View 호출 시에 이렇게 지정을 할 수
있습니다.
소스코드가 임포트되는 시점에 As View 함수가 호출이 되는 거예요.
이 View 함수가 호출이 되는 시점에 As View가 호출되는 것이 아닙니다.
As View 함수는 소스코드가 임포트되는 시점에 호출이 됩니다.
이 시점에 결정되는 정적인 데이터는 extra context 속성으로 지정하실 수
있습니다. 자 그런데 view 호출 시점에 결정되는 이런 pk 같은 값은 익스트라
컨텍스트에 지정할 수 없어요
그쵸 어디에서 참조할 방법이 없습니다
view 호출 시점에 결정되는 이러한 값들을 우리가 컨텍스트 데이터에 지정을 하려면
get_context_data 라는 메서드를 재정의 해야 되구요
이를 위해서 템플릿 뷰를 상속받은 index.view 클래스를 새롭게 정의했습니다
여기에 클래스 면수로서 템플릿 네임을 지정했고 엑스트라 데이터도 지정했죠
이 값들은 index.view.as_view 호출 시에 여기에 지정하실 수도 있겠지만
index.view 관련된 설정들은 as_view 호출 시에 지정하시기 보다 이렇게 클래스 면수로서
지정하시는 것이 좀 더 훨씬 관리하시기 좋습니다
자 정적인 데이터는 이렇게 정했고 동적인 데이터는 method 호출 시에 동적으로 할당을
해줍니다 get_context_data 메서드를 재정의하고 부모의
get_context_data를 호출해서 템플릿 뷰의 기본 context data를 사전으로
가져오고요 이 사전에 key 값을 이렇게 할당해서 변경된 사전을 return을 하는 식으로
구현을 하실 수 있게 됩니다

이번에는 리디렉트 뷰 4가지 예시를 살펴보겠습니다.
이 뷰 클래스는 서비스에서 한두 번 정도 사용될 정도로 사용 빈도가 낮습니다.
함수 기반 뷰로 리디렉트 쇼컬 함수 사용이 더 간편하고 직관적일 수 있습니다.
첫 번째 예시로 url 문자애를 직접 조합하는 경우입니다.
view1 함수 구현에서는 redirect 쇼컷 함수 호출시에 조합한 url 문자열을를
지정합니다.
redirect view.asview 호출에서는 url 인자로 조합한 url 문자열을
지정하면 지정한 주소로 이동하는 view1 view 함수가 만들어집니다.

두 번째 예시로 url 문자를 직접 조합할 때 url-captured-values를
활용하는 경우입니다.
url 문자를 조합할 때 python2부터 지원되는 방식과 python2.6부터 지원되는
방식을 사용할 수 있습니다.
Python 2.6부터 지원되는 포맷 메소드는 함수인자로 처리되는 방식이기에 더 유연하고
더 다양한 포맷 옵션을 제공합니다.
AsView 인자 방식에서는 동적으로 View 인자를 조합할 수 없습니다.
AsView 인자들은 소스코드 임포트 시점에 각 값들이 고정되기 때문입니다.
리디렉트 뷰 내에서는 urlcapturedvalues와의 조합을 지원하기 때문에 동적으로
조합하려면 클래스를 상속받아 메소드 재정의가 필요하지만 urlcapturedvalues를
활용할 경우 이와 같이 인자명 지정만으로도 충분합니다

세 번째 예시는 url-reverse를 활용하는 경우입니다.
아직 url-reverse를 다루진 않았는데요.
url-reverse는 url 문자들보다 유연하고 손쉽게 생성할 수 있는 장고의 기능입니다.
redirect-shortcut 함수는 url-reverse 기능도 제공합니다.
redirectView에서는 PatternName 속성으로 urlReverse를 적용할 패턴명을 지정하면 redirectView 클래스의 getRedirectUrl 메소드 내에서
urlReverse를 수행하고 반환된 주소로 이동을 합니다.

네번째 예시는 urlReverse와 urlCapturedValues를 활용하는 경우입니다.
아래 URL 패턴 정의일 경우 URL 조합 시에 PK 인자가 필요합니다.
view4 함수 내에서 redirect shortcut 함수에서는 URL 리버스 시에 추가 인자가 필요하다면 이렇게 인자를 지정합니다.
그런데 redirect view as view 호출에서는 view 호출되는 시점에 결정되는 데이터를 참조할 수 없습니다.
그런데 redirect 뷰의 get redirect url 메소드 내에서는 url reverse를 수행할 때 자동으로 url captured values 값을 url reverse 함수인자로 지정을 해주니까 
패턴명을 지정하실 때에는 특별히 url captured values 값을 지정하실 필요 없이 패턴명만 지정하시면 됩니다 
활용 예시 코드를 작성해 봤습니다



최상위 주소에 대해서 현재 이를 처리하는 뷰가 없는데요 아래와 같이 세 가지 방식으로 처리를 해볼 수 있겠습니다
첫 번째 방식으로 템플릿 뷰 클래스를 활용해서 템플릿 응답을 생성합니다
템플릿 파일은 특정 장고 앱 안에 있는 템플릿 폴더가 아닌 별도의 경로에 저장하겠습니다.
앱 디엑토리 내 템플릿 경로에는 그 앱과 관련된 템플릿 파일을 두는 것이 적절하며 특정 앱에 기속되지 않은 템플릿 파일은 앱 디렉토리 외부에 두는 것이 적절하기 때문입니다.
마이 사이트 밑에 템플릿 밑에 root.html 템플릿 파일를 생성하고 settings.templates 설정에서 dirs 이름의 리스트에 마이 사이트 밑에
템플릿 디엑토리 경로를 추가하여 장고에서 템플릿 파일를 찾을 때 이 경로에서도 템플릿 파일를 찾을 수 있도록 설정합니다.
두 번째 방식은 다른 주소도 이동을 시킬 때 직접 url을 조합하는 방식입니다.
함수 뷰에서 redirect 함수를 써도 되고, redirect 뷰 클래스에서 url 키워드 인자를 통해 이동할 주소를 지정할 수 있습니다.
이동할 주소에서 서버 주소를 생략하면 같은 서버 내에서 지정 페이지로 이동을 합니다.
슬래쉬로 시작하는 주소는 절대 주소로써 웹사이트 루트에서 시작하는 주소입니다.
상대 주소는 현재 페이지 위치에 따라 주소가 가변적으로 계산되기 때문에 웹 개발에서는 서버 리소스를 표현하는 URL에서 절대 주소를 쓰시기를 권장합니다.
세 번째 방식은 url-reverse를 이용하여 다른 주소로 이동시키는 것입니다.
이 방법은 두 번째 방식과 유사하지만 직접 url을 조합하는 대신 장고에게 url 조합을 맡깁니다.
url-reverse를 활용하면 요청이 url 패턴과 일치하는지 확인하고 url 조합에 실패할 경우 오류를 반환합니다.
이를 통해 안정적으로 URL을 조합할 수 있으며 URL 변경 시에도 이에 적응하여 자동으로 새 URL을 생성합니다.
또한 복잡한 URL도 가독성 높게 조합할 수 있는 장점이 있습니다.
URL 리버스를 위해서 코어 앱 밑에의 urls.py 파일에 앱 네임과 패스 네임을 추가로 지정했습니다.
URL 리버스에 대해서는 이후 챕터에서 자세히 살펴보겠습니다.
root.html 템플릿 예시는 이와 같습니다.
이 템플릿을 활용하여 응답이 생성되면 오른쪽 스크린샷과 같이 실행이 됩니다.
직접 데모는 생략하겠으며 슬라이드 코드를 보시면 유화될 패턴들을 바꿔가며 실습해보세요.


이번 내용은 **장고의 기본 클래스 기반 뷰(View Class)**에 대해 설명하고 있으며, 주요 클래스 기반 뷰의 종류와 활용 방법을 다루고 있습니다. 이를 정리하면 다음과 같습니다:

1. 장고 클래스 기반 뷰 (Class-Based Views)
장고에서 제공하는 클래스 기반 뷰는 크게 4가지 카테고리로 나눌 수 있습니다:

기본 뷰
제네릭 조회 뷰
제네릭 날짜 기반 조회 뷰
제네릭 수정 뷰

2. 기본 뷰 (Base Views)
2.1. View 클래스
View 클래스는 모든 클래스 기반 뷰의 기본이 되는 클래스입니다.
HTTP 메소드(GET, POST 등)에 따라 적절한 메서드가 호출됩니다. 예를 들어, get() 메소드로 GET 요청을 처리하고, post() 메소드로 POST 요청을 처리합니다.
요청 메소드에 따라 적절히 메서드를 구현하고, 그 외의 요청은 405 Method Not Allowed로 처리됩니다.
dispatch() 메서드를 통해 요청을 분기 처리합니다.

2.2. 템플릿 뷰 (TemplateView)
TemplateView는 템플릿 렌더링을 처리하는 뷰입니다.
ContextMixin과 TemplateResponseMixin을 상속받아 템플릿과 컨텍스트 데이터를 처리합니다.
템플릿을 렌더링할 때 사용할 템플릿 이름을 template_name 속성으로 설정합니다.
get_context_data() 메서드를 오버라이드하여 템플릿에 전달할 데이터를 동적으로 추가할 수 있습니다.

2.3. 리디렉트 뷰 (RedirectView)
RedirectView는 다른 URL로 리디렉션을 처리하는 뷰입니다.
url 속성을 사용하여 리디렉트할 URL을 지정하거나, pattern_name을 사용해 URL 패턴 이름을 기반으로 리디렉션을 할 수 있습니다.
URL에 동적으로 값을 삽입해야 할 경우 url-captured values를 활용할 수 있습니다.

3. 클래스 기반 뷰의 HTTP 메소드 처리
함수 기반 뷰(FBV)에서는 @require_http_methods 등의 데코레이터를 사용해 HTTP 메소드 제한을 했습니다.
클래스 기반 뷰(CBV)에서는 각 HTTP 메소드에 대한 처리 메서드 (get(), post(), put(), delete() 등)를 구현하면 됩니다.
각 메서드는 request, args, kwargs를 인자로 받아 HTTP 요청을 처리합니다.

4. 인스턴스 변수와 클래스 변수
인스턴스 변수는 객체에 종속되고, 클래스 변수는 클래스에 종속됩니다.
인스턴스에서 속성을 찾을 때, 우선적으로 인스턴스 변수를 찾고 없으면 클래스 변수를 참조합니다.

5. 템플릿 뷰의 동작
템플릿 뷰는 get_context_data() 메서드를 통해 템플릿에 전달할 데이터를 준비하고, render_to_response() 메서드를 통해 응답을 반환합니다.
extra_context 속성은 정적인 데이터를, get_context_data()는 동적인 데이터를 템플릿에 전달할 때 사용됩니다.

6. 리디렉트 뷰 활용
리디렉트 뷰는 주로 다음과 같은 방식으로 사용됩니다:

URL 문자열 직접 조합: RedirectView를 사용해 url 속성에 URL 문자열을 지정합니다.
url-captured values 활용: URL 경로에 캡처된 값들을 사용하여 동적으로 URL을 구성합니다.
url-reverse 사용: URL 패턴 이름을 통해 URL을 역으로 생성할 수 있습니다.
url-reverse와 url-captured values 결합: URL 리버스 시 동적으로 값이 포함되도록 url-captured values를 활용합니다.

7. 템플릿 뷰와 리디렉트 뷰 예시
템플릿 뷰를 사용하여 템플릿 응답을 생성하거나, 리디렉트 뷰를 사용하여 다른 페이지로 리디렉션하는 방법을 다뤘습니다.

8. 장고에서 템플릿 파일의 위치
템플릿 파일을 앱 내의 templates 폴더가 아닌, 프로젝트 루트의 templates 디렉토리에 저장할 수 있습니다.
settings.py에서 TEMPLATES 설정을 통해 이 경로를 추가하여 장고가 해당 경로에서 템플릿을 찾을 수 있도록 합니다.

결론
장고의 클래스 기반 뷰는 함수 기반 뷰보다 더 구조화되고 재사용 가능한 뷰를 작성하는 데 유리한 접근법을 제공합니다. 
다양한 믹스인과 메서드를 활용하여 뷰를 구성할 수 있으며, 템플릿 렌더링, 리디렉션 처리 등 다양한 기능을 클래스 기반으로 간결하게 구현할 수 있습니다.



