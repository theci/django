안녕하세요. 이번 시간에는 클래스 기반 뷰에 뷰 장식자 입히기입니다.
장식자는 어떤 함수, 클래스를 감싸는 목적의 함수입니다.
감싼 함수의 기능을 확장할 뿐, 변경할 수는 없습니다.
ProtectedView1 함수에서는 LoginRequired 장식자가 적용되어 있습니다.
이는 ProtectedView1 함수를 호출하기 전에 LoginRequired 내에 구현된 로직을 통해 인증 상태를 먼저 확인하고 미인증 상태라면 로그인 페이지로 리다이렉트 응답을 합니다. 
인증 상태라면 ProtectedView1 뷰 내에 로직이 수행되어 요청을 처리합니다.
오른쪽의 코드에는 장식자 문법은 없지만, 로그인 장식자의 반환 값으로 할당된 함수는 왼쪽의 함수와 동일한 동작을 합니다.
로그인 리퀘이어드 인자로 넘긴 함수와 같은 이름의 변수에 반환 값을 덮어 쓰는 것이 장식자 문법의 포인트입니다.
로그인 리퀘이어드 장식자는 함수이며, 인자로 전달된 함수를 랩핑한 함수를 반환합니다.
이제 프로텍티드 뷰 2 함수는 프로텍티드 뷰 1 함수와 동일한 동작을 합니다.
함수 기반 뷰에서는 장식자로 기능을 확장만 할 수 있고요.
클래스 기반 뷰에서는 클래스 상속을 통해 기능을 확장하고 기능을 변경할 수도 있습니다.
그리고 클래스에서도 장식자를 적용할 수 있습니다.
클래스 기반뷰의 .asView 함수를 통해 반환된 값은 함수입니다.
그러니 로그인 인자로 넘겨 랩핑한 뷰 함수를 만들 수 있습니다.
이런 방식의 장식자 적용은 외부 라이벌리 함수를 랩핑할 때 유용합니다.
혹은 클래스의 인스턴스 메서드에 직접 장식자를 적용할 수 있습니다.
이때에는 메서드 데코레이터 장식자를 활용합니다.
클래스 기반 뷰에서의 모든 요청 처리의 시작은 Dispatch 메서드로부터 시작되어 각 요청 메서드에 맞게 Get, First, Put, Delete 등의 메서드를 통해 요청을 처리합니다. 
그러니 LoginRequired 장식자는 Dispatch 메서드에 적용하는 것이 적절합니다.
Dispatch Method의 장식자 적용을 위해 Dispatch Method를 재정의하고 Method Decorator 장식자를 적용합니다.
앞선 방식은 Dispatch Method의 장식자 적용을 위해 Dispatch Method를 재정의했는데요.
메서드 데코레이터 장식자를 클래스에 직접 적용하고, Name 속성으로 장식자를 적용할 메서드명을 지정하면, 해당 메서드를 재정의하지 않아도 장식자를 적용할 수 있기에 편리합니다. 
클래스 기반 뷰에 장식자를 적용하실 때에는 이 세 번째 방법을 추천드리며 상황에 따라 첫 번째 방법도 좋습니다.
하지만 클래스 기반 뷰에 장식자를 적용하기보다 믹싱 클래스를 상속받는 형태도 많이 사용합니다. 
동일한 기능에 믹싱 클래스가 없고 장식자만 제공되는 경우도 있으니 상황에 맞게 적용을 해주세요.
뷰에서의 인증 여부 검사 부분은 생성, 수정 요청을 처리할 때 적용을 해 보겠습니다.



이번 시간에는 **클래스 기반 뷰(Class-Based Views, CBV)**에 **뷰 장식자(Decorator)**를 적용하는 방법에 대해 다뤘습니다. 장식자와 클래스 기반 뷰에서 이를 활용하는 방법을 정리하면 다음과 같습니다.

1. 장식자(Decorator) 개념
장식자는 함수나 클래스를 감싸서 기능을 확장하는 함수입니다.
장식자는 기존 함수의 동작을 변경하지 않고 추가적인 기능을 더할 수 있습니다.
예를 들어, LoginRequired 장식자는 사용자가 인증되지 않았다면 로그인 페이지로 리다이렉트하고, 인증된 사용자는 원래의 뷰 로직을 실행합니다.
2. 함수 기반 뷰에서의 장식자 사용
LoginRequired와 같은 장식자는 함수 기반 뷰에서 사용될 수 있습니다. 이 장식자는 뷰 함수의 동작을 확장하는데, 예를 들어 인증 체크 기능을 추가합니다.
함수 기반 뷰에서는 장식자를 적용해 기능을 확장만 할 수 있으며, 기존의 뷰 함수는 그대로 유지됩니다.
3. 클래스 기반 뷰에서의 장식자 적용
클래스 기반 뷰에서는 장식자 기능을 클래스 상속을 통해 확장하거나, 장식자를 메서드에 직접 적용할 수 있습니다.

클래스 기반 뷰에서 장식자를 적용하는 방법은 다음과 같습니다:

as_view() 메서드를 이용한 장식자 적용:
as_view() 메서드는 클래스 기반 뷰를 함수로 변환합니다. 따라서 이 함수에 장식자를 적용하여 뷰의 동작을 변경할 수 있습니다.
예를 들어, 로그인 요구를 적용하려면 LoginRequired 장식자를 as_view()로 감싸면 됩니다.
메서드 데코레이터를 통한 장식자 적용:
클래스 내의 특정 메서드에 직접 장식자를 적용할 수 있습니다. 예를 들어, dispatch() 메서드에 LoginRequired 장식자를 적용하면, 모든 요청이 dispatch() 메서드를 통해 처리될 때 인증 여부를 확인할 수 있습니다.
이 방법은 특정 메서드에 장식자를 적용하는 편리한 방법입니다.
장식자 대신 믹스인(Mixin) 클래스 사용:
클래스 기반 뷰에서 인증 여부와 같은 기능을 처리할 때 **믹스인(Mixin)**을 사용하는 방법도 많이 활용됩니다.
믹스인 클래스는 장식자보다 더 세밀하게 기능을 확장할 수 있는 방법으로, 장식자가 제공되지 않는 경우에는 믹스인을 사용하여 기능을 구현할 수 있습니다.
4. 클래스 기반 뷰의 요청 처리
클래스 기반 뷰는 dispatch() 메서드에서 요청을 처리하는 방식입니다. 요청에 따라 get(), post(), put(), delete() 등의 메서드가 호출됩니다.
dispatch() 메서드에 장식자를 적용하면, 요청이 해당 메서드를 통해 처리되기 전에 인증과 같은 추가적인 처리를 할 수 있습니다.
5. 장식자 적용 방식
방법 1: dispatch() 메서드를 재정의하고 그 안에 장식자를 적용하는 방법.
방법 2: 메서드 데코레이터를 사용해 클래스에 장식자를 적용하는 방법. @method_decorator를 사용하면 dispatch() 외에도 다른 메서드에 장식자를 적용할 수 있습니다. 이는 권장되는 방법입니다.
방법 3: 믹스인 클래스를 사용하여 인증 등의 기능을 처리하는 방법. 믹스인을 사용하면 장식자보다 더 유연하게 기능을 추가할 수 있습니다.
6. 추천 방법
메서드 데코레이터 장식자 적용 방법을 추천합니다. 이 방법은 클래스 내의 메서드에 장식자를 적용할 수 있어 매우 편리하고, 재정의할 필요 없이 특정 메서드에만 적용할 수 있습니다.
다만, 믹스인을 사용하는 방법도 인증 처리 등에서 매우 유용하므로 상황에 맞게 선택하면 좋습니다.
7. 실제 적용 사례
인증 여부 체크는 생성이나 수정 요청을 처리할 때 적용할 수 있습니다. 예를 들어, 인증이 필요한 페이지에서 인증되지 않은 사용자가 접근하면 로그인 페이지로 리디렉션되도록 장식자를 사용할 수 있습니다.
요약
**장식자(Decorator)**는 함수나 메서드의 기능을 확장하는 데 사용됩니다.
**클래스 기반 뷰(CBV)**에서는 as_view() 메서드에 장식자를 적용하거나, 메서드 데코레이터를 사용하여 특정 메서드에 장식자를 적용할 수 있습니다.
믹스인을 활용하면 장식자보다 더 세밀한 기능 확장이 가능합니다.
메서드 데코레이터 방식이 가장 일반적이고 추천되는 방법입니다.


