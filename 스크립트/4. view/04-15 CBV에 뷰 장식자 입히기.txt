안녕하세요. 이번 시간에는 클래스 기반 뷰에 뷰 장식자 입히기입니다.
장식자는 어떤 함수, 클래스를 감싸는 목적의 함수입니다.
감싼 함수의 기능을 확장할 뿐, 변경할 수는 없습니다.
ProtectedView1 함수에서는 LoginRequired 장식자가 적용되어 있습니다.
이는 ProtectedView1 함수를 호출하기 전에 LoginRequired 내에 구현된 로직을 통해 인증 상태를 먼저 확인하고 미인증 상태라면 로그인 페이지로 리다이렉트 응답을 합니다. 
인증 상태라면 ProtectedView1 뷰 내에 로직이 수행되어 요청을 처리합니다.
오른쪽의 코드에는 장식자 문법은 없지만, 로그인 장식자의 반환 값으로 할당된 함수는 왼쪽의 함수와 동일한 동작을 합니다.
로그인 리퀘이어드 인자로 넘긴 함수와 같은 이름의 변수에 반환 값을 덮어 쓰는 것이 장식자 문법의 포인트입니다.
로그인 리퀘이어드 장식자는 함수이며, 인자로 전달된 함수를 랩핑한 함수를 반환합니다.
이제 프로텍티드 뷰 2 함수는 프로텍티드 뷰 1 함수와 동일한 동작을 합니다.
함수 기반 뷰에서는 장식자로 기능을 확장만 할 수 있고요.
클래스 기반 뷰에서는 클래스 상속을 통해 기능을 확장하고 기능을 변경할 수도 있습니다.
그리고 클래스에서도 장식자를 적용할 수 있습니다.
클래스 기반뷰의 .asView 함수를 통해 반환된 값은 함수입니다.
그러니 로그인 인자로 넘겨 랩핑한 뷰 함수를 만들 수 있습니다.
이런 방식의 장식자 적용은 외부 라이벌리 함수를 랩핑할 때 유용합니다.
혹은 클래스의 인스턴스 메서드에 직접 장식자를 적용할 수 있습니다.
이때에는 메서드 데코레이터 장식자를 활용합니다.
클래스 기반 뷰에서의 모든 요청 처리의 시작은 Dispatch 메서드로부터 시작되어 각 요청 메서드에 맞게 Get, First, Put, Delete 등의 메서드를 통해 요청을 처리합니다. 
그러니 LoginRequired 장식자는 Dispatch 메서드에 적용하는 것이 적절합니다.
Dispatch Method의 장식자 적용을 위해 Dispatch Method를 재정의하고 Method Decorator 장식자를 적용합니다.
앞선 방식은 Dispatch Method의 장식자 적용을 위해 Dispatch Method를 재정의했는데요.
메서드 데코레이터 장식자를 클래스에 직접 적용하고, Name 속성으로 장식자를 적용할 메서드명을 지정하면, 해당 메서드를 재정의하지 않아도 장식자를 적용할 수 있기에 편리합니다. 
클래스 기반 뷰에 장식자를 적용하실 때에는 이 세 번째 방법을 추천드리며 상황에 따라 첫 번째 방법도 좋습니다.
하지만 클래스 기반 뷰에 장식자를 적용하기보다 믹싱 클래스를 상속받는 형태도 많이 사용합니다. 
동일한 기능에 믹싱 클래스가 없고 장식자만 제공되는 경우도 있으니 상황에 맞게 적용을 해주세요.
뷰에서의 인증 여부 검사 부분은 생성, 수정 요청을 처리할 때 적용을 해 보겠습니다.