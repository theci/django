포스팅 삭제를 구현해 보겠습니다.
DeleteView, Class-Based View에서 제공하는 삭제 프로세스는 GET 요청에서는 삭제
의사를 물어보는 입력 폼을 제공하고 유저가 삭제를 확인하는 액션으로 폼 제출을 하면 포스트
요청을 받아서 관련 모델 인스턴스를 제거하고 다른 주소로 이동 응답을 합니다.
이를 함수 기반으로 구현하면 이렇게 GET 요청과 POST 요청을 구분하여 구현하실 수
있습니다. 삭제 확인을 위해 비밀번호를 입력받거나 리캡쳐 등을 적용하려면 폼 필드 구성이
필요한데요. 현재 삭제는 가장 간단한 구성으로 폼필드 없이 POST 요청만으로 삭제를
구현했습니다.
그래서 폼 인스턴스 생성 없이 처리했고요.
템플릿에서는 별도 폼 인스턴스 렌더링 없이 폼 전송만을 하도록 구성했고요.
향후 폼이 추가되면 템플릿에도 반영을 해주세요.
삭제는 DeleteView 클래스 기반 뷰를 통해 제공되고요.
앞서 살펴본 함수 기반 뷰의 예시처럼 Get 요청과 POST 요청을 구분하여 처리합니다.
삭제를 위한 최소한의 설정으로 모델 속성을 통해 관련 모델 클래스를 지정하고,
Success URL의 속성을 통해 삭제 후에 이동할 주소를 지정합니다.
get 요청을 받으면 get_object 메서드를 통해 모델 인스턴스를 조회하고 템플릿
응답을 하고요.
post 요청을 받으면 get_object 메서드를 통해 모델 인스턴스를 조회하고 삭제를
수행한 후에 항공 URL로 이동하는 응답을 합니다.
함수 기반 뷰로 post delete 뷰를 먼저 구현해 보겠습니다.
인자의 pk 기본키로 모델 인스턴스를 조회하고 삭제 의사를 묻는 템플릿 응답을 하겠습니다.
템플릿 파일명은 파일은 밑에 모델명 소문자 언더바 컨펌 언더바 딜리트 점 HTML로 사용할
텐데요. 이는 삭제 뷰 클래스 기반 뷰에 설정된 default suffix 설정을 따라
작성했습니다. 이 규칙을 따르면 템플릿 램 속성을 따로 하지 않아도 관례대로 동작하기에
코드가 줄고 가독성이 좋아집니다.
템플릿 파일에서는 장고 폼 없이 폼 포스트 요청을 보내도록 간결하게 구성했고요.
url 패턴도 등록해줍니다.
포스트 디테일 템플릿에서 삭제하기 링크도 추가하겠습니다
그럼 디테일 페이지에서 삭제하기 링크가 보여지고 클릭해서 삭제하기 페이지로 잘 넘어가네요
지금은 삭제하겠습니다
버튼을 클릭해서 서버로 포스트 요청을 보내봐도 삭제가 되지 않습니다 PostDeleteView에서는
조회만 있을 뿐 아직 삭제와 페이지 이동 코드가 없기 때문이죠 포스트 요청일 때 조회한
모델 인스턴스를 제거하고 웹 로그에 포스트 뉴 페이지로 이동시키겠습니다
삭제를 했으니 게시물 목록 페이지로 이동을 시키면 좋은데 아직 게시물 목록 페이지 구현이
없어요 삭제를 하면 게시물 등록 페이지로 이동함을 확인하실 수 있습니다 삭제가 잘 된
상황입니다 이제 DeleteView 클래스 기반 뷰를 통해 PostDeleteView를
생성해 보겠습니다
PostDelete 함수는 삭제해 주시고요
DeleteView 클래스를 상속받는 PostDeleteView 클래스를 정의하고 모델
속성으로 PostModel 클래스를 success URL 속성으로 웹로그의 PostNew를
지정합니다. 그런데 서세스 URL 속성에 대해서는 클래스 기반 뷰에서 URL 리버스를
시도하지 않습니다.
URL 문자열로만 취급해요.
URL 리버스가 필요하다면 먼저 URL 리버스를 적용해서 서세스 URL 속성에 할당해줘야
합니다. 리버스 함수를 적용하시고 manage.py 런서버 개발 서버 터미널의 로그를
확인해 보세요.
MySiteURLs에 어떠한 패턴도 찾을 수 없다는 오류가 뜹니다.
Success URL은 PostDeleteView 클래스의 클래스 변수입니다.
리버스 함수를 호출해서 Success URL 클래스 변수의 값 할당을 시도하는 시점은
PostDeleteView 클래스가 정의되는 시점이에요.
즉, Django 프로그램이 시작될 때 리버스 함수를 호출해서 URL 리버스를 시도한다는
거죠. 이때는 아직 Django 프로젝트가 초기화되기 전 소스코드 임포트 시점입니다.
Django 프로젝트 초기화 전에 url-reverse를 수행했기 때문에 아직 정의된
url 패턴이 없다는 오류가 발생한 것입니다.
url-reverse 시도를 Django 프로젝트 초기화 이후로 늦춰야 합니다.
get-success-url 메서드로 구현하시는 방법도 있고요.
그럼 요청을 받는 시점에 URL reverse를 수행하겠죠.
다른 방법으로 Django는 reverse-lazy 함수를 제공해 줍니다.
reverse_lazy 함수를 호출하는 시점에는 아직 URL 리버스를 시도하지 않고요 그 반환 값을
사용하는 시점에 게으르게 URL 리버스를 수행합니다
그럼 해당 오류는 제거되고요 PostDeleteView가 아직 없다는 오류네요
PostDeleteView 클래스를 통해 PostDeleteView도 생성해 줍니다
포스팅 삭제를 해 보시면 Success URL에 지정한 대로 포스팅 생성 페이지로 이동함을
확인하실 수 있습니다.
포스팅 목록 페이지도 구현하고요.
각 페이지에 서로 간의 링크도 추가해 주겠습니다.
포스팅 목록을 보여줄 인덱스 뷰를 구현할 텐데요.
함수 기반 뷰로 구현하기보다 리스트 뷰, 클래스 기반 뷰를 활용하겠습니다.
리스트 뷰를 활용하면 향후에 페이징 처리나 검색 구현하기도 용이합니다.
모델 속성을 지정하고 템플릿 네임 속성을 지정하지 않으면 웹로그에 post_list.html
템플릿을 사용하려 할 텐데 인덱스 뷰 이름에 맞춰 웹로그에 index.html 템플릿
경로를 지정하겠습니다
템플릿 파일도 생성해 주시고요 포스트 리스트 쿼디셋을 순회하며 제목을 렌더링하고요 디테일
페이지 링크도 추가합니다
새 포스팅 쓰기 링크도 추가하고요 디테일 페이지에는 수정하기 링크도 추가하겠습니다
PostDeleteView 클래스의 SuccessURL 속성은 웹로그의 인덱스로 수정하여
삭제 후에 포스팅 목록으로 이동하도록 합니다.
ConfirmDeleteForm 클래스를 통해 삭제 동의 여부를 물어보는 체크박스를 추가해 보겠습니다.
CustomForm 클래스는 BooleanField, FormField만 필수
필드로 구성했고요.
BooleanField, FormField는 디폴트로 InputType 체크박스로
렌더링됩니다. 이 필드는 필수 필드이기에 체크하지 않으면 유효성 검사에 실패하게 돼요.
함수 기반 뷰에서는 직접 confirm, delete, form 인스턴스를 만들어서
템플릿에는 form 이름으로 form 인스턴스를 넘겨주고요 유효성 검사에 통과했을 때에만
삭제를 수행하도록 합니다
템플릿에서는 form 값이 있을 때에만 as table 메서드를 호출하여 form을
렌더링하고요 그럼 동의 체크박스에 체크가 되고 제출이 되면 삭제가 수행될 것입니다
DeleteView 클래스 기반 뷰에서는 Form 클래스 속성에 Form 클래스만 지정하면
앞서 함수 기반 뷰의 작업들을 내부에서 처리해 줍니다.
Django Vanilla Views의 DeleteView에서는 Form 클래스 속성을 지원하지
않아요. 삭제 시에 모델 인스턴스의 Delete 메서드를 호추하여 데이터베이스에서 삭제를
수행하는 것은 Hard Delete라고 부릅니다.
혹은 데이터베이스에서 삭제하지 않고 삭제된 플래그만 변경하여 이를 소프트 딜리트라고
부릅니다. 서비스에 따라 소프트 딜리트가 필요할 수도 있습니다.
DeleteView에서 소프트 딜리트가 필요할 때에는 FormValid 메서드를 재정의해서
소프트 딜리트 코드를 수행하고 부모의 FormValid 메서드 호출 없이 redirect
응답을 합니다.
부모의 FormValid 메서드에서는 하드 딜리트 코드가 구현되어 있기 때문에 호출하지
않아야 할 것입니다.
Django 바닐라 뷰스의 DeleteView 클래스에서는 form 클래스 속성을 지원하지
않습니다. 그래서 Django 기본의 deleteView 클래스를 import해서 부모
클래스를 변경해 주겠고요.
deleteView 구현을 보시면 form 클래스 속성이 있고, post 요청을 받으면
관련 모델 인스턴스를 조회하고, 폼 인스턴스를 생성하고, 유효성 검사에 통과하면 폼 밸리드
메서드를 호초하여 응답을 생성합니다.
폼 밸리드 메서드 구현을 보시면, 성공 URL 주소를 먼저 계산하고, 모델 인스턴스를
삭제한 후에 redirect 응답을 하네요.
웹로그의 폼주점 파일에 삭제 의사를 묻는 폼 클래스를 먼저 생성하겠습니다.
불리한 필드, 폼 필드를 추가하고요.
required 인자를 참으로 지정하면 반드시 체크를 해야만 유효성 검사를 통과합니다.
약간 동의에 쓰기 좋겠죠.
PostDeleteView 클래스의 Form 클래스 속성으로
ConfirmDeleteForm 클래스를 적용하시고요.
PostConfirmDelete.html 템플릿에서 폼 렌더링도 해줍니다.
그럼 폼 필드들이 렌더링이 되죠.
동의 체크박스를 체크하지 않고 삭제하겠습니다
버튼을 클릭하면 필수 항목입니다라는 에러 메시지가 뜹니다.
이는 Django 폰필드에서 디폴트로 정의한 에러 메시지인데요.
현 상황에 맞게 에러 메시지를 커스텀할 수 있으면 좋겠네요.
폼 필드의 에러 메시지스 인자로 required 키로 변경할 에러 메시지를 등록하실 수
있습니다. 필수 필드를 요청하는 상황에서 필수 에러 메시지로 보여집니다.
다시 서밋하시면 지정한 에러 메시지로 보여지고요.
체크하시고 서밋하시면 삭제가 됨을 확인하실 수 있습니다.