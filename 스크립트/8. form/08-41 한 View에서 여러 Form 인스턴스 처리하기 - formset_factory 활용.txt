한 페이지에서 같은 폼 클래스의 여러 폼 인스턴스를 한 번에 생성해서 처리하고자 할 때
폼 인스턴스를 하나하나 생성하고 프리픽스 인자를 일일이 지정하지 않아도 폼셋 팩토리 함수를
통해 생성된 폼셋 클래스를 활용하시면 자동으로 프리픽스가 부여된 폼 인스턴스를 생성하고
입력 데이터에 대한 유효성 검사를 수행하실 수 있습니다.
메모 뉴 뷰를 함수 기반 뷰로 다시 구현해 보겠습니다.
이는 Django의 기본적인 폼 처리 코드이죠.
메모 폼, 폼 클래스는 모델 폼이 아닌 그냥 폼이기에 세이브 메서드가 지원되지 않고,
유효성 검사에 통과했을 때 Cleaned Underbar Data 사전을 제공받습니다.
생성된 HTML 코드를 보시면 메시지 필드의 Name 속성에는 메시지 문자열이,
StatusField의 Name 속성에는 Status 문자율이 지정되어 있습니다.
Form 전송 시에 이 이름으로 서버로 전송이 됩니다.
유효성 검사에 통과한 값을 보시면 메시지 키와 Status 키를 가지고 있습니다.
FormView 클래스 기반 뷰로 구현된 메모 뉴 뷰를 동일한 동작을 하는 함수 기반
뷰로 다시 구현합니다.
유효성 검사에 통과하면 성공 메시지를 보여주도록 했고요.
새로운 메모를 제출하면 이렇게 성공 메시지가 보여집니다.
유효성 검사에 통과한 값인 cleaned_underbar_data 사전 값도 이렇게 확인이
됩니다. 메모뉴 뷰에서 두 개의 메모 폼 인스턴스에 대한 처리를 지원하려 합니다.
두 개 폼 인스턴스의 입력 값이 섞이지 않도록 prefix 이름을 다르게 지정하여 각
인스턴스를 각각 템플릿으로 전달하여 하나의 폼 태그 안에서 각 폼 인스턴스를 각각
렌더링하고요. 그럼 이렇게 HTML로 서로 다른 네임을 가진 태그로 렌더링됩니다.
각 태그에는 프리픽스가 적용되어 첫 번째 메시지 인풋 태그에는 네임 속성으로 form-0
메시지가 지정되어 있고요 두 번째 메시지 인풋 태그에는 네임 속성으로 form-1 메시지가
지정되어 있습니다
폼 제출이 되고 Django 뷰에서 post, files 데이터를 처리할 때에도 동일한
프리픽스가 지정되어 프리픽스에 맞는 데이터만 폼 인스턴스에서 매칭하여 처리합니다 유효성
검사도 폼 인스턴스별로 유효성 검사를 수행하고 모든 폼 인스턴스의 유효성 검사가 통과했을
때 cleaned_underbar_data 사전을 출력하고 페이지 이동 응답을 하며 폼 처리를 마칩니다.
메모 뉴 뷰에서 두 개의 메모 폼 인스턴스를 처리해 보겠습니다.
GET 요청 처리 시에 두 개의 메모 폼 인스턴스를 생성하고요.
POST 요청 처리 시에도 두 개의 메모 폼 인스턴스를 생성하고, 각각 유효성 검사를
수행하고, 유효성 검사를 모두 통과했을 때, 각각의 cleaned_underbar_data
사전 값을 출력해 보겠습니다.
템플릿에도 두 메모 폼 인스턴스인 폼1과 폼2를 넘겨줍니다.
포스트 요청 데이터 값 확인을 위해 터미널에서 실행 중인 개발 서버를 끄고 PyCharm 개발
서버를 구동시켰습니다.
포스트 요청 처리 시에 중단점에 걸리도록 중단점을 설정합니다.
템플릿에서는 폼1, 폼2 모두에 대해 동일하게 템플릿 코드를 작성해줍니다.
두 개의 폼 인스턴스는 하나의 폼 태그 안에 배치를 해야만 하나의 폼 전송을 통해 한 번의
입력 값을 서버로 전송할 수 있습니다.
웹페이지를 새로고침하시면 폼 2개가 뜨고요.
폼 2개에 모두 값을 입력하시고 폼 제출을 할 텐데요.
블라우저 개발자 도구로 각 폼의 인풋 요소를 찍어보면 네임, 속성 값이 동일함을 확인하실
수 있습니다.
그러면 폼 전송 시에 두 폼의 데이터가 같은 이름으로 전송이 되는 거죠.
폼 제출하시면 중단점에서 실행이 멈춰있고요.
불필요한 값 워치는 제거하고 리퀘스트 객체의 포스트 속성을 열어보시면 이렇게 메시지 값과
스테이터스 값이 두 개가 아니라 한 개씩만 있음을 확인하실 수 있습니다.
같은 네임으로 전송되었기에 두 번째 값만 보여지고 있는데요.
포스트 데이터를 키 조회가 아니라 getList 메서드로 조회해 보시면 이렇게 두 개의
값을 확인하실 수 있습니다.
장고 폼에서 포스트 데이터를 입력 받을 때에는 getList 메서드로 조회하는 것이 아니라
키 조회만 하거든요.
두 폼 인스턴스에 각각 입력 값을 전달하려면 인풋 요소의 name 속성 값을 다르게 지정해
줘야만 합니다.
이를 위해 폼 생성자에서는 prefix 인자를 지원해 주는 것입니다.
두 개의 폼 인스턴스 생성자에 prefix 인자를 지정하되, 어떤 문자열이든 상관없고요.
서로 다른 prefix만 지정하시면 되고, post 요청 처리 시에도 동일한 prefix를
지정해 주셔야만 합니다.
이제 input 요소의 name 속성을 확인해 보시면 prefix가 적용되어 서로 다른
name 속성 값이 지정되어 있음을 확인하실 수 있고요.
form 제출을 하면 리퀘스트의 post 속성에서 두 폼의 두 필드 값이 모두 확인이
됩니다. 유효성 검사를 통과하는 부분까지 실행을 이어가시면 각 폼 인스턴스의
cleaned-underbar-data 사전 값에도 이렇게 유효성 검사에 통과한 값들이 잘
저장되어 있음을 확인하실 수 있습니다.
앞선 구현을 폼셋 팩토리를 통해서 보다 간결하게 구현하실 수 있습니다.
폼셋 팩토리 함수로 폼셋 클래스를 동적으로 생성해서 요청을 처리합니다.
form 인자로 폼 클래스를 지정하고요.
extra 인자로 추가 폼의 개수를 지정합니다.
default는 1이고요.
3을 지정했으니 3개의 폼 인스턴스를 생성하여 3개의 입력 폼을 보여주려 합니다.
Vue에서 FormSet 클래스를 활용하는 것은 Form 클래스 활용법과 거의 유사합니다.
GET 요청에서는 FormSet 클래스의 인스턴스를 생성하고 템플릿을 통해 HTML 응답을
생성하고요.
POST 요청 시에는 FormSet 인스턴스 생성 시에 데이터 인자로 Request 객체의
Post 속성, Files 인자로 Files 속성을 지정하고 IsValid 메서드를
호출하여 유효성 검사를 수행하고요.
유효성 검사에 통과한 값은 Cleaned Underbar Data List를 통해 조회하실
수 있습니다.
템플릿에서는 폼셋 인스턴스의 매니지먼트 폼 속성을 렌더링하여 관리 정보에 대한 인풋 타입
요소를 렌더링합니다.
관리 정보는 폼셋이 렌더링하는 폼의 전체 개수, 폼셋이 처음 렌더링될 때 이미 존재하는
폼의 개수, 폼셋에 최소한 존재해야 하는 폼의 개수, 폼셋에 추가할 수 있는 최대 폼의
개수입니다. 최대 폼의 개수가 디폴트로 1,000이고요 폼셋 팩토리 함수 출시에
maxnum 인자로 최대 폼의 개수를 지정하실 수 있습니다
우리는 메모 뉴뷰에서 폼을 3개만 생성했지만 프론트엔드 딴 자바스크립트를 통해서 입력 폼의
개수를 최대 1,000개까지 동적으로 늘려줄 수 있습니다 폼 최대 개수 초과 등의 폼셋
에러는 non-form errors 속성을 통해서 참조하실 수 있고요 폼셋을 순회 돌면서
폼 인스턴스를 참조하실 수 있습니다
세 개 폼 중에 첫 번째 폼에만 입력이 있고 나머지 두 개 폼에는 입력이 없는데요 입력이
없는 폼에 대해서는 cleaned-underbar-data-list에는 빈 사전 값으로
값들이 수집되어 있습니다
메모 뉴뷰를 폼셋 팩토리를 활용해서 구현해 보겠습니다.
폼셋 팩토리 함수 인자를 보시면 다양한 인자들이 지원되는데요.
이 중에 폼 인자와 익스트라 인자를 사용해 보겠습니다.
폼 인자로 메모 폼 클래스를 지정하고요.
익스트라 인자로 3을 지정하여 새로운 폼셋 클래스를 생성합니다.
일일이 폼 인스턴스를 생성했던 코드들을 모두 제거하고 폼셋 인스턴스를 생성해 줍니다.
폼 클래스를 처리하는 뷰 패턴과 같은 패턴으로 폼셋 클래스를 처리합니다
폼셋 인스턴스의 cleaned_data 속성은 사전이 아니라 여러 폼
인스턴스의 cleaned_data 사전 값이 들어있는 리스트입니다
템플릿에도 폼셋 인스턴스만 넘겨주고요 폼셋 인스턴스의 미디어 속성을 렌더링하고 폼셋
인스턴스의 관리 정보 렌더링을 위해 매니지먼트 폼 속성을 렌더링합니다
폼셋 인스턴스를 순회 돌면 개별 폼 인스턴스를 탐조하실 수 있습니다.
폼 인스턴스별로 폼 렌더링을 해줍니다.
페이지 새로고침하시면 생성된 3개의 폼을 확인하실 수 있습니다.
Extra 인자로 지정한 개수만큼 빈 폼이 생성이 되고요.
빈 폼에 입력 값을 채워 넣으시고 제출을 하시면 이렇게 메시지를 통해 몇 개의 값을 입력
받았는지도 확인하실 수 있습니다.
포스트 데이터를 확인하기 위해 파이참에서 중단점을 걸고요.
폼 제출을 하시면 이렇게 폼셋의 관리 정보 및 각 폼의 필드 값들이 프리픽스를 가지고 잘
전송이 되었음을 확인하실 수 있습니다.
폼셋 인스턴스의 cleaned-underbar-data 리스트도 확인해 보시면 각 폼
인스턴스의 cleaned-underbar-data 사전들이 잘 저장되어 있네요.
폼셋에서 유효성 검사에 통과한 값들은 폼셋 인스턴스의
cleaned-underbar-data 리스트나 각 폼 인스턴스의
cleaned_data 사전을 통해서 참조하실 수 있습니다.
각 폼의 입력 여부는 폼 인스턴스의 has_changed 메서드를 호출하여 아실 수
있고요. 이렇게 메모 모델 인스턴스를 모아서 한 번에 bulk create를 통해 일괄
생성하실 수도 있겠습니다.
폼셋 팩토리를 통해 생성된 폼셋 클래스는 모델 폼이 아닌 폼 기반으로 동작하기에 save
메서드를 지원하지 않습니다.
그러니 직접 모델로의 저장을 구현해 주셔야 합니다.
폼셋 인스턴스를 순회 돌며 각 폼 인스턴스를 참조하실 수 있고요.
폼 인스턴스의 has_changed 메서드를 호출하여 입력이 있는 폼 인스턴스만 선별하여
메모 모델 폼 인스턴스를 생성해서 리스트에 담고 bulk create를 통해 일괄
생성합니다. 페이지 서도 고침하시고 입력 폼을 채우고 저장하시면 총
3개의 메모가 저장되었고요.
블로그 메모 데이터베이스 테이블도 확인해 보시면 저장된 데이터를 확인하실 수 있습니다.