앞서 살펴본 모델 폼셋 팩토리는 특정 모델의 전체 레코드를 대상으로 수정 폼을 띄우고, 입력 받은 대로 모델 인스턴스를 생성했었는데요.
메모의 경우, 대개의 서비스에서 여러 유저들의 메모를 모두에게 노출해서 생성, 수정, 삭제 기능을 제공하지 않습니다.
유저마다 각자의 메모만을 보고 생성하고 수정하고 삭제 기능을 제공하겠죠.
그러려면 메모 모델에 유저 모델에 대한 외래키 필드를 추가해야 할 테고요.
조회 시에도 특정 유저의 메모를 조회하는 쿼리셋도 직접 작성해 줘야 하고 저장 시에도 그 유저를 외래키로 지정하는 코드도 직접 작성해 줘야 합니다.
일라인 폼셋 팩토리는 몇 가지 설정만으로 모델 폼셋 팩토리와 거의 동일한 사용법으로 외래키 관계를 1라인 폼셋 팩토리는 모델 폼셋 팩토리를 랩핑하여 부모 자식 관계에서 자식에 대한 생성, 수정, 삭제의 편의성을 강화했습니다.
조회 시에는 부모 조건 필터링을 자동 수행해 주고요.
생성 시에는 모델 인스턴스에 부모 메레킷 필드를 자동으로 지정하여 저장해 줍니다.
메모 모델에 프로젝트의 유저 모델에 대한 외래키 author 필드를 추가해줬고요 
메모 폼 모델 폼에서는 author 필드는 유저로부터 입력받지 않고 뷰 내부적으로 처리할 것이기에 모델 폼 필드로는 추가하지 않았습니다
메모 모델에 유저 모델에 대한 외래키인 author 필드를 추가하고요 마이그레이션 과정을 수행해줍니다 
일회성 디폴트 값으로 1을 입력했고요
그럼 마이그레이트 수행 시에는 유저의 PK가 1인 레코드가 반드시 존재해야만 마이그레이션이 성공합니다 
부모 자식 관계가 있을 때 일라인 폼셋 팩토리를 사용하면 몇 가지 설정만 해주면 외래키 관계를 거의 신경 쓸 부분이 없습니다.
인라인 폼셋 팩토리 함수 호출 시에 모델 인자로 자식 모델 클래스를 지정하고 폼 인자로 관련 모델 폼 클래스를 지정하고요.
페어런트 모델 인자로 부모 모델 클래스를 지정하고 fkname 인자로 자식 모델 클래스에서 부모 모델 클래스에 대한 외래키 필드명을 지정합니다.
그리고 모델 폼셋 인스턴스를 생성할 때 인스턴스 인자로 부모 모델 인스턴스를 지정하면 그 부모 모델 인스턴스에 속한 자식 모델 인스턴스로 제한되어 수정 폼이 제공되고요 생성 저장
시에는 부모 모델 인스턴스가 외래키 필드로 자동 지정되어 저장됩니다
그리고 인라인 폼셋 팩토리 함수는 모델 폼셋 팩토리와는 다르게 Extra 인자의 디폴트 값이 3이고요 
CanDelete 삭제 지원 옵션이 디폴트로 켜져 있습니다 유효성 검사에 통과했을 때 formset.SaveMethod 호출만으로 생성, 수정 및 삭제에 대한 부분까지 모두 한 번에 처리됩니다.
아주 강력하고 편리하죠?
새로운 메모를 저장하려고 하니 Integrity Error 예외가 발생합니다.
메모 모델의 author 필드는 필수 필드라서 null을 허용하지 않는데 값 지정 없이 저장을 시도하니 데이터베이스에 null 저장을 시도했다는 거죠.
모델 폼셋 팩토리를 inline-formset-factory로 변경하고요.
parent-model 인자에는 부모 모델 클래스인 user-model 클래스를 지정하고 fk-name 인자에는 author를 지정합니다.
메모 모델에는 외래키가 한 개이기 때문에 FKNAME 인자를 생략하실 수도 있습니다.
일라인 폼셋 팩토리를 통해 부모인 유저 레코드 하나에 속한 다수의 메모 레코드를 손쉽게 관리하실 수 있게 됩니다.
폼셋.Save 호출만으로 새로운 메모 저장 시에 외래키 필드를 자동으로 지정해 줍니다.
부모 모델 인스턴스를 아직 지정하지 않았네요.
현재 로그인 유저 인스턴스를 지정하기 위해 메모 new 를 로그인 required 장식자로 감싸서 로그인 상태에서만 메모 new 를 보장받고요.
request.user 속성으로 현재 로그인 유저 인스턴스를 참조하실 수 있습니다.
각 모델 폼셋 생성자의 인스턴스 인자로 지정하시면 이제 현재 로그인 유저의 메모만 수정 폼으로 보여지게 되고요.
생성되는 메모에도 자동으로 author 필드의 현재 로그인 유저 인스턴스가 지정이 됩니다.
블로그 메모 데이터베이스 테이블을 열어보면 이렇게 author 외래키 필드 값도 잘 지정이 되어 저장되어 있음을 확인하실 수 있습니다.
새 메모들 하나로 생성해 봤고요.
현재 로그인 유저의 PK 확인을 위해 템플릿에 로그인 유저의 PK를 노출하도록 해봅니다.
다른 유저로도 잘 동작을 하는지 확인하기 위해 다른 슈퍼 유저로 로그인을 해볼게요.
새로운 슈퍼 유저 계정은 Create Super User 장고 관리 명령으로 생성하실 수 있습니다. 
다른 유저로 메모가 잘 조회되고 있고요.
새로운 메모를 남기면 이렇게 그 유저의 PK가 Author ID 외래키에 잘 저장이 되었음을 확인하실 수 있습니다.
일라인 폼셋 팩토리로 구현한 것을 모델 폼셋 팩토리로 구현해 본다면 부모 모델 인스턴스에 속한 자식 모델 인스턴스를 조회하는 쿼리셋을 직접 작성하고요.
유효성 검사에 통과했을 때 폼셋.save method 호출 시에 commit 인자를
지정하여 모델 저장을 지연시키고 각 자식 모델 인스턴스마다 순위를 돌며 부모 메레킷 필드를 지정하고 개별적으로 save 메서드를 호출하여 저장해줍니다
그리고 삭제에 대해서도 수동으로 처리를 해줘야겠죠
인라인 폼셋 팩토리는 모델 폼셋 팩토리를 랩핑한 함수거든요
인라인 폼셋 팩토리 함수 동작을 모델 폼셋 팩토리로도 손쉽게 동일하게 동작하도록 구현하실 수 있습니다 
인라인 폼셋 팩토리에서 자동으로 제공해 줬던 기능을 직접 구현해 보며 이해도를 높여 봅시다. 
모델 폼셋 팩토리로 변경하고, 페어런트 모델 인자와 fkname 인자도 제거합니다.
extra 인자는 다시 3으로 지정하고, can_delete 참 인자로 지정하고, 각 모델 폼셋 생성자에서 부모 모델 인스턴스를 지정하는 인스턴스 인자를 제거하고, 
웹페이지 새로고침하시면 현재 사용자의 메모만 노출되는 것이 아니라 모든 메모가 노출되고 있습니다.
현재 사용자의 메모만 노출하려면 쿼디셋 인자를 지정하여 현재 로그인 유저의 메모만 필터링합니다. 
그럼 현재 유저의 메모만 보여지죠? 
새 메모를 저장해보면 author 메타필드 필드를 지정하지 않아서 Integrity Error 예배가 발생하네요.
formset.SaveMethod 호출 시에 모델 인스턴스 저장을 지연시키고 직접 author 필드를 지정한 후에 모델 인스턴스를 저장하도록 구현합니다.
잘 동작하네요.