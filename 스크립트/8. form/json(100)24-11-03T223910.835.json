안녕하세요. 이번 시간에는 수정과 삭제를 지원하는 4가지 클래스 기반 뷰에 대해서
살펴보겠습니다.
수정 요청과 삭제 요청을 지원하는 클래스 기반 뷰는 총 4가지입니다.
FormView 클래스는 모델 폼 클래스가 아닌 폼 클래스에 대한 일반적인 패턴을
체계적으로 구현할 수 있도록 지원합니다.
사용할 폼 클래스, 사용할 템플릿 경로, 유효성 검사에 통과되었을 때 수행될 로직, 처리
후에 이동할 주소 정도를 설정에 가까운 코드로 뷰를 구현할 수 있고요.
CreateView 클래스는 모델 폼 클래스를 활용한 생성 요청에 대한 패턴을 설정에
가까운 코드로 구현할 수 있도록 지원합니다.
업데이트 뷰 클래스는 모델 폼 클래스를 활용한 수정 요청을, 딜리트 뷰 클래스는 모델 폼
클래스를 활용한 삭제 요청을 지원합니다.
모델을 활용한 데이터 저장의 함수 뷰 예시를 폼 뷰 클래스를 활용한 뷰 코드로 변환해
보겠습니다. 타이틀 필드와 컨텐츠 필드로 구성된 포스트 모델 클래스를 정의했고요.
포스트 모델 구성대로 폼 클래스를 상속받은 포스트 폼 폼 클래스를 정의했습니다.
form 요청 처리 시에는 두 개의 요청을 받아서 처리할 수 있어야 하죠 get 요청과
post 요청에 맞춰 post form 클래스의 인스턴스를 생성합니다
formView 클래스 기반 뷰에서는 사용할 form 클래스 설정을 form__class
속성으로 설정하고요 매 요청을 처리할 때마다 form 클래스를 동적으로 결정해야 한다면
get__form__class 메서드를 재정의해서 사용할 form 클래스를 반환하도록
합니다 get-form-class 메서드 기본 구현에서 form-class 속성을 반환하는
형태로 구현되어 있습니다.
초기 빔폼을 보여줄 때와 포스트 요청에서 유효성 검사에 실패했을 때 템플릿을 통한 HTML
응답을 하죠. 이때 사용할 템플릿 파일의 경로는 form-view-class 기반
view에서는 template-name 속성으로 설정하고요.
매 요청마다 다른 템플릿 파일을 참조해야 한다면 get-template-names 메서드를
통해 문자열 리스트를 반환합니다.
getTemplateNames 메서드의 기본 구현에서는 템플릿 네임 문자의 속성을 리스트로
반환하는 형태로 구현되어 있습니다.
유효성 검사에 통과했을 때 수행되는 로직은 FormView 클래스 기반 뷰에서는
form__valid 메서드를 통해서 구현합니다.
인자로 form 인스턴스를 하나 넘겨봤습니다.
유효성 검사에 통과했을 때 자동 호출되고요.
유효성 검사에 실패했을 때에는 form__invalid 메서드가 자동 호출됩니다.
FormView의 FormValid 메서드 기본 구현에서는 FormInstance에 대한
별다른 처리는 없고, 성공 주소로 이동하는 HTTP 리스폰스 객체만 반환합니다.
PostCreateView 클래스의 FormValid 메서드에서는 유효성 검사에 통과한
FormInstance의 cleanedUnderbarData 사진값을 참조해서
PostRecord을 생성하고, 부모의 FormValid 메서드를 호출하면
SuccessURL에 지정한 주소로 이동 응답을 할 것입니다.
혹은 부모를 호출하지 않고 redirect shortcode 함수를 사용해서 이동 응답을
바로 하실 수도 있습니다.
FormView 클래스의 FormInvalid 메서드 기본 구현에서는 템플릿을 통한 에러
내역이 포함된 HTML 응답을 합니다.
디폴트 구현으로 충분하니까 대개 메서드 제정이 없이 디폴트 구현을 그대로 활용하시게
됩니다. 모든 성공 처리가 끝난 후에 이동할 페이지 주소는 FormView 클래스 기반
뷰에서는 SuccessURL 속성이나 동적인 지정은 GetSuccessURL 메서드를
재정의해서 지정합니다.
GetSuccessURL 메서드 기본 구현에서는 SuccessURL 속성을 반환하는 형태로
구현되어 있습니다.
웹로그 앱의 PostNew 함수 뷰와 동일하게 동작하는 FormView 클래스 기반의
클래스 기반 뷰를 구현해 보겠습니다.
FormView 클래스는 Django Vanilla View 라이브러리 구현을 사용해
보겠습니다.
FormView 클래스에서는 Form 클래스 속성과 템플릿 램 속성이 꼭 필요합니다.
유효성 검사에 통과한 후에 FormValid 메서드 처리 후에 이동할 주소도 Success
URL 속성으로 지정합니다.
PostNew 함수에서 모델 인스턴스 저장 코드를 잘라내기 해 주시고요.
현재의 PostNew 함수 뷰 구현에서 모델 인스턴스 저장을 제외한 코드 동작과 현재의
PostCreateView, 클래스 기반 뷰 동작은 동일합니다.
FormView 클래스의 FormValid 메서드 기본 구현에서는 Success URL의
주소로의 이동 응답만 할 뿐 Form 인스턴스에 대한 처리는 하지 않습니다.
그러니 폼밸리드 메서드를 재정의해서 방금 잘라내기한 모델 인스턴스 저장 코드를 붙여넣기
하고요. 부모의 폰벨리드 메서드를 호출해서 이동응답도 생성해서 반환합니다.
이제 postNew 함수 코드는 제거하고, PostCreateView 를 통해서
postNew 를 생성하겠습니다.
웹로그의 new 주소에서 새로운 포스팅을 생성하고, 어드민에서 확인해 보시면 입력한 대로
파일과 many-to-many 필드 내역까지 모두 잘 저장되어 있음을 확인하실 수
있습니다. 장고 클래스 기반 뷰는 다양한 사용 사례에 맞춰 재사용성이 높도록 설계되었기
때문에 상속 구조가 복잡하여 전체 흐름을 한눈에 파악하기 어려울 수 있습니다.
폰뷰의 전체 구조를 이해하려면 6개 이상의 클래스 코드를 살펴봐야 하는 상황이 발생하고요.
처음 클래스 기반 뷰를 학습하실 때에는 이 상속 관계 파악이 어렵죠.
각 메서드의 반환값 타입을 제가 추가해봤지만 여전히 눈에 잘 들어오진 않습니다.
그래서 Django Vanilla Views 라이벌리를 추천드립니다.
장고 개발자인 아담 존슨이 개발한 수많은 장고 라이벌리 중 하나입니다.
클래스 기반뷰 상속 관계를 아주 간결하게 재구현하였고요.
단 두 개 클래스의 짧은 코드만으로 폰뷰 클래스 구현이 끝났습니다.
장고의 클래스 기반 뷰, 클래스 상속한 기존 뷰 코드를 장고 바닐라 뷰스
상속 코드로 변경하셔도 거의 99% 잘 동작하실 겁니다.
장고 클래스 기반 뷰 코드를 살펴보시기 전에 장고 바닐라 뷰스의 뷰 클래스를 먼저
상속받으시고, 클래스 기반 뷰 상속 관계를 먼저 이해해 보시길 추천드립니다.
폼뷰 구형 코드를 보면 한결 보기 수월하고요.
코드도 직관적입니다.
GET 요청을 받으면 getFormMethod을 호출하여 form 인스턴스를 생성하고
getContextDataMethod을 호출하여 context 사전을 생성하고
renderToResponse 메서드을 호출하여 HTML 응답 객체를 생성합니다.
POST 요청을 받으면 getFormMethod을 호출하여 form 인스턴스 생성 시에
request.POST 속성의 데이터와 request의 files 속성의 파일 데이터를
인자로 넘기고요.
폼 유효성 검사를 수행한 뒤에 유효성 검사에 통과하면 폼 밸리드 메서드를 호출하여 유효성
검사에 통과했을 때 로직을 수행하는데요.
기본 구현에서는 성공 주소로 이동하는 응답 객체만 생성해서 반환합니다.
폼 유효성 검사에 실패하면 폼 인벨리드 메서드가 호출되고요.
폼 인벨리드 기본 구현에서는 템플릿을 통해 에러 폼 응답을 하도록 되어 있습니다.
장고 폼과 폼뷰를 활용한 수정 요청 처리에 대해서 살펴보겠습니다.
폼 인스턴스 생성 시에는 Initial 인자로 각 폼필드의 초기 값을 받고요.
폼뷰, 클래스 기반 뷰에서는 Initial 속성으로 정적인 폼필드 초기 값을 지정받고,
getInitial 메서드를 통해 동적인 폼필드 초기 값을 지정받습니다.
Django 기본의 FormView 클래스에는 getInitial 메서드를 사용하지만
Django Vanilla Views 클래스 클래스에서는 getInitial 메서드가 없습니다.
이때에는 getForm 메서드를 재정의해서 폼 생성자에 넘길 인자를 커스텀해서
initial 인자를 추가하는 방식으로 구현할 수 있습니다.
포스팅 수정에서는 매 포스팅마다 초기 값이 달라져야 하니 getInitial 메서드를
재정의합니다. 함수 기반 뷰에서는 함수 인자로 urlCapturedValues를
전달받지만, 클래스 기반 뷰에서는 keywordArguments 인스턴스 변수에
urlCapturedValues가 사전 타입으로 저장되어 있습니다.
pk 값으로 관련 모델 인스턴스를 생성하고, Model2Dig 메서드를 통해 사전으로
변환한 후에 반환합니다.
모델 인스턴스는 다른 메서드에서 활용할 수 있도록 인스턴스, 멤버, 변수로 저장해 두고요.
유효성 검사에 통과했을 때 폰벨리드 메서드를 호출해서 최종 응답 객체를 생성하죠.
폰벨리드 메서드를 재정의하고 다시 데이터베이스를 조회하기보다 앞서 생성한 모델 인스턴스를
활용해서 추가 데이터베이스 조회 없이 수정 데이터를 데이터베이스에 저장합니다.
폼뷰의 폼밸리드 구현에서는 성공 URL로 이동하는 응답을 생성하거든요
그러니 부모의 폰밸리드 메서드를 호출하여 성공 URL로 이동하는 응답 객체를 생성하고
반환합니다 폼밸리드 메서드에서 리라이렉트 메서드를 통해 직접 응답 객체를 생성하고 반환하실
수도 있습니다 웹 로그 앱의 포스트 에디트 함수 뷰와 동일하게 동작하는 장고 바닐라 뷰스의
폰뷰 클래스 기반의 클래스 기반 뷰를 구현해 보겠습니다
앞선 PostCreateView 클래스와 비교해서 상속받은 부모 클래스와 다른 속성들은
모두 동일하게 지정하고요.
모델 폼 인스턴스 생성 시에 생성 인자만 달리 지정할 것입니다.
폼 밸리드 메서드 재정의 시에 폼.SaveMethod 도출을 추가하고요.
이제 폼 에디트 함수 코드는 제거하고, PostUpdateView를, 클래스 기반 뷰를
통해서 PostEditView를 생성하겠습니다.
저는 10번 포스팅이 있고, 웹로그 10의 에디트 주소에서 포스팅 수정 화면을 띄워봅니다.
아직 폰필드 초기값들이 지정되어 있지 않습니다.
현재 Django 바닐라 뷰스의 FormView를 상속받았는데요.
Django 기본의 FormView를 상속받는 예시를 먼저 작성해 보겠습니다.
PostForm 클래스는 모델 폼 기반이기에 이니셜 인자를 받지 않고 인스턴스 인자를
받습니다. 그러니 getInitial 메서드를 구현해서는 안 되고요.
대신 Django 기본의 FormView에서는 getForm 키워드 아귀먼트 메서드를 통해
form 인스턴스 생성 시에 전달되는 생성자 인자를 지정합니다.
그래서 getFormKeywordArguments 메서드를 재정의해서 인스턴스 인자를
추가해 주겠습니다.
KeywordArguments 멤버 변수에서 현재 요청의 PK 값을 조회하고, 해당 기본
키의 모델 인스턴스를 조회한 뒤에 인스턴스 이름으로 인자를 추가해 줍니다.
모델 폼 내부에서 인스턴스 인자를 관리하고 있기 때문에 모델 인스턴스를 따로 멤버 변수로
관리하지 않아도 됩니다.
페이지를 새로 고침하니 폼 필드 초기 값들이 채워졌고 수정 기능도 잘 동작하네요.
이번에는 Django Vanilla Views의 폼뷰 버전으로 작성해 보겠습니다.
getForm 키워드 하기 원치 메서드는 없는 메서드라고 합니다.
폼뷰 코드를 보시면 getFormMethod를 호출하여 form 인스턴스를 생성하고
getForm 구현해서 키워드 인자를 그대로 form 인스턴스 생성 시에
전달하고 있네요.
그럼 getFormMethod를 재정의해서 instance 키워드 인자로 전달해주면
되겠습니다. 소스 코드 저장하시고요.
확인해 보시면 수정 기능이 잘 동작합니다.