안녕하세요. 이번 시간에는 django-formtools 라이벌을 통해 여러 폼
인스턴스를 하나의 뷰에서 마법사 UI로 지원하는 방법에 대해서 살펴보겠습니다.
UI 모델에 대한 모델 폼인 UserForm과 프로필 모델에 대한 모델 폼인 을 이렇게 정의했습니다.
하나의 뷰에서 과 에 대해서 입력을 받고 저장하려 합니다.
Accounts 앱에 유저 모델이 있고요.
이 유저 모델에 대한 모델 폼을 정의합니다.
Field는 기본 유저 모델에 정의된 First Name Field와 Last Name
Field로 지정합니다.
아래에 프로필 모델에 대한 모델 폼이 있고요.
간단한 구성으로 모델 폼을 하나 더 생성해 주겠습니다.
프로필 폼, 단 하나의 폼을 처리하는 프로필 에디트 뷰는 이렇게 구현을 하죠.
로그인 required 장식자를 통해 로그인 상태임을 보장받고요.
현재 로그인 유저의 프로필이 있다면 수정으로 동작하고, 없다면 생성으로 동작합니다.
유효성 검사에 통과한다면, 유저 외래키 필드에 로그인 유저의 모델 인스턴스를 대입하고
저장합니다.
템플릿에서는 Form 인스턴스의 EdgeTable 메서드 호출을 통해 Table 포맷으로
렌더링했습니다.
이번에는 프로필 에디트 뷰에 UserForm, Form에 대한 지원을
추가했습니다. 이 경우에는 UserForm과 ProfileForm에 대한 입력을 동시에
받아서 동시에 유효성 검사를 수행하고 동시에 저장을 하는 거죠.
각 폼별로 단계적으로 수행할 수는 없을까요?
Django Form Tools 라이브러리를 통해 하나의 뷰에서 여러 폼을 마법사 UI로
구현할 수 있습니다.
라이브러리 설치는 pip install django-formtools 명령으로 설치하실 수
있고요. 2.5.1 버전을 저는 설치했습니다.
세팅스에 Installed Apps List에 FormTools 앱 이름을 추가해 주시면
설치 끝입니다.
Django FormTools 라이브러리는 Django 1.7까지는 Django 기본
앱이었고요.
Django 코어를 간결하게 유지하기 위해 Django 1.8부터 독립 라이브러리로
분리되었습니다.
장고 폼 주 라이브러리는 폼 프리뷰 기능과 폼 유저드 기능을 제공하고요 폼 유저드
기능에서도 다양한 옵션들이 지원되는데 필수 옵션 위주로 살펴보겠습니다
먼저 각 단계의 입력 데이터를 저장할 스토리지로서 Session과 Cookie 중에
선택하실 수 있고요 Session을 사용하시려면 Session, WizardView,
Class 기반 뷰를 상속 받으시면 되고 Cookie를 사용하시려면 Cookie,
WizardView, Class 기반 뷰를 사용하시면 됩니다
쿠키는 서명이 되기에 유저가 임의로 변경할 수는 없습니다
두 번째로 FormList 속성으로 단계별로 사용할 Form 클래스를 List로 지정합니다
그러면 알아서 각 단계에 맞춰 Form 인스턴스를 생성하고 유효성 검사를 수행하고요 유효성
검사에 실패하면 에러 화면을 보여주고 유효성 검사에 성공하면 다음 단계의 Form 화면을
보여줍니다 마지막 Form까지 모두 진행하고 나면 돈 메서드를 통해 저장을 구현하고 다른
페이지로 이동을 시킵니다.
세 번째로 템플릿 네임 속성으로 사용할 템플릿 경로를 지정하고요.
만약 각 단계마다 템플릿 경로를 다르게 지정하고자 하신다면 getTemplateNamed
메서드를 재정의하시면 되고요.
현재 단계는 self의 Steps의 Current 속성으로 참조하실 수 있습니다.
네 번째로 임시 파일 스토리지를 지정합니다.
마법사 진행 중에 각 단계에서 입력받은 데이터는 Session이나 Cookie에
저장하는데요.
파일은 Session이나 Cookie에 저장할 수 없습니다.
DOM 메서드를 통해 최종 저장하기 전에 임시로 파일을 저장해둘 파일 스토리지를 지정해
주어야만 합니다.
파일 스토리지에 임시 파일을 저장하고 Session이나 Cookie에는 임시 파일의 경로
문자열을 저장합니다.
현 장고 프로젝트의 디폴트 스토이지를 지정하겠습니다.
각 폼 인스턴스 생성 시에 필요한 이니셜 인자는 getFormInitial 메서드를 통해
제공해 줄 수 있고요.
인자로 현 단계를 문자열로 받습니다.
첫 번째 단계는 문자열로 0이고요.
두 번째 단계는 문자열로 1입니다.
각 모델 폼 인스턴스 생성 시에 필요한 인스턴스 인자는 getFormInitial 메서드를
통해 제공해 줄 수 있고요.
모델 폼을 사용하는 단계에서만 호출됩니다.
모든 단계가 완료되었을 때, 모든 단계에 대한 유효성 검사를 다시 한 번 더 수행하고요.
유효성 검사에 통과하면 돈 메서드가 호출됩니다.
인자로는 formList 인자로 각 form 인스턴스를 list 타입으로 넘겨주기도
하고요. formDict 인자로 각 form 인스턴스를 사전 타입으로 넘겨주기도 합니다.
상황에 맞춰 참조하기 편하신 인자를 사용하시면 됩니다.
순회 돌면서 일괄적으로 저장할 때에는 폼 리스트 인자를 사용하면 좋겠네요.
저장 완료 메시지를 남기고 다시 프로필 마법사 페이지로 이동을 시키겠습니다.
템플릿에서는 위자드 객체를 통해서 렌더링하는데요 위자드의
form 속성을 통해 현재 form 인스턴스를 참조하실 수 있고요 위자드의
management form 속성으로 마법사 관리 정보를 input type hidden
요소로 렌더링하고요 위자드의 steps 속성은 steps helper 클래스의
인스턴스이며, 단계와 관련된 다양한 속성들을 지원해줍니다.
count 속성으로 전체 단계수를, step1 속성으로 1부터 시작하는 현재 단계수를,
step0 속성으로 0부터 시작하는 현재 단계수를, 그리고 first 속성으로 첫
단계명을, .previous 속성으로 이전 단계명을, .next 속성으로 다음 단계명을
참조할 수 있고, last 속성으로 마지막 단계명을 참조할 수 있습니다.
이전에 프로필 에디트 뷰를 구현했었고요.
이와 별도로 프로필 위자드 뷰를 구현하겠습니다.
Django django-formtools 라이브러리를 최신 버전인 2.5.1 버전으로 설치했고요.
settings의 인스톨드 앱 리스트에 폼툴즈 에비룸도 추가합니다.
세션 위자드 뷰를 상속받은 UserProfileWizardView 클래스를 정의하고요.
뷰 호출 시에 로그인 상태임을 보장받기 위해 로그인 리퀘어드 믹싱 클래스도 상속받습니다
폼 리스트 속성으로 두 개의 폼, 유저 폼 클래스와 폴필 폼 클래스를 지정하여 두 단계로
나누어 폼 입력을 받겠습니다
뷰 함수를 생성하고 URL 패턴도 등록해줍니다
웹브라우저에서 Accounts의 프로필 위자드 페이지에 접속하면 이렇게 1단계인
UserForm, Form 클래스를 통한 입력 폼이 뜹니다
뷰에 템플릿 네임 설정을 하지 않았지만 위자드 뷰, 디폴트로 폼툴즈의 위자드에
wizard-form.html 템플릿이 지정되어 있어 디폴트 템플릿으로 렌더링이 된
상황입니다 모델 폼 인스턴스 생성 시에 인스턴스 인자가 지정되지 않았기에 폼.save을
통한 저장 시에 생성으로 동작할 것입니다
1단계에서 유저 폼 필드 값을 입력하고 2단계에서 유저 프로필 폼 필드 값을 입력하고
저장하면 Not Implemented Error 예외가 발생합니다.
위자드 뷰에서 don't 메서드를 아직 구현하지 않았기 때문이고요.
done 메서드를 재정의하시고, done 메서드 인자로 formList와
formDict이 전달되고요.
뷰 호출 시에 urlCapturedValue 값이 keywordArguments 사전으로
전달됩니다. 돈 메서드 호출 시점에는 폼 리스트, 폼 딕 내의 폼 인스턴스들은 이미 유연성
검사가 끝난 상황입니다.
각 폼 인스턴스들을 순회 돌며 세이브 메서드 호출을 통해 저장하고 페이지 이동을 합니다.
수정으로 동작하기 위해 각 모델폼 인스턴스의 인스턴스 인자를 지원해 주겠습니다.
getFormInstance 메서드를 재정의해서 각 단계에 맞는 모델 인스턴스를 반환하면
관련 모델폼 인스턴스 생성 시에 인스턴스 인자로 전달됩니다.
각 단계의 모델 폼 클래스에 맞게 모델 인스턴스를 생성해야겠죠.
현재 단계가 1단계라면, 즉, 스탭 문자열이 0이라면, 현재 유저의 모델 인스턴스를 생성,
반환하고요. 현재 단계가 2단계라면, 현재 유저의 모델 인스턴스를 반환하고요.
현재 단계가 2단계라면, 즉, 스탭 문자열이 1이라면, 프로필 모델 인스턴스를 반환합니다.
현재 유저와 연결된 프로필이 있다면 반환하고요
그럼 프로필 수정으로 동작할 것이고 현재 유저와 연결된 프로필이 없다면 논을 반환하면
프로필 생성으로 동작할 것입니다
커스텀 템플릿 사용을 위해 템플릿 네임 속성을 지정합니다 장고 메시지 출력을 위해 저장된
메시지스 값을 렌더링하고요 위자드의 폼 객체는 현 단계의 폼 인스턴스입니다
미디어 속성 렌더링으로 의존성 있는 css, javascript 파일의 태그를 렌더링하고요
폼 태그의 enctype 속성으로 멀티파트 폼 데이터를 지정하여 파일 업로드를 지원하고
as table 메서드로 table 포맷으로 폼을 렌더링합니다
위자드의 Management 폼으로 마법사 관리 정보를 input type 히든 요소로
렌더링합니다 관리
정보로는 현재 단계명을 담고 있습니다
위자드의 steps 속성에는 Count는 총 단계수, Step 1은 1부터 시작하는 현재
단계수를 보여주고요.
2단계 이상 상황일 때에는 처음 단계 혹은 이전 단계로 이동하는 버튼도 추가해 줍니다.
HTML 폼 태그 내에서는 인풋 타입 서브 및 요소와 함께 버튼 요소도 폼 제출로서
동작합니다. 인풋 타입 서브 및 요소는 버튼 레이블과 서버로 전달되는 값을 동일하게 지정할
수밖에 없지만, 버튼을 활용하면 레이블과 서버로 전달되는 값을 다르게 지정할 수 있습니다.
페이지 서로고침하면 템플릿 내역에 맞게 화면이 보여지고요.
현재 프로필 폼에 대한 인스턴스 생성 시에 생성으로 동작할 수도 있는 부분이 있었죠.
생성으로 동작할 경우 프로필 폼 인스턴스의 save method 호출 시에 모델 인스턴스
저장을 지연시키고 유저 메리키 필드가 발생을 해 줘야 하는데요.
코드를 간결하게 구현하기 위해 getFormInstance 메서드에서 현재 유저 인스턴스와
연결된 프로필 모델 인스턴스가 없다면 프로필을 생성해서 반환도록 해주겠습니다.
그럼 UserProfileWizardView 관점에서는 프로필 폼은 항상 수정으로 동작하는
것이고요. 프로필 폼 인스턴스의 save 메서드 도출 시에 별도로 수행할 작업이 없습니다.
프로필 모델에 PhotoImageField가 있으니 User Profile Form,
Model Form에서 Photo Field를 추가해 줍니다.
소스 코드를 저장하면 장고 개발 서버가 오류를 일으키며 죽어 있습니다.
에러 메시지를 읽어보면 파일 업로드를 처리하려면 리자드 뷰에 File Storage 설정을
추가하라고 합니다.
File Storage는 Default Storage로 추가해 줍니다.
이제 개발 서버가 정상적으로 구동되고요.
프로필 폼 입력 화면에서도 파일 업로드가 정상적으로 처리됩니다.
혹시 파일 업로드가 안된다면 샘플릿 파일에서 폼 태그의 ENC 타입 속성을 멀티파트 폼
데이터로 지정하시는 것을 누락하셨는지 확인해 보시고, 지정하셨다면 오타는 없는지 2번,
3번 확인해 보세요.
DOM 메서드에서 성공 메시지로 추가해 줍니다.
만약 UserForm과 UserForm 순서를 변경하시려면 FormList 속성에서
순서를 변경하시면 되고요
WizardView 메서드 내에서 Step 현단계를 참조하는 코드도 FormList에 맞게
코드를 변경해 주세요
바뀐 순서대로 잘 동작합니다