안녕하세요. 이번 시간에는 CSRF 사이트 간 요청 위조 공격, 방어에 대해서 살펴보겠습니다.
사이트 간 요청 위조 공격이란, 공격자가 사용자의 Session 인증된 상태를 이용하여 서버에 악의적인 요청을 보내는 공격을 말합니다.
공격 예시로써, 이미지 요청을 활용한 CSRF 공격입니다.
GET 요청은 Image 태그나 Script 태그들을 통해 손쉽게 이루어질 수 있기 때문에 
겟 요청을 처리하는 뷰에서는 수정, 삭제 등의 파괴적인 요청을 해서는 안 됩니다.

보안 위험이 있는 희생자 서비스가 있습니다.
유저는 이 서비스에서 로그인을 한 상황이고요.
유저가 악의적인 공격 서비스에 접속했습니다.
유저는 이 페이지에 접속만 한 것이지만, 유저 모르게 이미지 택을 통해 희생자 서비스에서 여행 계획을 변경하는 요청이 겟 요청으로 보내어집니다.
희생자 서비스에서 유저의 인증된 상황을 악용한 공격입니다
희생자 서비스에서 여행 계획 변경 시에 인증 여부만 체크할 뿐 겟 요청을 통해서 여행 계획을 바꿀 수 있게 되어 있기 때문에 
이 공격에 의해 그 유저의 여행지가 유저 모르게 바뀔 수도 있습니다
이러한 공격을 CSRF 사이트 간 요청 위조 공격이라고 부릅니다

물론 CSRF 공격 방어를 위한 두 가지 방법이 있는데요.
그 첫 번째는 희생자 서비스 로그인 시에 Session Cookie의 Same Site 설정을 Rex나 Strict로 두면 
앞선 공격의 이미지 태그를 통한 요청에서는 브라우저가 Session Cookie를 전송하지 않기 때문에 희생자 서비스에 로그인된 상태라 할지라도
이미지 태그를 통해 요청해서 미인증 요청이 됩니다.
장고 기본에서는 Session Cookie의 Same Site 설정이 디폴트로 Lax로 되어 있습니다.
이미 방어가 되어 있습니다.
게다가 Session Cookie는 HTTP Only 설정이 되어 있어서 자바스크립트를 통해서 Session Cookie 조회도 불가능합니다.
Current Travel Edit 뷰 코드를 트래블 앱을 생성해서 구현하는 것이
이름상으로는 적합해 보이지만, 편의성을 위해 샵 앱의 뷰스.py 파일에 복사하겠습니다.
샵 앱의 urlspy 파일에도 Current Travel Edit 뷰에 대한 url 패턴을
등록하고요. 현재 샵 앱의 urls.py 파일에는 프로젝트의 urls.py 파일에서
include가 안 되어 있어요
include도 추가해 줍니다
샵의 urls에 대해 prefix 주소로 샵 슬러시 주소를 추가했어요 장고 개발 서버를
구동하고요 장고 개발 서버는 기본적으로 8000 주소로 구동이 되죠
localhost 8000에 샵 트래블 커런트 업데이트 주소로 접속해 보면 이렇게 응답을 받습니다
로그인이 안 된 상황에서는 unauthorized 응답을 받습니다
얻은 페이지를 통해 로그인 하신 후에 페이지를 새로 고침해 주세요.
이제 공격 페이지를 만들어 보겠습니다.
HTML 폴더 밑에 CSRF Attack 폴더 밑에 CSRF Attack Using Image.html 파일을 복사해서 생성하겠습니다.
이제 파일을 다른 주소로 서빙을 해야 하는데요.
파이썬의 정적 파일 서빙 기능을 활용해 보겠습니다
새로운 터미널을 띄우시고 HTML 폴더까지 이동해 주세요
폴더가 있는 경로에서 파이썬-m http.server 9000 -t csrfattack
명령으로 새로운 웹서버를 하나 띄웁니다
로컬러스트 9000 주소로 접속하시면 csrf-attach-using-image.html
파일이 보이실 것이고요 클릭하시면 그 페이지 접속만으로 희생자 페이지로 GET 요청이
사용자 모르게 전달되어 유저의 여행지 변경 요청이 처리되었음을 확인하실 수 있습니다
지금 실습에서는 희생자 서비스와 공격자 서비스가 모두 로컬 호스트 도메인이기에
Session 인증 쿠키가 전달된 것이고요
다른 도메인에서는 Django 기본 프로젝트 설정에서 태그나 태그를 활용한 GET
요청에서는 Session 인증 쿠키가 자동으로 전달되지 않습니다
운영체제의 호스트 파일을 수정해서 127.0.0.1 IP에 대한 도메인을 추가하실 수
있습니다 호스트 파일을 수정한 그 컴퓨터에서만 동작하는 도메인이고요 맥이나 리눅스의 경우
ETC 밑에 호스트 파일을 관리자 권한으로 수정합니다
sudo nano /etc/hosts 명령으로, 관리자 권한으로 나노 편집기를 통해
etchost 파일을 수정하는 것이고요.
127.0.0.1.mydj.com 을 입력하고, Ctrl-X 를 누르고, Y 를 눌러
저장하고 빠져나옵니다.
윈도우의 경우 C 밑에 윈도우즈 밑에 시스템32, 밑에 드라이버스, 밑에 etc 디렉토리
밑에 호스트 파일을 수정하시면 되는데요
메모장을 관리자 권한으로 띄워주시고 열기 메뉴로 호스트 파일을 열어주세요
모든 파일을 선택하시면 호스트 파일을 보실 수 있습니다
페이지 하단에 127.0.0.1 mydj.com을 입력하고 저장하고 메모장을 꺼주세요.
이제 localhost 9000 주소 대신에 mydj.com 9000 주소로 접속하시면
이미지 태그를 통한 GET 요청에서 그 요청이 거부됨을 확인하실 수 있습니다.
이미지 태그나 스크립트 태그를 통한 요청은 GET 요청만 가능한데요 두 번째 방어 방법으로
변경에 대한 요청은 POST 요청으로만 제한하고 POST 요청에 한해서는 반드시 CSRF
토큰 값을 검사하여 CSRF 토큰 값이 없거나 유효하지 않으면 요청을 거부하도록 합니다
CSRF 토큰은 입력 폼에서 발급받을 수 있고요.
포스트 요청 시에 CSRF 토큰을 전송하면 우리가 CSRF 토큰을 체크하는 것이 아니라
Django 기본 프로젝트에 활성화된 CSRF View Middleware에 의해서
CSRF 토큰의 유효성을 검사합니다.
여행 변경 뷰에서는 Require Post 장식자를 적용하여 포스트 이외의 요청은 거부하도록 합니다.
악의적인 공격 서비스에서 동일한 공격이 들어오더라도 GET 요청에 대해서는 405 METHOD NOT ALLOWED 응답을 하여 요청을 맞고 
POST 요청을 하려면 CSRF 토큰이 필요한데 공격하기가 어려워졌습니다
GET 요청에서는 CSRF 토큰을 전송할 필요가 없습니다
POST 요청에 한해서 체크하고요 CSRF 토큰을 처리하는 순서는 아래와 같습니다
포스트 요청 전에 웹 페이지에 방문해서 CSRF 토큰을 발급 받습니다
대개 입력 폼 화면에서 이루어집니다
포스트 요청을 전송할 때 발급 받은 CSRF 토큰을 같이 전송합니다 폼 태그 안에 CSRF
토큰 템플릿 태그를 그대로 둡니다
포스트 요청이 전송되면 CSRF 뷰 미드웨어에 의해서 포스트 요청에 한해 CSRF 토큰이 체크되고요.
CSRF 토큰이 없거나 유효하지 않다면 403 포비든 응답을 하고, 유효하다면 관련 뷰를 호출하여 요청을 처리합니다.
여러분들은 form 태그를 활용하여 포스트 요청을 보낼 때 CSRF 토큰 템플릿 태그만 적용하시면 CSRF 공격에 대한 방어를 하시게 됩니다.
CSRF 토큰 체크 기능이 잘 모르겠다고, 번거롭다고 끄시는 분들도 계십니다.
그러지 마세요.
장고의 CSRF 보안 기능은 여러분들의 개발을 어렵게 만들지 않습니다.
그냥 누릴 수 있는 보안 기능입니다.
만약 특별한 이유로 이 보안 기능을 꺼야만 한다면요.
전역으로 끄시려면 Settings.py 내 Middleware 리스트에서 CSRF View
Middleware를 제거하시면 되고요.
특정 뷰에 한해서만 CSRF 토큰 체크 기능을 끄시려면 CSRF 언더바 EXEMPT 장식자를 그 뷰에 적용하시면 됩니다
CSRF 토큰 체크 기능은 웹페이지 기능에서 포스트 요청을 처리할 때 유용한 기능이고요
웹 API 요청에서는 외부 서비스로부터의 포스트 요청을 다이렉트로 받아야 하기에 CSRF 토큰 체크는 적절하지 않습니다
웹 API 요청을 처리하는 Vue에서는 CSRF 토큰 체크 기능을 끄는 것이 일반적입니다.
Django REST 프레임워크를 활용한 웹 API 구현에서는 이렇게 CSRF_EXEMPT 장식자가 기본 적용되어 있어서 
해당 Vue에서는 포스트 요청에서 CSRF 토큰 체크를 하지 않습니다. 
간략히 정리해보자면, GET 요청은 조회 목적으로만 사용하시고, 변경이나 삭제 요청은 POST 요청을 통해 처리해주세요.
함수 기반 뷰는 요청 타입에 상관없이 모두 호출이 됩니다.
변경을 수행하는 뷰라면, require_POST 장식자나 require_http_methods 장식자를 통해 
허용할 요청 타입에 한해서만 호출이 되도록 제안을 걸어주세요.
클래스 기반 뷰에서는 허용할 요청 타입의 메서드를 구현하시면 그 외의 요청 타입에 대한 요청에 대해서는 클래스 기반 뷰에서 405 메서드 낫 얼로우드 응답으로 처리해 줍니다.