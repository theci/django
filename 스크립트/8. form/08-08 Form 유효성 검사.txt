안녕하세요. 이번 시간에는 Form 유효성 검사에 대해서 살펴보겠습니다.
클라이언트로부터의 전달받은 값은 백엔드단에서 값에 대한 검증이 반드시 이루어져야 합니다.
유저로부터 이메일 문자열을 받아서 유저 이메일 값으로 서버에 저장하려 합니다.
유저가 입력한 문자열이 이메일인지 검사하기 위해서 입력 폼 태그의 서브 및 이벤트 핸들러를 통해 프론트엔드 단의 자바스크립트 코드로 이렇게 유효성 검사를 합니다.
유저가 입력한 문자열이 이메일 포맷이 아니라면 서버로 이메일 변경 요청을 보내지 않도록 했어요.
서버단에서는 클라이언트단에서 이메일 포맷 검사를 하기에 포스트 요청으로 전달받은 값이 이메일 값임을 신뢰하고 그대로 저장합니다.
아무 문제가 없는 잘 짜여진 서비스로 보여집니다.
하지만 유저가 브라우저에서 자바스크립트를 끈다면 유저가 입력한 값에 대한 이메일 유효성 검사는 동작하지 않고요.
서버로 보내지는 포스트 요청을 유저가 흉내내어 직접 패치 자바스크립트 API를 호출해서 요청을 보낼 때 
임의의 값으로 보낸다면 그 보내지는 값으로 서버에서는 그대로 저장을 해버립니다.
클라이언트 측의 유효성 검사는 서버 통신 없이 로컬에서 수행되고 값 변경 시마다 빠른 피드백이 가능합니다.
포맷에 대한 유효성 검사만 가능하고요.
유일성 검사가 필요하다면 이는 서버 단에서 이루어져야 합니다.
서버 단이 아닌 클라이언트 단에서 수행되기에 변조 가능성이 높습니다.
그러니 클라이언트 단에서 유효성 검사를 한다고 해서 그 입력을 신뢰하고 백엔드 단에서 그대로 저장해서는 안 됩니다.
서버 측의 유효성 검사는 유저가 폼을 제출한 후 서버에서 데이터를 처리하기 전에 유효성 검사가 이루어지고요.
서버 단에서 유효성 검사 후에 서버 응답을 받기 전까지는 유저는 기다려야 하니까 클라이언트 유효성 검사보다는 다소 느린 피드백입니다.
하지만 다양한 비즈니스 로직에 대한 유효성 검사가 가능하고요.
변조 가능성 없이 안전합니다.
서버단에서는 이처럼 입력받은 값에 대해서 필히 유효성 검사가 이루어져야 합니다.
이처럼 서버단에서 입력 값에 대한 유효성 검사가 이루어진다면 이메일 포맷에 대한 검사뿐만 아니라 이메일에 대한 유효성 검사를 수행할 수도 있겠고요.
이메일을 저장하기 전에 이메일 소유에 대한 확인 프로세스를 진행하실 수도 있습니다.
이제 이메일이 아닌 값으로 요청을 받더라도 이렇게 이메일 포맷이 아닙니다라는 400배드 리퀘스트 응답을 할 수 있게 되었네요.
슬라이드에서는 간단한 파이썬 코드로 문자열이 이메일 포맷인지 검사했지만, 
Django 기본에서는 이메일 Validator 클래스를 통해 RFC 표준을 기반으로 엄격한 이메일 주소 검사를 제공해줍니다.
서버단에서의 유효성 검사는 단순히 값 유무에 대한 검사부터 요구되는 포맷에 대한 검사 및 비즈니스 로직에 따라 다양한 유효성 검사가 필요할 수 있습니다.
다양한 유효성 검사 로직을 구성하고 관리하기 위한 체계를 Django에서는 Form 기능을 통해 제공합니다.
장고의 유효성 검사 함수는 반드시 인자 1개를 받아야 하고요.
그 인자의 값이 유효하지 않다면 validation error 예외를 발생시켜야 하고, 유효하다면 예외 없이 함수를 종료시키면 됩니다.
유효성 검사 함수에서 값을 반환하더라도 그 값은 사용되지 않습니다.
그에 반해 나중에 다룰 Django Form Class에서의 Clean 함수에서도 유효성 검사를 수행하는데요.
값이 유효하지 않다면 ValidationError 예외를 발생시키는 것까진 같지만, 함수에 반환 값이 꼭 필요하며, 반환 값은 값 변환에 사용이 됩니다.
정규 표현식으로 이메일 포맷을 검사하는 유효성 검사 함수는 이렇게 구현할 수 있으며, 
인자 문자열이 이메일 포맷이 아닐 경우 ValidationError 예외를 발생시킵니다.
이메일 포맷 검사는 Django 기본에서 ValidateUnderbarEmail 함수를 제공해줍니다.
유효성 검사 함수를 호출할 때 validation error, 예외 발생 여부를 체크해서 오류 발생 시에 400배드 리퀘스트 응답을 하도록 했어요.
그럼 이메일 포맷이 아닌 값으로 이메일 변경 요청을 받더라도 이렇게 서버에서 오류를 내어주게 됩니다.
폼에서 입력받는 필드가 여러 개일 때 각 필드별로 유효성 검사를 합니다.
그룹 필드를 추가했습니다.
select 요소로 입력을 받기에 선택지로 제공된 값들로만 서버로 전송이 될 듯 하지만 
유저가 브라우저의 개발자 도구나 확장 프로그램을 통해서 웹페이지의 선택지를 변경할 수도 있고요. 
HTTP 요청을 흉내내어 임의의 값으로 없는 그룹명으로 전송할 수도 있습니다.
그룹에 대한 유효성 검사가 없다면 이렇게 지원하지 않는 그룹명으로 변경이 되어 버릴 것입니다.
서버단에서는 전달받은 그룹명이 허용된 그룹명인지 검사해야만 합니다.
이 그룹명은 데이터베이스 테이블에 저장이 되어 있을 수도 있겠지만, 간결한 구현을 위해 소스코드의 하드코딩으로 허용 그룹 목록을 나열해서 검사하겠습니다.
프로필 에디트 뷰에서는 이메일 값에 대한 유효성 검사 외에도 이렇게 그룹에 대한 유효성 검사도 수행하고 
두 개의 유효성 검사를 모두 통과하고 밸리데이션 에러 예외가 발생하지 않았다면 이메일 변경 응답을 합니다.
존재하지 않는 그룹 명으로 요청하면 이렇게 400 배드 리퀘스트 응답을 받게 됩니다.
유효성 검사는 이메일 필드 값과 그룹 필드 값의 포맷을 검사하는 것에서 그치지 않고 두 개 이상의 필드 값을 조합해서 등록 여부에 대한 검사를 구현하기도 합니다.
게임 서버가 여럿 있을 때 한 게임 서버 내에서는 아이디가 유일해야 함을 검사하는 경우도 있습니다. 
입력받은 그룹 내에서 이미 등록된 이메일 주소다면 등록을 거부토록 이렇게 유효성 검사를 구성할 수 있습니다.
그럼 프로필 에디트 뷰에서는 총 세 개의 유효성 검사를 구현했고요.
이메일 포맷에 대한 유효성 검사, 지정 그룹 포함 여부에 대한 유효성 검사, 지정 그룹 내에 이미 등록된 이메일 주소인지를 검사하는 유효성 검사, 이렇게 3개입니다.
그런데 유효성 검사 로직이 Vue에 직접 뒤섞여 있어 Vue가 여러 책임을 가지게 되고 유지 보수성이 나쁘고 가독성도 떨어집니다.
게다가 새로운 유효성 검사 조건이나 그룹을 추가하려면 Vue 코드를 뜯어보고 수정해야 하죠. 
Vue로부터 유효성 검사의 책임을 분리하기 위해 Django에서는 Form을 지원합니다. 
프로필 폼, 폼 클래스를 뒤 슬라이드에서 구현할 텐데요.
데이터 인자로 전달받은 값을 기반으로 앞서 수행한 3개의 유효성 검사에 책임을 가집니다.
생성된 폼 인스턴스에 이전 더바 밸리드 메서드를 호출하면 그 즉시 그 폼에 등록된 모든 유효성 검사를 수행하고 단 한 개의 유효성 검사라도 실패한다면 거짓을 반환합니다.
뷰에서는 어떤 필드에 대한 유효성 검사인지를 신경 쓸 필요가 없습니다.
단지 데이터만 넘기고 전체 유효성 검사가 수행되도록 isUnderbar valid 메서드만 호출하고요. 
그 반환 값에 따라 유효성 검사 성공 실패 응답만 하면 됩니다.
이렇게 뷰에 장고 폼을 적용하면 뷰 함수가 간결해져서 가독성이 향상되고 유효성 검사의 책임이 폼으로 이관되었습니다.
새로운 필드나 새로운 유효성 검사 조건을 추가하려면 폼만 수정하면 됩니다.
폼은 다른 뷰나 모델에서도 쉽게 재사용할 수 있습니다.
장고 폼 클래스 선언은 모델 클래스 선언과 비슷합니다.
폼지에 폼 클래스를 상속받는 것으로부터 시작합니다.
그리고 입력받을 필드를 폼 필드로 추가하고요.
각 폼 필드에 대한 유효성 검사는 clean-field명 메서드를 구현하면 유효성 검사를 수행할 때 자동으로 호출됩니다.
clean-underbar-group-method는 그룹 필드에 대한 유효성 검사에 책임이 있습니다. 
form 인스턴스 내에서 입력 값은 cleaned-underbar-data 사전을 통해서 유지 관리됩니다.
cleaned-underbar-data 사전에서 그룹 명을 꺼내서 유효성 검사를 수행합니다. 
유효성 검사에 실패했을 때에는 ValidationError 예외를 발생시키고요.
앞서서 Validate__Allowed__Group 함수를 구해냈으니 이를 호출해서 유효성 검사를 수행하겠습니다.
클린 메서드는 유효성 검사의 책임뿐만 아니라 값 변환의 책임도 가지고 있습니다.
클린 메서드에서 반환한 값이 변환된 값으로써 클린 메서드에서 반환한 값이 클린드 언더바 데이터 사전에 다시 반영됩니다
값 변환의 예로써 띄어쓰기를 허용하지 않는 필드이지만 띄어쓰기를 포함한 문자를 입력 받았을 때 띄어쓰기를 제거한 문자로 변환할 수 있습니다.
이메일 필드에 대한 유효성 검사도 수행해 주고요.
clean__group 메서드와 clean__email 메서드는 개별 필드에 대한 유효성 검사 및 값 변환에 책임이 있으며, clean 메서드는 다수 필드에 대한 유효성 검사 및
값 변환에 책임이 있습니다.
이메일 값과 그룹 값을 조회해서 해당 그룹에 이미 등록된 이메일 주소인지 여부를 검사하기 적당합니다.
클린메서드에서의 반환값은 cleaned_data 사전에 그대로 덮어쓰기 하는데요 
클린메서드에서 값 변환이 없고 단지 유효성 검사만 할 것이라면 값을 반환하지 마세요 
클린메서드에서는 반환값이 None이라면 cleaned-underbar-data 사전으로의 덮어쓰기를 수행하지 않습니다
유효성 검사에 실패했을 때에는 errors 사전 속성에 각 필드에 대한 에러 내역이 저장되어 있습니다.
앞선 슬라이드에서는 form 처리 내역을 HTML이 아닌 단순 문자열로 보여주도록 했었기 때문에 에러 내역을 문자열로 변환해주는 errorsString 메서드를 추가로
구현했습니다.
이렇게 프로필 폼 클래스 구현을 마쳤고요.
그룹 필드와 이메일 필드에 대한 개별 유효성 검사는 단지 외부 유효성 검사 함수를 호출만 했을 뿐이죠. 
이럴 때에는 폼 필드에 validators 속성으로 해당 폼 필드에 대한 유효성 검사 함수를 추가해 주시면 유효성 검사 시에 폼에서 자동으로 호출해 줍니다.
이렇게 코드를 줄이고 가동성을 높이며, 유효성 검사에 대한 재사용성을 높였습니다.
이메일 필드는 자주 사용이 될 텐데요.
매번 CharField, FormField를 추가하고, Validators 속성으로 ValidateEmail 함수를 추가하는 것은 반복입니다.
그래서 이러한 반복을 CustomFormField를 만들어서 제거하실 수 있고요.
폼즈에서 이메일 필드를 기본으로 지원해 주고 있으며 여러분들도 프로젝트에서 반복되는 폼 필드 선언은 이렇게 커스텀 폼 필드를 만드시어 반복을 줄여나가실 수 있습니다 
폼에 바이오 필드를 하나 추가했습니다
바이오 필드 문자를 입력 받을 때 악의적인 유저는 HTML이나 JavaScript 코드를 같이 작성해서요 
크로스 사이트 스크립팅 공격을 시도할 수 있습니다
이렇게 유저가 입력한 HTML 코드가 웹에 그대로 노출되어서는 안 됩니다.
이는 일부러 위험 상황을 예시로 만든 것이고요.
장고 기본에서는 이러한 크로스 사이트 스크립팅 공격을 막는 장치가 기본 설정되어 있습니다. 
크로스 사이트 스크립팅 공격에 위험이 있는 태그 문자열은 굳이 데이터베이스에 저장할 필요가 없을 것입니다.
태그 문자열을 제거하고 데이터베이스에 저장한다면 데이터베이스 데이터를 사용할 때마다 크로스 사이트 스크립팅 공격의 위협을 계속 걱정할 필요가 없겠죠.
바이오 필드에 대한 가편한 힘으로 clean-underbar-bio 메서드에서 태그 문자열 제거를 구현하는 것이 적절합니다.
스트립 태그스 함수를 지원하니 호추에서 태그가 제거된 문자열을 반환합니다.
그러면 반환된 문자열이 다시 클린드 언더바 데이터 사전에 저장이 되고요.
이렇게 HTML 문자열을 입력받더라도 HTML 태그가 제거된 문자열로써 저장이 되는 거죠.
HTML 태그를 지원해야 하는 경우라면 모든 HTML을 허용하는 것이 아니라 안전한 일부 태그만 허용해야만 합니다.
이때 장고 Bleach 라이브러리의 도움을 받으실 수 있습니다.