안녕하세요. 이번 시간에는 장고 폼 클래스와 모델 폼 클래스를 활용한 포스팅 생성 및
수정, 뷰 구현 방법에 대해서 살펴보겠습니다.
블로그의 New 주소에서 포스팅 생성을 위한 기능을 제공하려 합니다.
폼 요청 처리 시에는 두 개의 요청을 받아서 처리할 수 있어야 하고요.
첫 번째는 초기 입력 폼을 보여주는 요청이며, 두 번째는 입력 폼을 통해 전송된 데이터에
대한 유효성 검사 및 저장 요청입니다.
이 두 개의 요청을 서로 다른 뷰에서 처리할 수도 있겠지만, Django에서는 하나의 뷰
내에서 Get과 Post 요청 타입에 따라 이 두 개의 요청을 나누어 처리합니다.
Get 요청일 때에는 입력 폼을 제공해 달라는 요청으로 보고요.
초기 입력 폼을 제공하는 HTML 응답을 합니다.
포스팅 생성 페이지에서는 빈 폼으로 응답을 할 것이고요.
포스팅 수정 페이지에서는 수정할 포스팅의 내용으로 채워진 폼으로 응답을 할 것입니다.
이때 폼 태그의 액션 속성은 빈 문자열, 메서드 속성은 반드시 포스트로 지정되어 있어야
합니다. 왜냐하면 액션 속성을 생략하거나 비워두면 같은 주소로 입력 값 전송을 받을
테고요. 포스트 요청으로 입력 값 전송임을 뷰에서 인지토록 합니다.
그럼 유저는 해당 폼에 값을 채워놓고 제출 버튼을 클릭하여 제출합니다.
빈 폼을 받은 주소와 같은 주소로 포스트 요청으로 입력 값을 전송하겠죠.
그럼 뷰에서는 포스트 요청이기에 입력 값 전송으로 판단하고 전달받은 값으로 유효성 검사를
수행합니다.
일반적으로 Django Form Class를 통해 유효성 검사를 수행하고요.
단 하나의 유효성 검사라도 실패한다면 에러 메시지와 함께 입력 서식 HTML을 다시
응답하여 유저에게 재입력을 요구합니다.
예를 들어 서비스에서 로그인 하실 때 로그인 암호가 틀리면 재입력을 요구하는 상황인
것이죠. 모든 유효성 검사를 통과한다면 유효성 검사에 통과한 값들을 그 뷰의 목적에 맞게
처리하고 다른 페이지로 리다이렉트 응답을 합니다.
새로운 블로그 포스팅 작성 요청을 한다면 포스팅을 데이터베이스에 저장을 할 테고요.
포스팅 저장 후에 포스팅 작성 폼에 머물러 있는 서비스는 거의 없습니다.
대개 작성된 포스팅 내용을 보는 디테일 페이지나 목록 페이지로 이동을 시킬 것입니다.
장고 폼은 입력 HTML을 자동 생성하고 사용자 입력을 검증하고 정제된 데이터를 제공하는
기능을 제공해 줍니다.
입력받을 폼 구성에 맞게 폼 클래스를 선언합니다.
제목은 한 줄 문자열로 입력받을 테니 캐릭터 필드, 폼 필드로 선언하고요.
이는 인풋 타입 텍스트 태그로 렌더링 됩니다.
내용은 문자열이니 캐릭터 필드, 폼 필드로 선언하고요.
여러 줄 입력을 받기 위해 텍스트 에어리어 위젯을 지정합니다.
이는 텍스트 에어리어 태그로 렌더링 됩니다.
포스팅 상태는 유저에게 선택지를 주고 선택을 요구할 것이기에 Choice Field,
Form Field를 사용하고요.
Choice Is 키워드 인지를 통해 선택지 목록을 지정합니다.
각 선택지는 Select 태그의 옵션 항목으로 렌더링됩니다.
유효성 검사 시에 입력 값이 선택지 목록의 D나 P 인지를 자동으로 검사해 주고요.
대표 사진 필드는 이미지를 입력받을 것이기에 이미지 필드, 폼필드를 지정하고요.
옵션 필드로 설정하기 위해 required 거짓 설정을 합니다.
제목, 내용, 상태, 폼필드는 모두 필수 필드로서 값이 지정되지 않으면 유효성 검사 에러가
발생합니다.
브라우저가 블로그의 new 주소로 get 요청을 보내어 초기 입력 폼을 요청합니다.
유저가 새 포스팅 쓰기 링크를 눌러서 이동했거나, 주소창에 블로그 new 주소를 직접
입력해서 들어왔거나, 혹은 북마크된 블로그 new 주소로 들어왔다면 모두 get
요청입니다. 이 뷰에서는 Post 폼 클래스의 인스턴스를 생성하고, 템플릿에서는 폼
인스턴스의 as table 메서드를 호출하여 HTML 코드를 자동 생성합니다.
템플릿에서는 폼필드에 대한 코드는 1도 없습니다.
폼필드 렌더링에 대한 책임은 PostForm 클래스에 있죠.
아래와 같이 화면이 보여질 것입니다.
유저가 입력 폼에 값을 채우고 전송을 누르면 같은 주소로 포스트 요청이 날아갈 것이고요.
뷰에서는 포스트 요청이니까 입력 데이터를 통해 PostForm 클래스의 인스턴스를 생성하여
요청을 처리합니다.
포스트 요청에서는 request.post 속성에 파일을 제외한 포스트 데이터가 저장되어
있고요
request.files 속성에 파일 데이터가 저장되어 있습니다 유효성 검사를 수행하여
입력 값을 검증하고 단 하나의 유효성 검사라도 실패한다면 isValid 함수가 거짓을
반환합니다 그러면 에러 응답을 다시 템플릿 응답으로 생성하고요
템플릿 응답을 통해 유저에게 에러 입력 화면을 다시 보여주고 재입력을 요구합니다
모든 유효성 검사가 통과한다면 정제된 값들을 cleaned_data
사전으로 제공하니 뷰 목적에 맞게 적절히 처리하면 되겠습니다.
first-form, form-class의 책임은 여기까지고요.
나머지는 뷰에서 처리합니다.
저는 이 데이터들을 데이터베이스에 저장하려 합니다.
Django에서는 모델을 이용하면 편리하니까 이렇게 first-model 코드를 제목,
내용, 상태, 사진, 생성 날짜, 필드로 구성했습니다.
홈필드 코드와 비슷하죠?
유효성 검사에 통과한 값들을 모델을 통해 저장해 봅시다.
새로운 모델 인스턴스를 생성하고 cleaned_data 사전으로부터 값을 하나씩 꺼내어 값을
할당하고요.
업로드된 파일의 경우에는 단순히 필드 할당이 아니라 포토 이미지 필드의 save 메서드를
호초하여 디스크의 파일 내용을 먼저 저장하고요.
포토 이미지 필드에는 저장된 파일의 상대 경로 문자열이 저장됩니다.
마지막으로 instance.save 메서드를 호출하여 데이터베이스에 저장하고 다른 주소로
이동 응답을 하면 포스팅 저장 과정이 끝납니다.
포스트폼 클래스와 포스트 모델 구성이 비슷한데요.
최적 목표인 포스트 모델을 통해 저장을 할 테니 포스트폼 클래스도 포스트 모델과 비슷하게
만들게 되겠죠.
그리고 포스트 모델 구성이 변경될 때마다 포스트폼 클래스 구성도 같이 변경되어야 할
것입니다. 이 경우 장고의 모델 폼 기능을 활용하면 포스트 폼 폼 코드를 보다 간결하게
가져가실 수 있고요.
포스트 모델만 변경하면 포스트 폼 클래스에도 자동으로 그 변경이 반영되게 할 수 있습니다.
블로그 앱의 포스트 모델은 이미 다양한 필드가 있으니 웹 로그 앱의 포스트 모델에 필드를
추가해서 실습을 진행해 보겠습니다.
모델 필드들을 추가하고 Make Migrations 웹 로그 명령으로 마이그레이션 파일을
생성하고요.
createdDateField에 대해서는 일회성 디폴트 값으로 timeZoneNow 함수를
지정합니다. 그러면 마이그레이트가 적용되는 시점의 시각이 모든 행에 동일하게 적용됩니다.
migrateWebLog 명령으로 해당 마이그레이션을 데이터베이스에 적용하고요.
포스트 모델을 통해 저장할 테니 포스트 모델 내역대로 form 클래스를 구성해봅시다.
클래스명은 PostForm이며 Forms의 Form 클래스를 상속받고요.
CharField, ModelField와 TextField, ModelField는
모두 CharacterField, FormField로 변경합니다.
데이터베이스에서는 여러 문자열 타입이 있지만, Python이나 HTML에서는 문자열 타입이
단 하나이기 때문에 문자열 필드는 Character 필드, Form 필드 하나밖에
없습니다. Status 필드는 선택지를 제공할 것이기에 ChoiceField, FormField를
사용하고요.
Choices 인자로 선택지를 지정합니다.
Photo 필드는 ImageField, FormField를 적용하고, Option 필드로 처리할
것이기에 Required 거짓 인자를 지정합니다.
CreatedDateField는 유저로부터 입력받는 값이 아니기에 삭제합니다.
새로운 PostNewView 함수를 생성하고 템플릿을 통해 단순히 응답만 해보겠습니다.
템플릿 파일명은 앱 이름 밑에 모델명 소문자 언더바 폼.html 포맷으로 지정했습니다.
이는 Django 크레이트뷰 클래스 기반 뷰의 관례로서 디폴트 템플릿 파일명입니다.
해당 템플릿 파일을 PyCharm 기능으로 자동 생성하려면 웹로그 폴더 밑에 템플릿 폴더가
있어야 하니 생성해 주시고, PyCharm 기능으로 템플릿 파일을 생성합니다.
혹은 웹로그 밑에 템플릿 밑에 웹로그 경로에 post__form.html 파일을 직접
생성해 주셔도 됩니다.
템플릿 파일에 postform 태그만 쓰고 저장하고요.
postnew 뷰가 호출되기 위해 웹로그 밑에 urs.py 파일을 생성하고 url 패턴도
추가해줍니다.
mysite.urls에 weblog.urls를 include도 해줘야겠죠.
그럼 localhost 8000 웹로그 new 요청에서 이렇게 템플릿 응답을 받게 되고요.
postnew 뷰에서 post_form 클래스의 인스턴스를 생성해서 템플릿 단에서 html로
렌더링을 해봅시다.
폼 인스턴스를 그대로 렌더링하시면 폼 인스턴스에서는 as table 메서드를 자동으로
추하여 HTML 문자열을 생성해 줍니다
웹 페이지에 폼 필드들이 보여지긴 하는데 폼 필드들이 열이 맞지 않죠
HTML 소스 보기를 하시면 테이블 태그에 태그는 없고 있는데 테이블 태그와 폼 태그가 없습니다
as table 메서드는 폼필드 내역에 대해서만 렌더링을 제공할 뿐, table 태그와
form 태그는 직접 지정해야 합니다.
as table 외에도 as div, as p, as ul 메서드가 제공되며, 이외에도
폼필드를 렌더링하고 레이아웃을 잡는 다양한 방법이 있습니다.
폼 전송을 통한 생성, 수정, 삭제 요청에서는 항상 포스트 방식으로 전송해야 하고요 파일
전송이 필요하니까 ENC 타입 속성으로는 멀티파트 폼 데이터를 지정해서 브라우저에서 파일
전송을 할 수 있도록 합니다
서브밋 버튼도 추가하고요 페이지
새로고침하고 전송할려니 어떤 유효성 검사 오류가 뜹니다
이는 장고 서버의 유효성 검사 오류가 아니라 폼 제출 전에 브라우저에서 유효성 검사를
수행하고 오류가 있어서 폼 제출을 막은 상황입니다
아직 장고 서버로 전송되지 않았습니다.
브라우저의 유효성 검사는 브라우저마다 동작과 UI가 다를 수 있으니 끄겠습니다.
태그에 속성을 추가하고요.
페이지를 새로 고침해 주시고 다시 제출하시면 CSRF 검증에 실패했다는 403
forbidden 응답을 받았습니다.
요청에서 CSRF 토큰 값이 누락되었다고 하네요.
장고에서는 포스트 요청에서 항상 CSRF 토큰 값을 검사하는 보안 기능이 활성화되어 있죠.
폼 태그 내에 CSRF 언더바 토큰 템플릿 태그만 넣어두시면 인풋 타입 히든 요소로
CSRF 미들웨어 토큰 값이 자동으로 생성되고요.
UI 딴에는 보여지지 않고 폼 전송 시에만 자동으로 전달됩니다.
페이지 새로 고침하실 때마다 토큰 값이 자동으로 변경되고 있죠.
페이지 새로 고침하시고 제출해 보시면 이번에는 폼 제출은 되는 듯한데 오류조차 없습니다.
개발 서버 로그에 보시면 포스트 요청 로그가 있네요.
포스트 요청으로 전달되었습니다.
그런데 화면에 변화가 없는 것은 뷰 코드에서 단순히 빈 포스트 폼 인스턴스만 생성해서
응답할 뿐 포스트 데이터를 처리하지 않았기 때문입니다.
뷰에서 요청 타입으로 분기합니다.
GET 요청에서는 빈 포스트폼 인스턴스를 생성하고, 포스트 요청에서는
request.post 속성과 request.files 속성 값을 포스트폼 생성자로 넘겨서
인스턴스를 생성합니다.
이어 isValid 메서드를 호출하여 포스트 폼에 등록된 모든 유효성 검사를 수행합니다.
유효성 검사에 모두 통과하면 참을 반환할 테고요.
폼 인스턴스에서는 form.cleaned_data 사전을 제공받는 것까지가
포스트 폼 클래스의 역할은 끝입니다.
유효성 검사에 실패하면 거짓을 반환하고요.
이때는 특별히 다른 작업을 수행할 것은 없고요.
폼 인스턴스에 에러 내역까지 모두 저장되어 있습니다.
그대로 폼 인스턴스를 템플릿을 통해 렌더링하면 에지테이블 메서드에서 에러 내역까지 모두
HTML로 렌더링 해줍니다
아! 컨텐츠 필드가 한 줄 입력으로 되어 있네요
텍스트 에어리어 위젯을 지정하면 여러 줄 입력을 받을 수 있습니다
제목과 내용을 입력하고 제출하면 개발 서버 로고에 보시면 유효성 검사에 통과한
Cleaned Data 사전을 확인하실 수 있습니다
사진 파일로 지정하고 다시 제출해 보시면 이렇게 업로드된 파일 객체도 확인하실 수 있습니다
뷰코더에서 포스트 모델을 통해 유효성 검사에 통과한 값들을 저장해 봅시다 파일 필드,
이미지 필드를 제외한 필드들은 모두 값을 그대로 활당하시면 되고요
포토필드는 이미지 필드이기에 필드의 값을 할당하시면 파일 저장이 아니라 인스턴스의 속성을
덮어쓰기 해버립니다.
사진 필드에 save 메서드를 호출하여 파일을 저장합니다.
이는 로컬 파일 스토리지 디스크에 파일을 저장하는 것일 뿐 아직 인스턴스 내역을
데이터베이스에 저장하는 것은 아닙니다.
save 메서드 구현을 보시면 총 3개의 인자를 지원합니다.
첫 번째 인자는 파일명, 두 번째 인자는 파일 객체, 세 번째 인자는 모델 인스턴스의
save 메서드 자동 호출 여부입니다.
파일 저장 시에 저장될 파일명을 생성하고, 스토리지에 파일을 저장한 후에 저장된 경로를
얻어내고, 모델 필드의 상대 경로를 저장합니다.
save 인자가 참이면 모델 인스턴스의 save 메서드를 호출하여 데이터베이스도에 저장을
시도합니다. 파일 객체는 Django의 UploadedFile 타입이고요.
name 등의 다양한 속성을 지원합니다.
save method 첫 번째 인자로 파일 객체의 name 속성으로 파일명을 지정하고, 두
번째 인자로 Django 파일 객체를 지정하고요.
세 번째 인자로 거짓을 지정하여 모델 인스턴스 저장을 뒤로 미뤘습니다.
따로 모델 인스턴스의 save method를 호출하여 데이터베이스로의 저장을 시도합니다.
포스팅 생성 요청을 성공적으로 처리했으니 다른 페이지로 이동을 시키는 것이 적절합니다
포스트 디테일 뷰를 구현했다면 해당 주소로 이동시키는 것이 적절하겠지만 아직 구현이 없으니
루트 주소로 이동 응답을 하겠습니다
다시 포스팅 생성 요청을 하시면 루트 주소로 이동을 하네요.
정상 처리되었나 봅니다.
어드밋 페이지에서 확인해 보시면 입력한 값으로 포스팅이 잘 저장되었음이 확인됩니다.
업로드된 파일 링크를 클릭해 보시면 요청 주소가 localhost:8000에 파인명이 이어진
주소인데요. 현재 404 오류가 뜨는 것은 이 주소에 요청을 처리하는 뷰가 없기 때문이고
이 뷰는 지정 URL에 매칭되는 파일을 파일 스토리지에서 읽어와서 응답을 해줘야만 합니다.
파일은 프로젝트 루트 디렉토리에 다른 소스 코드와 섞여 저장이 되어 있네요.
뒤에서 다룰 장고 미디어 설정을 미리 해보겠습니다.
세팅스에서 미디어 URL 설정과 미디어 루트 설정을 추가합니다.
미디어 URL 설정은 업로드된 파일을 요청하는 요청인지를 구별하는 URL 프리픽스이고요.
디폴트 값은 빈 문자열입니다.
미디어 슬러시로 시작되는 요청은 업로드된 파일을 조회하는 요청으로 판단하려 합니다.
미디어 루트 설정은 파일을 저장하고 찾는 디렉토리 경로입니다.
디폴트 값은 빈 문자열입니다.
미디어 루트 경로에 파일을 저장하게 되고 업로드된 파일을 찾는 요청에서는 미디어 루트 경로
아래에서 파일을 찾을 것입니다.
Settings 파일 저장하시고요.
미디어 루트 설정을 프로젝트 루트 경로 아래에 Media Files 경로로 지정했으니
프로젝트 루트 경로에 Media Files 폴더를 생성하고 업로드된 파일도 이 폴더로
옮겨줍니다. 그리고 페이지 새로고침하시고 다시 해당 파일 링크를 클릭해 보시면 URL
주소에 미디어 슬러시가 추가되어 있음을 확인하실 수 있고요.
조금 전 미디어 URL 설정 값이 자동으로 추가되어 있습니다.
그런데 아직 이 요청을 철회하는 뷰가 없어요.
mysite.urspy 파일에 django.conf.urls.static에 static
함수를 호출하여 반환 값으로 urlpatterns.list를 확장합니다.
static 함수는 url 패턴 리스트를 반환하고요
첫 번째 인자로 미디어 url 설정 값과 document root 인자로 미디어 루트 설정
값을 지정하면 미디어 url 설정 값으로 시작되는 요청에 대해서 미디어 루트 경로에서
파일을 찾아서 응답을 해줍니다
페이지 새로고침 하시면 파일 서빙이 잘 됩니다.
참고로 이 static 함수는 settings에서 디버그 설정이 참인 개발 모드에서만
동작하고요. 서비스 모드인 거짓 설정에서는 빈 리스트를를 반환하여 파일 서빙을 지원하지
않습니다. 이는 장고는 정적 파일 서빙 기능을 개발 서버에서 개발 편의성을 위해서 지원할
뿐 실서비스급의 서빙 지원은 엔진엑스, 아파치 웹서버나 CDN과 같이 이미 충분히 좋은
서비스 혹은 서버가 많기 때문에 장고에서는 관심을 두고 있지 않습니다.
마지막으로 포토필드는 옵션 필드로 두었으니 파일이 업로드되지 않은 상황도 있습니다.
그때에는 클린더 언더바 데이터 사전에는 논 값이 저장되어 있어요.
포토파일이 논이 아닐 때만 파일 스토리지에 저장하도록 합니다.