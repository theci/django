안녕하세요. 이번 시간에는 요청 객체에 대해서 살펴보겠습니다.
장고에서는 HTTP 요청을 받으면 HTTP 요청의 모든 내역을 HTTP 요청 타입의 요청 객체에 담아서 뷰 함수를 호출 시에 전달하며 요청을 처리합니다.
뷰 함수의 첫 번째 인자는 항상 요청 객체이고요.
클래스 기반 뷰에서는 self.request를 통해 요청 객체를 참조하실 수 있습니다.
뷰에서 해당 요청을 모두 처리한 뒤에 처리 결과를 HTTP 응답 타입의 응답 객체를 통해 반환해야만 하고요.
반환된 응답 객체는 HTTP 요청을 한 클라이언트에게 전달됩니다.
HTTP 요청 객체의 메서드 속성은 HTTP 요청 타입입니다.
항상 대문자로서 GET과 POST 요청이 됩니다.
같은 주소의 요청에 대해서는 항상 같은 뷰가 호출이 되는데요
같은 뷰가 호출이 될 때 요청 타입을 통해 요청의 성격을 구별하게 됩니다
GET 요청일 때는 조회로서 처리하고요 POST 요청일 때는 추가, 수정, 삭제로서 처리하는 거죠
HTTP 폼 태그에서는 GET 요청 및 POST 요청만을 지원하기에 장고 폼에서도 GET과 POST만으로 분기를 해서 요청을 처리하고요.
웹 API에서는 HTTP 폼을 통한 요청뿐만 아니라 JavaScript나 여러 프로그래밍 언어에 의해서 요청이 만들어지는데 
이때에는 요청 타입을 PUT, PATCH, DELETE 등으로 확장하게 됩니다.
패스 속성은 HTTP 요청을 받은 쿼리 스트링을 제외한 전체 경로입니다.
사용 예로써 요청 경로를 포함한 로그를 남기거나, 현재 경로 문자열을 템플릿에 전달하여 현재 메뉴에 강조 처리를 할 때 사용합니다.
바디 속성은 HTTP 요청 바디의 로우 데이터입니다.
HTTP 요청을 보낸 클라이언트가 사용한 인코딩에 따라 여러 포맷이 있을 수 있는데요.
URL 인코디드 인코딩과 멀티파트 폼 데이터 인코딩에 대해서는 장고 기본에서 자동 변환을 지원하여 request.post 속성과 request.files 속성을 통해 참조하실 수 있고요. 
JSON 요청의 경우에는 웹 API이기에 장고 기본에서는 자동 변환을 지원하지 않고 직접 수동으로 JSON.ROSE API 호출을 통해서 처리하실 수도 있고,
django-rest-framework를 적용하시면 JSON 요청도 자동 변환을 지원합니다.
메타 속성은 요청의 HTTP 헤더 및 파이썬 웹서버의 몇 가지 메타 정보를 담고 있는 사전입니다.
HTTP 헤더에는 키에 대문자로 HTTP:// 접두사가 항상 붙고 대문자로 저장되어
있습니다. 
요청 클라이언트의 브라우저 종류는 대문자로
HTTP_USER_AGENT_KEY로 참조하실 수 있고요.
이전 페이지 주소를 나타내는 레퍼러 헤더는 대문자 HTTP_REFERRER_KEY를
통해 참조하실 수 있습니다.
헤더스 속성은 메타 속성에서 http 헤더만 추출했고요.
대소문자를 구분하지 않고 http 헤더를 참조할 수 있도록 도와줍니다.
대소문자가 섞인 키를 지정하더라도 키 에러가 발생하지 않고 키 조회가 됩니다.
키는 메타 속성의 http 헤더에서 대문자 HTTP_ 접두사를 제거하고 언더바 문자를 hyphen으로 변경한 키입니다.
쿠키 속성은 쿠키 헤더에 담겨있는 쿠키 문자를 파싱한 사전이며, 이 사전을 변경하더라도 쿠키 값이 변경되진 않습니다.
쿠키 값 설정은 응답 객체의 setCookie 메서드를 활용하고요 이때 쿠키 만료 시간 등의 쿠키 설정 인자도 함께 지정합니다

첫 번째로 get 속성입니다
쿼리 스트링 문자열 원본은 메타 속성의 쿼리 스트링을 통해 참조하실 수 있고요 이 쿼리 스트링 문자열을 파싱한 쿼리릭 타입의 객체입니다
사전처럼 각 쿼리 파라미터를 참조하실 수 있습니다
쿼리 스트링은 요청 주소 뒤에 붙어 있는 문자열이기에 get 요청이 아닌 post 요청 등에서도 이 값이 있을 수 있습니다.
그러니 request. 대문자 get 속성은 get 요청 뿐만 아니라 다른 요청에서도 값이 있을 수 있는 거죠.
두 번째, 세 번째로 post 속성과 files 속성입니다.
둘 다 요청 바디 로 데이터를 파싱한 사전이며, 각각 데이터 사전과 파일 내역 사전을 담고 있습니다. 
둘 다 Post 요청에서만 요청 컨텐츠 타입을 확인해서, Post 속성에서는 Multipart FormData와 URL-Encoded 타입에서만 파싱을 시도하고요.
Files 속성은 Multipart FormData 타입에서만 파싱을 시도합니다.
JSON 요청의 경우에는 컨텐츠 타입이 Application JSON인데요.
이 경우에는 Post 속성에서 파싱을 시도하진 않습니다.
뷰 함수는 호출되기 전에 middleware를 모두 거치고 나서야 호출이 됩니다.
middleware를 거치면서 HTTP request 객체의 커스텀 속성이 추가될 수 있습니다.
Session 앱의 middleware에서는 Session 속성을 추가합니다.
Session은 서버단에서 저장 관리되어지는 상태값이며, 브라우저와 사용자별로 다른 Session을 가집니다.
로그인은 세션을 통해 관리되는데요.
같은 유저명으로 로그인하더라도 크롬과 엣지 브라우저에 각각 로그인을 해야 하죠.
세션이 브라우저별로 따로 관리되고 있고, 브라우저를 넘어 공유할 수 없다는 뜻입니다.
장고에서 Session 처리는 SessionStore 클래스를 통해 추상화가 되어 있으며, Session 속성을 통해 Session 처리를 편리하게 하실 수 있습니다.
Settings 설정 변경만으로 SessionStore를 변경하실 수 있고요.
장고의 Default SessionStore는 데이터베이스이며, 보다 빠른 Session 저장 및 로딩을 원하신다면 Redis를 SessionStore로 쓰실 수도 있습니다.
Auth 앱의 미들웨어에서는 유저 속성을 추가합니다.
레이지하게, 게으르게 동작하며, 유저 속성에 접근할 때 관련 유저 인스턴스를 생성하는데요.
로그인할 때 세션에 로그인 유저의 기본 키를 저장하고요.
매 요청마다 유저 속성 접근 시에 세션에 저장된 유저의 기본 키를 가져와서 관련 유저 모델 인스턴스를 조회하고 반환합니다.
세션에 저장된 로그인 유저 키가 없다면 로그아웃 상황인 것이고요.
이때에는 모델 클래스가 아닌, anonymous user라는 일반 파이썬 클래스의 인스턴스를 반환합니다.
로그인 여부에 따라 request.user 속성이 모델 인스턴스이기도 하고, 파이썬 클래스의 인스턴스이기도 하죠.
모델 간의 관계 지정에서는 모델 인스턴스가 꼭 필요한데요.
로그아웃 상황에서 request.user 속성은 UserModel 인스턴스가 아니니까 UserModel 인스턴스에서 지원하는 여러 모델 관계나 커스텀 속성이나 메서드를 지원하지 않습니다.  단지 기본 UserModel 클래스의 속성만 로그아웃 상황에 맞춰 지원할 뿐입니다. UserModel 클래스에서는 isUnderbarAuthenticated 속성 값은 항상 참이고요, Anonymous User 클래스에서는 항상 거짓입니다.
뷰와 템플릿에서는 user.isUnderbarAuthenticated 속성으로 인증 여부를 확인합니다.
HTTP에서 하나의 키에 여러 값을 담을 수 있는 특징을 Multi-Value
Parameters 또는 Multi-Value Fields라고 합니다.
이러한 특징은 주로 Query 문자율이나 HTTP 헤더, 그리고 PostData 등에서 볼
수 있습니다. 파이썬 사전에서는 같은 키에 다른 값을 여러 담을 수 없는데요.
Multi-Value Parameters를 지원하기 위해, 장고에서는 사전을 확장한
Multi-Value Dict 타입을 지원하고, Request.Files 속성에 사용되고 있고요. 쿼리 스트링 지원을 위해 멀티밸류 딕 타입을 확장한 코디 딕 타입을 지원하고
있고, request.get 속성과 request.post 속성에 사용되고 있죠.
request의 get, post, files 속성 모두 하나의 키에 다수의 값을 담을 수 있습니다. 
사전에서 하나의 키에 리스트를 담는 것과는 다릅니다.
요청 주소의 코디 파라메터로서 같은 네임이 3개가 설정된 상황입니다.
사전처럼 네임 키로 조회하면 마지막 단일 값이 조회되죠.
여러 값을 담은 사전이었다면 리스트를 반환할 수밖에 없었을 것입니다.
어떤 키가 여러 값이 담겨져 있다는 것을 알고 있다면 getList 메서드를 통해 리스트 형태로 값을 조회할 수 있습니다.
getList는 Multi-Value 딕에서 확장한 메서드입니다.
request.getList 메서드의 유용한 예로써 사진 100장을 한 번에 업로드하는 상황이 있습니다.
사진 100장을 업로드하기 위해 이렇게 클라이언트 단에서는 네임 속성으로 포토 1부터 포토 100까지 이름을 지정해서 파일을 업로드하고 서버 단에서도 각 이름마다 하나씩 조회해서
파일을 처리할 수도 있겠죠
하지만 이렇게 같은 네임으로도 사진을 업로드할 수 있습니다
그럼 서버에서는 하나의 이름으로 Get List를 통해 업로드된 파일 리스트를 조회할 수 있습니다 
그런데 사진 업로드 버튼을 100번 클릭해서 사진을 100번 선택해야 하네요
인풋 타입 파일 요소에서는 멀티플 속성을 지원합니다
멀티플 속성을 지정하면 파일 선택 대화 상자에서 여러 파일을 선택할 수 있습니다
사진 100장을 한 번에 선택해서 업로드할 수 있습니다
그럼 같은 네임으로 서버에 업로드가 될 것이고요 서버에서는 Get List를 통해 한 번에
업로드된 파일 리스트를 참조할 수 있습니다