이번에는 빈 마이그레이션 파일을 생성하고 그 안에 runpython operation을
활용해서 코드 모델에 대한 데이터 마이그레이션을 수행해 보겠습니다.
새로운 장고 앱 shop 앱을 하나 생성하고요.
settings에 installed apps 리스트에 등록합니다.
그리고 shop 앱에 ZipCode 모델을 정의한 후 make migrations 명령을
통해 ZipCode 모델에 대한 마이그레이션 파일을 생성합니다.
이어서 make migrations --empty 명령으로 빈 마이그레이션 파일을
생성하는데, name 인자로 마이그레이션 파일명도 지정해 줍니다.
그럼 아래와 같이 operations 내역이 빈 리스트로 빈 마이그레이션 파일이 생성이
되고요. 의존성 정보에는 샵 앱의 0001 이니셜 파일에 의존성이 있다고 명시되어
있습니다. 샵 앱의 0001 이니셜 마이그레이션 수행 후에 이 마이그레이션이 수행될 수
있습니다. 이 마이그레이션 파일을 수정해서 RUN Python Operation을 적용하고 정방향
실행에서는 우편번호 데이터를 추가하고 역방향 실행에서는 우편번호 데이터를 삭제하도록 구성을
해보겠습니다 슬라이드 하단에 안내된 웹페이지를 먼저 열어뒀습니다
파이썬 manage.py startapp shop 명령을 통해서 샵 앱을 생성을 하겠는데요 오류가 납니다
폴더 구조를 보시면 앞선 명령에서 샵이라는 폴더가 자동 생성이 되었기 때문인데요 이 폴더가
있기 때문에 샵 앱을 생성을 못하고 있는 거죠
그래서 샵 폴더를 일단 삭제를 하고요 다시 명령을 줘서 샵 앱을 생성을 하겠습니다
그리고 Settings 파일에서 InstallDepth에다가 샵 앱을 추가하고요 그리고
앞서서 명령 내렸던 파이썬 집코드 샘플 다운로드 명령을 한 번 더 수행하시면 이렇게 수행이
되었고 서울특별시점.txt 파일도 샵 앱 안에 이렇게 생성이 되었음을 확인하실 수 있습니다
샵 앱의 모델 파일 내에서 code라는 모델, class를 정의하고 code는
CharField에 maxLength 6, name은 CharField에
maxLength 100으로 이렇게 저장하겠습니다
그리고 terminal 를 띄우신 다음에 make migrations 샵 명령을 통해서 샵
앱에 0001 마이그레이션 파일을 이렇게 생성을 해 주시고요
그리고 empty, name은 insert_zip_code_data라고 이렇게 줘서 빔
마이그레이션 파일도 생성을 해 주시겠습니다
그러면 샵 앱에 마이그레이션스에 1번 마이그레이션은 create 모델을 통해서 데이터베이스
테이블을 만드는 operation이고, 0002는 샵 앱의 0001에 대해서 의존성이
있고, operation은 현재 비워져 있습니다.
이 operation을 run_python operation을 통해서 채워보겠습니다.
안내해드린 이 코드를 그대로 복사해서 붙여넣으셔도 되겠고요.
근데 저는 지금 하나씩 이 코드를 채워나가보도록 하겠습니다.
operations에서 여기 list에다가 migrations에 runpython이라는 이
operation을 추가를 하도록 하겠고요 인자로 두 개를 받습니다
첫 번째 인자는 이 migration이 정방향 실행일 때 호출된 함수 두 번째 인자는
역방향 실행일 때 호출된 함수를 지정합니다
정방향 실행일 때는 addZipCodeData라는 함수를 실행하도록 할 것이고요 역방향
실행에서는 removeZipCodeData라는 함수를 실행하도록 하겠습니다
이 함수는 상단에다가 이렇게 정의를 해주겠고요 run_python에 지정된 함수는 인자를 항상 두
개를 받습니다 첫 번째는 apps, 두 번째는 schema editor라고 합니다
ZipCode 모델 클래스를 import를 해야 되는데 ZipCode 모델 클래스
import를 위해서 이 위에서 from shop의 models에 ZipCode라고 쓰실
수 있겠지만 이렇게 쓰시면 마이그레이션은 모델에 대한 히스토리를 관리하잖아요
위와 같이 이렇게 임포트하시면 마이그레이션이 최신 ZipCode 모델 코드를 가져오는 건데
이렇게 하시면 안되고 아래에서 apps.getModel 이렇게 가져오시면 마이그레이션이
적용되는 시트 이렇게 가져오셔야만 하고요 remove에서도 똑같이 이렇게 가져옵니다
remove 함수에서는 삭제니까 그냥 ZipCode.objects.all 전체에 대해서
이렇게 삭제 추가에 대한 부분은 코드를 복사할게요
위에다가 임포트만 날리고 붙여넣겠습니다 getCodeEndNameFromCSV라는 함수를
정의한 거죠
addZipCode 데이터에서 이 부분의 코드로 복사할게요 붙여넣으십니다
소관로를 썼기 때문에 이 코드는 제너레이터 표현식이 됩니다
우리가 가져올 파일의 데이터가 아주 클 수 있어요 작게는 10MB, 많게는 수백MB의
텍스트 데이터인데 그런 데이터를 리스트로 변환하시면 한 방에 메모리에 다 올리기 때문에
메모리 소모가 불필요하게 많아집니다
그때는 파이썬의 제네레이터를 활용하시면 메모리를 엄청 아껴서 아껴서 효율적으로 그리고
빠르게 작업을 수행을 하실 수 있습니다.
여기를 대관로도 쓰시면 안 돼요.
대관로 쓰시면 리스트 컴프레이션 문법이죠.
리스트 컴프레이션 문법을 쓰시면 아무리 이 getCodeEndNameFromCSV라는
함수에서 이렇게 제네레이터로 처리해도 받는 측에서 리스트로 다 써버리면 안 됩니다.
받는 측에서도 이렇게 제네레이터 표현식을 써서 받으시면 이 코드를 수행했을 때는 아직 이
파일 경로에서 파일을 읽지 않은 상황이 되겠습니다.
bulk create 메서드에 list나 generator 객체를 지정할 수 있습니다.
bulk create에서는 첫 번째 인자의 값을 list로 모두 변환한 뒤에 배치 사이즈에
지정한 크기만큼 인서트 코디를 모아서 실행해 줍니다.
앞에서 메모리 효율성을 높이려고 generator 표현식을 썼는데 bulk create 내부에서
인서트 코디 전에 한 번에 리스트로 변환을 해버리니 그 의미가 좀 없어졌네요
하지만 배치 사이즈 단위로 인서트 코디를 모아서 실행하니 데이터베이스 서버의 부하를 줄이고
전체 실행 시간을 단축시킬 수 있습니다 터미널을 띄우셔서
python manage.py show migrations에 sharp 명령을 내리시면
현재 1번 마이그레이션과 2번 마이그레이션이 미적용이죠.
이 상황에서 python manage.py migrate 샵의 0001이라고 하시면 1번까지만
수행됩니다.
1번까지죠. 1번인데 만약 1번을 롤백하고 싶다 하시면 이렇게 제도하시면 1번이
un-offline, 즉, 취소된 상황이죠.
롤백된 상황이 되겠습니다.
다시 show migrations 해보시면 둘 다 미적용 상황이 되는 거고요.
migrate에 인자 없이 실행하시면 1과 2가 동시에 수행이 됩니다.
동시에 수행이 되었어요.
2번이 수행이 되었다는 것은 데이터 마이그레이션이 수행이 되었다는 거고, 이렇게 장고 셀을
구동하신 다음에 ZipCode에 object.all.count에 보시면 현재
데이터베이스에는 4999개의 데이터가 저장이 되어 있고요 그리고 파이참에서 데이터베이스를
여신 다음에 여기에 샵에 ZipCode 테이블이 있네요
더블클릭해 보시면 이렇게 데이터 마이그레이션이 잘 수행되었음을 확인하실 수 있습니다
앞선 슬라이드에 bulk create method 호출에서는 bulk create
method 내부에서 인자의 ZipCode 리스트 제너레이터를 리스트로 일괄 변환하기
때문에 원본 데이터의 크기가 아주 클 경우 메모리 효율성이 낮아집니다.
이를 개선하여 bulk create 메서드의 배치 사이즈 인자를 활용하지 않고, 배치
create 메서드를 호출하기 전에 getChunk 함수를 통해 지정 chunk
사이즈만큼만 값을 꺼내어 bulk create 메서드를 호출하여 처리하면 메모리 효율성을
높일 수 있습니다.
chunk는 연속적인 데이터의 일부를 말합니다.
getChunk 함수는 인자의 iterator에서 chunk 사이즈만큼 값을 순차적으로
꺼내어 yield하는 generator 함수입니다.
인자가 iterator가 아니라면 iterator로 변환하고요.
iterator는 값을 순차적으로 하나씩 꺼낼 수만 있을 뿐, 값을 꺼내기 전에는 남은
값이 있는지 알 수 없습니다.
for 반복문에서 값을 하나 꺼낼 때 남은 값이 없다면 stop iteration 예외가
발생하며 반복문이 종료됩니다.
addZipCode 데이터 함수에서 bulk create method 호출 전에
getChunk 함수 호출을 통해 chunk 사이즈만큼 순차적으로 읽어낸 chunk를
받아서 bulk create method를 배치 사이즈 인자 없이 호출해 주세요.
소스 파일을 저장하시고 python manage.py migrate sharp 0001
명령을 통해 0002 마이그레이션을 롤백하시고,
python manage.py migrate sharp 0002 명령을 수행해서 0002
마이그레이션을 적용해주세요.
그럼 스크린샷에서처럼 최대 1000개 단위로 csv 파일로부터 데이터를 순차적으로 읽어와서
인서트 쿼리를 모아서 보냄을 확인하실 수 있습니다.