안녕하세요. 이번 시간에는 마이그레이션을 활용한 데이터베이스 스키마 관리입니다.
장고에서 모델의 필드는 데이터베이스 테이블의 컬럼과 대응됩니다.
모델을 통해서 SQL Query가 생성되는데요.
모델과 데이터베이스 스키마가 일치하지 않으면 SQL Query 실행 시에 오류가 발생합니다. 
포스트 모델에 title과 content 필드만 있다고 가정해 봅시다.
생성되는 SQL 코드에도 이 두 컬럼이 포함이 됩니다.
예제 코드를 실행했을 때 operational error 예외가 발생한다면 모델과
데이터베이스 스키마가 서로 맞지 않을 확률이 높습니다.
오류 메시지를 읽어보니, BlogPost 테이블에 content 컬럼이 없다고 하네요.
실제 데이터베이스 테이블 스키마를 확인해보면, 이렇게 컨텐츠 컬럼이 누락되었을 가능성이 99%입니다.
모델과 일치하게 데이터베이스 스키마를 수정해야 합니다.
또 다른 가능성은 Settings의 DATABASES 설정에서 잘못된 데이터베이스 설정으로
인해 다른 데이터베이스를 참조하고 있는 경우입니다
이 경우 데이터베이스 설정을 확인하여 올바른 데이터베이스를 참조하도록 수정해야 되고요
마지막 가능성으로 장고 서버가 재시작되지 않아서 소스코드 최신 내역으로 서버가 동작하지
않았을 경우입니다 실 서비스 서버에서는 소스코드 업데이트 후에 PD와 장고 서버 프로세스를
재시작을 해주세요
앞서 언급된 Operational Error는 장고 모델을 사용하기 때문에 발생하는 것이
아니라 데이터베이스를 사용하는 모든 애플리케이션에서 만날 수 있는 오류입니다
어떤 애플리케이션이든 데이터베이스에 SQL 쿼리를 보낼 때에는 항상 데이터베이스의 현재
스키마와 일치하게 SQL 쿼리를 작성해야 합니다.
만약 쿼리가 데이터베이스 스키마와 맞지 않을 경우 데이터베이스 오류가 발생할 수 있습니다.
데이터베이스 스키마는 고정된 것이 아니라 프로그램의 코드가 발전하고 변화됨에 따라
지속적으로 업데이트 되고 수정됩니다.
따라서 데이터베이스 스키마와 애플리케이션, 코드에서 참조하는 스키마를 맞춰주는 것이
중요합니다 처음으로 포스트 모델을 생성했습니다
그러면 이 내역 그대로 데이터베이스에 반영을 하려면 이렇게 Create Table, SQL
Query를 직접 작성을 하고요 해당 데이터베이스에 가서 실행을 해줘야 됩니다
그리고 서비스를 운영하다가 두 번째 변경이 생겼습니다
createdAppField와 updatedAppField를 추가를 해야 됩니다
이때에도 모델을 변경하시고 나서 데이터베이스 테이블에도 반영하기 위해서 이렇게 코드를를
작성해서 데이터베이스에서 직접 수행을 해주셔야 됩니다
그리고 또 새로운 모델의 변경이 생겼습니다
새로운 모델 태그 모델을 만들고 Post 모델과 Many-to-Many 관계로 서로
엮었어요 이 내역에 대해서도 데이터베이스 테이블에 동일하게 반영을 해주기 위해서 이렇게
태그와 태그를 통해서 데이터베이스에서 직접 수행도 해줍니다
그리고 네 번째 변경으로 포스트 모델에서 컨텐트 필드를 만약 제거를 해야 되는 상황이
생기면 우리는 포스트 모델에서 그 컨텐트 필드만 지우는 거예요
지우는 걸로 끝이고 이를 데이터베이스에 반영하기 위해서는 이렇게 alter table
post drop column content라는 코디를 작성해서 이 역시 데이터베이스에서
직접 수행을 해줘야 합니다
지금 작성한 코디는 PostgreSQL 기준의 코드고요 만약 데이터베이스의 종류가 바뀌면
그 데이터베이스에서 지원하는 SQL 언어로 동일한 동작의 코디를 만들어서 수행을 해주셔야
되는 거죠 만약 오라클의 경우는 이렇게 쿼리를 생성해 주셔야 되고 마이크로소프트 SQL
서버도 쿼리가 조금씩 다릅니다
이렇게 쿼리를 생성해서 수행을 해주셔야 합니다
데이터베이스 시스템마다 사용되는 SQL 쿼리는 서로 다를 수 있습니다
이는 각 데이터베이스가 가진 고유의 기능과 문법 때문이고요
스키마 변경 내역을 추적하고 다양한 데이터베이스 유형에 맞춰 적절한 SQL 쿼리를 작성하고
실행하는 것은 상당히 복잡하고 어려운 작업입니다.
특히 SQL 쿼리에 대한 히스토리를 수동으로 관리하는 것은 매우 번거롭고 오류가 발생하기
쉬운 일입니다..
이러한 복잡성을 관리하기 위해 장고에서는 마이그레이션 기능을 제공해줍니다.
모델의 변경을 추적하고 서로 다른 데이터베이스 시스템 간의 쿼리 차이를 자동으로 해결하며
필요한 SQL 쿼리를 자동 생성 및 실행할 수 있습니다.
이를 통해 개발자는 데이터베이스 관리의 복잡성을 크게 줄일 수 있습니다.
포스트 모델 클래스를 처음 만들었습니다
그러면 python-manage-py make-migrations-blog라는 명령을 한
번만 내려 주시면요 블로그 앱 디렉토리 밑에 migrations 디렉토리 밑에
0001.initial.py라는 마이그레이션 파일이 자동으로 생성이 됩니다
금방 생성된 마이그레이션 파일을 열어 보시면 이런 파이썬 코드가 자동 생성이 되었고 이
마이그레이션 파일이 수행이 되면 데이터베이스의 테이블이 생성이 됩니다
우린 SQL 코드를 작성하지 않았어요 그러면
어떤 SQL로 수행이 되는지 확인을 해보려면 파이썬 맨지 SQL Migrate
Blog 0001 이니셜 명령으로 현재 Settings.DATABASES에 설정된
데이터베이스 엔진에 맞춰 수행된 SQL을 확인할 수 있습니다
즉, Settings에 SQLite 데이터베이스로 설정되어 있으면 SQLite 기준으로 SQL이
작성이 되고요 MySQL이면 MySQL SQL, Foursquare SQL이면
Foursquare SQL, Oracle이면 Oracle SQL Server면 SQL
Server 기준으로 자동으로 생성이 됩니다
그리고 포스트 모델 클래스에 created의 필드를 추가했습니다
저장하시고 나서 또 파이썬 매니지파이 make migrations 명령을 내려보시면
이번에는 블로그 밑에 migrations 밑에 0002 그리고 이미의 이름으로 파일명이
주어지고 마이그레이션 파일이 생성이 됩니다
이 마이그레이션 파일에는 created의 필드를 추가하는 마이그레이션 내역이 파이썬 코드로
작성이 되어 있어요
아직 데이터베이스에 적용한 건 아닙니다
세 번째로 태그 모델을 추가로 만들고 퍼스트 모델 클래스에 태그 모델에 대한
many-to-many 관계를 추가했습니다
블로그 앱 모델에 변화가 생긴 거죠
변화가 생겼으면 이를 데이터베이스에 반영하기 위해서 python-manage-py
make-migrations-blog라는 명령을 내려줍니다
그러면 블로그 밑에, 마이그레이션스 밑에 이번에는 0003.py라는 파일이 생성이 돼요
태그 란 이름에 데이터베이스 테이블도 생성해주고 포스트 모델과의 many-to-many
관계를 저장하는 추가 테이블도 생성을 해주는 마이그레이션 파일이 있는 거예요
네 번째로 포스트 모델에서 컨텐트 필드를 제거했습니다
우리는 모델 클래스에서 컨텐트 필드 한 줄만 날리는 거예요
그냥 삭제하시는 거죠
이 역시 모델에 변화가 발생한 거니까 파이썬 매니지 파일
make-migrations-blog 명령을 내려주시면 이 변화가 데이터베이스에 반영되기
위한 마이그레이션 파일을 또 생성을 해줍니다
이 파일명은 블로그 밑에 마이그레이션스 밑에 0004.py가 되는 거죠
이렇게 4개의 마이그레이션 파일을 생성을 했고요 데이터베이스로 반영을 하기 위해서는
python manage.py migrate blog라는 명령을 내려주시면 미적용
마이그레이션 파일부터 순차적으로 해당 마이그레이션을 수행해서 데이터베이스에 반영이 되게
됩니다 장고 앱 초기에 빈 모델 파일이 있고, 빈 데이터베이스가 있습니다.
새로운 모델을 추가한 모델 변경 내역이 발생했습니다.
데이터베이스로의 반영을 위해 make migrations AppName 명령을 수행하시면,
0001 Migration 파일이 생성됩니다.
생성된 마이그레이션 파일에서 어떤 SQL 쿼리로 수행되는지 확인을 하려면 SQL
Migrate AppName 명령을 수행합니다 데이터베이스 엔진 종류에 맞춰 SQL이
다르게 생성되고요 수행되는 스키마 변경 SQL을 확인함으로써 운영하시는 데이터베이스에 어느
정도의 부하가 걸릴지를 예측할 수 있습니다.
마이그레이션 파일 확인이 다 되었다면 migrate AppName 명령 혹은 migrate AppName
0001 명령으로 앱 네임 앱의 0001 마이그레이션까지 데이터베이스에 반영합니다.
각 마이그레이션 파일은 의존성 설정에 의해서 실행 순서가 있습니다
파일명으로 실행 순서가 결정되는 것이 아닙니다
마이그레이션 소스 파일 안에 의존성이 명시되어 있으며 파일명은 단순히 파일 목록에서
순서대로 보여주기 위함일 뿐 실행 순서에는 영향을 주지 않습니다
migrate AppName 명령은 해당 장고 앱 안에서 미적용 마이그레이션 파일부터 마지막
마이그레이션까지 순차적으로 실행합니다.
마이그레이트 앱 네임 띄우고 마이그레이션 파일명 명령은 해당 장고 앱 안에서 미적용
마이그레이션 파일부터 지정한 마이그레이션까지만 순차적으로 실행합니다.
만약 미적용 마이그레이션이 10번까지 있을 때 migrate AppName 0005 명령을
내리시면 1번 마이그레이션부터 2번, 3번, 4번, 5번까지만 순차적으로 실행합니다.
두 번째 모델 변경 내역이 발생하고 make migrations 명령으로 새로운
마이그레이션 파일을 만들고 SQL Migrate 명령으로 수행될 SQL 내역을 확인합니다
미적용 Migration 파일에 요구사항이 충분히 담기지 못했거나 오류가 있다면 해당
Migration 파일을 삭제하시고 Make Migrations 명령으로 다시 생성하셔도
됩니다 데이터베이스에 적용한 migrations 파일은 절대 삭제해서는 안 됩니다
세 번째 모델 변경 내역이 발생하고 동일하게 세 번째 Migration 파일을 생성하고
데이터베이스까지 반영했습니다
3번 마이그레이션 적용내역을 롤백 할 수도 있습니다.
장고 마이그레이션은 롤백을 지원합니다.
3번 롤백을 위해서 python manage.py, migrate, mname, 그리고
추가 인자로 직접 마이그레이션 파일명인 0002를 지정합니다.
2번 마이그레이션이 마지막 상태가 되도록 마이그레이션이 동작해서 3번 마이그레이션에 대한
롤백이 수행됩니다.
만약 현재 상태가 1번까지만 적용된 상태라면 같은 명령을 수행했을 때 2번 상태가 마지막
상태가 되도록 0002 마이그레이션이 적용될 것입니다.
3번 마이그레이션이 모델명, 필드명 변경이었죠.
롤백하면 모델 필드명을 원복합니다.
테이블을 삭제하는 마이그레이션에 대한 롤백은 테이블 재생성이고요.
롤백은 반대되는 SQL 코디를 실행할 뿐 데이터까지 복원해 주진 않습니다.
데이터는 백업을 자주 하시어 직접 해주셔야 합니다.
python manage.py migrate appname 제도 명령을 실행하시면 현재
적용된 마이그레이션에서부터 1번 마이그레이션까지 역순으로 롤백이 적용되어 해당 장고 앱의
모든 테이블이 삭제될 것입니다.
마이그레이션 오퍼레이션은 크게 세 가지 분류로 나눌 수 있습니다
첫 번째로 스키마 오퍼레이션입니다
모델 필드에 변경을 가한 후에 Make Migrations 명령을 실행하면 새로운
마이그레이션 파일이 생성이 되고 모델 변경 내역을 데이터베이스에 반영하기 위한 다양한
스키마 오퍼레이션들이 자동으로 지정됩니다
Schema Operation은 테이블 생성을 위한 Create과 테이블 삭제를 위한
Delete, 테이블명 변경을 위한 Rename 모델이 있으며, 이외에도
Column, 제약조건, Index 등의 변경을 지원하는 다양한 Schema
Operations들이 지원됩니다.
두 번째로, Learn SQL Operations이 지원됩니다.
Custom SQL 문자열을 수행할 수 있는 강력한 도구이지만, 잘못 사용하면
데이터베이스와 모델 상태 동기화가 틀어질 수 있습니다.
세 번째로, run-python operation이 지원됩니다.
지정 파이썬 함수를 수행하고요.
어떤 작업이든 수행할 수 있지만, 마이그레이션 과정에서 수행되기에 데이터 마이그레이션 작업
시에 유용합니다.
예를 들어, 외부 API나 CSV 파일로부터 우편번호 초기 데이터 넣기가 있겠습니다.
각 오퍼레이션들은 정방향, 역방향 동작을 지정할 수 있습니다.
스키마 오플레이션에서는 Create 모델의 정방향 동작은 테이블 생성이며, 역방향 동작은
테이블 삭제입니다.
Delete 모델의 정방향 동작은 테이블 삭제이며, 역방향 동작은 테이블 생성입니다.
마이그레이션은 정해진 마이그레이션을 순차적으로 수행할 뿐 데이터를 복원해 주진 않습니다.
데이터 복원이 필요하다면 항상 백업해 주셔야 합니다.
대표적인 마이그레이션 관련 명령을 살펴보겠습니다
그 첫 번째로 makemigrations 명령이 되겠고요 모델의 변경 사항을 감지하여
새로운 마이그레이션 파일을 생성을 해주고요
Make Migrations 명령으로 생성된 마이그레이션 파일이 실제 어떤 SQL로 수행이
되는지 확인하기 위해서 sqlmigrate 명령을 통해서 확인하실 수 있고요 인자로 앱
이름과 마이그레이션 이름을 지정합니다
이렇게 지정하시면 정방향에 대한 SQL 내역을 살펴보실 수 있고요 추가 인자로 백워즈
인자를 지정하시면 역방향 동작 시에 수행되는 SQL 내역을 살펴보실 수 있습니다
마이그레이션 파일 확인이 끝났다면 마이그레이트 명령을 통해서 데이터베이스에 적용을 하실 수
있어요 마이그레이션 파일을 적용할 때에 각 마이그레이션을 한 개씩 적용하실 수도 있겠고요
미적용 파일부터 최신 마이그레이션 파일까지 순차적으로 한 번에 다 수행을 하실 수도
있습니다 네 번째 명령으로 Show Migrations 명령으로 현재
바라보고 있는 데이터베이스에 대해서 몇 번 마이그레이션 파일까지 적용이 되었는지, 적용
현황을 확인할 수 있는 명령인 Show Migrations 명령이 있겠고요.
서비스를 개발하다 보면 여러 마이그레이션 파일이 생성이 되는데, 스쿨쉽 마이그레이션 명령을
통해서 여러 개의 마이그레이션 파일을 하나로 합치실 수 있습니다.


---

1. 장고 모델과 데이터베이스 스키마의 관계
장고의 모델은 데이터베이스의 테이블과 1:1 대응됩니다.
모델의 필드는 데이터베이스 테이블의 컬럼이 되고, 이 필드들은 SQL 쿼리를 통해 테이블에 반영됩니다.
만약 모델과 데이터베이스의 스키마가 일치하지 않으면, OperationalError와 같은 오류가 발생할 수 있습니다. 이는 예를 들어, 모델에서 존재하는 필드가 데이터베이스 테이블에는 없는 경우 발생합니다.
2. 문제 해결 방법
스키마 수정: 모델과 데이터베이스 스키마를 일치시켜야 합니다.
데이터베이스 설정 확인: DATABASES 설정이 올바르게 되어 있는지 확인합니다.
서버 재시작: 소스 코드 업데이트 후 서버가 재시작되지 않으면 적용되지 않을 수 있습니다.
3. 수동 SQL 쿼리 작성과 그 복잡성
모델의 변경 사항을 수동으로 반영하려면, SQL 쿼리를 직접 작성하고 실행해야 합니다.
예를 들어, 필드를 추가하거나 제거할 때 ALTER TABLE 문을 작성하여 실행해야 합니다.
각 데이터베이스 시스템(MySQL, PostgreSQL 등)은 SQL 문법이 다르므로, 이를 신경 써야 합니다.
이러한 작업은 복잡하고 오류가 발생할 가능성이 있기 때문에, 장고는 마이그레이션 기능을 제공합니다.
4. 장고 마이그레이션 기능
장고의 마이그레이션은 모델 변경 사항을 데이터베이스에 자동으로 반영해주는 기능입니다. 이를 통해 SQL 쿼리 작성과 실행을 자동화하여 오류를 줄이고 관리 편의성을 높일 수 있습니다.
5. 마이그레이션 파일 생성
모델 변경 후: 모델을 수정하면 python manage.py makemigrations 명령어를 통해 마이그레이션 파일이 생성됩니다.
예: 0001_initial.py, 0002_add_field.py와 같은 파일이 생성됩니다.
SQL 확인: python manage.py sqlmigrate <앱이름> <마이그레이션파일> 명령어로 해당 마이그레이션이 실행될 SQL 쿼리를 확인할 수 있습니다.
마이그레이션 적용: python manage.py migrate 명령어로 마이그레이션을 데이터베이스에 적용합니다.
예: python manage.py migrate blog로 블로그 앱의 마이그레이션을 적용합니다.
6. 마이그레이션 파일의 관리
마이그레이션 파일은 순차적으로 실행됩니다. 각 마이그레이션 파일에는 이전 마이그레이션에 대한 의존성이 명시되어 있습니다.
마이그레이션 파일이 생성된 후에는 SQL 쿼리나 모델을 수정할 수 있습니다. 만약 문제가 생기면 마이그레이션 파일을 삭제하고 다시 생성할 수도 있습니다.
롤백: 마이그레이션은 롤백이 가능하며, 이전 상태로 되돌릴 수 있습니다. 예를 들어 python manage.py migrate blog 0002로 특정 마이그레이션을 되돌릴 수 있습니다.
7. 마이그레이션 종류 및 오퍼레이션
마이그레이션 오퍼레이션은 크게 3가지로 분류됩니다:

스키마 오퍼레이션(Schema Operations):
테이블 생성, 삭제, 컬럼 추가/제거 등.
예: Create, Delete, Rename, AddField, RemoveField.
Custom SQL 오퍼레이션:
RunSQL을 통해 커스텀 SQL 문자열을 실행할 수 있습니다. 데이터베이스에 직접 쿼리를 실행하고 싶을 때 사용됩니다.
Python 오퍼레이션(run-python):
마이그레이션 과정 중에 파이썬 함수를 실행할 수 있습니다. 주로 데이터 마이그레이션에 사용됩니다.
8. 주요 마이그레이션 명령어
makemigrations: 모델의 변경 사항을 감지하여 마이그레이션 파일을 생성합니다.
sqlmigrate: 마이그레이션 파일에 의해 실행될 SQL 쿼리를 확인합니다.
migrate: 마이그레이션을 데이터베이스에 반영합니다. 이 명령은 마이그레이션을 한 번에 다 적용하거나, 특정 파일에 대해서만 적용할 수 있습니다.
showmigrations: 데이터베이스에 적용된 마이그레이션 현황을 확인합니다.
squashmigrations: 여러 개의 마이그레이션 파일을 하나로 합칠 수 있습니다.
9. 주의사항
마이그레이션은 데이터를 복원하지 않으므로, 데이터 백업을 반드시 해둬야 합니다.
마이그레이션을 롤백하면 데이터는 복원되지 않기 때문에, 이를 염두에 두고 사용해야 합니다.
