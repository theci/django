언제 Make Migrations 명령을 수행해야 할까요?
모델 필드에 ForbesName 인자를 추가한 경우, 이는 데이터베이스 스키마 변경이 없으니 Make Migrations 명령을 수행하지 않아도 된다고 생각하실 수도 있습니다.
하지만 그렇지 않습니다.
데이터베이스 스키마 변경이 없을 것이라 예상되더라도 모델 필드에 대한 모든 변경 내역에 대해서 Make Migrations 명령을 수행해야 합니다.
장고는 모든 모델 변경에 대해 마이그레이션 파일로 기록을 남겨 모델의 변경 사항을 추적하기 때문입니다. 
하지만 모델 클래스의 Custom Method는 변경 사항을 추적하지 않습니다. 
그러니 모델의 Custom Method에 변화가 있더라도 Make Migrations 명령을 수행할 필요는 없습니다.
song 모델 클래스에 name 필드만 정의되어 있는 상태에서 이미 마이그레이션이 완료된 상태라고 가정해 보겠습니다.
그 후에 name 필드에 verboseName 인자를 추가합니다.
verboseName은 데이터베이스 스키마와는 관련이 없지만 make migrations 명령을 내려보면 alterField 오프레이션이 적용된 새로운 마이그레이션 파일이 생성이 되고요. 
SQL migrate 명령으로 수행되는 SQL 내역을 확인해 보면 실제로 수행되는 내역은 없습니다.
migrate 명령에서는 인자로 대상 앱 이름과 대상 마이그레이션 파일명을 지정합니다.
마이그레이트 명령에서 마이그레이션 파일명 인자에 대해서 살펴보겠습니다.
블로그 앱의 마이그레이션 파일로 0001_initial.py, 0002_createfield.py, 0002.updatefield.py 이렇게 3개의 파일이 있습니다.
0002 번호의 파일이 2개가 있는 것은 두 명의 팀원이 같은 타이밍에 각자의 컴퓨터에서 마이그레이션 파일을 생성했다면 같은 번호의 마이그레이션 파일이 생성될 수도 있습니다.
이는 파일명일 뿐 마이그레이션 실행 순서를 결정하는 것은 아니기에 이 번호가 겹치더라도 상관없습니다.
마이그레이션 파일명은 확장자를 제외한 이름에 대해서 부분 매칭을 시도합니다
마이그레이션 파일명 인자로 000을 지정하면 마이그레이션 파일명이 000으로 시작하는 파일이 3개나 있기 때문에 한 개 매칭이 아니죠
그래서 커맨드 에러 오류가 발생하고요 마이그레이션 파일명 인자로 100을 지정하면 마이그레이션 파일명이 100으로 시작하는 파일이 없어서 커맨드 에러 오류가 발생합니다
0001을 지정하면 0001로 시작하는 파일이 1개가 있으니 명령이 수행되고요 0002를 지정하면 0002로 시작하는 파일이 2개 있으니 명령에 실패합니다
그 외에 파일명이 1개 매칭이 되는 이름을 지정하면 모두 명령이 성공합니다 모든 마이그레이션을 롤백하기 위해서는 제로를 지정하시면 됩니다
마이그레이션 적용 순서는 의존성, 트리에 의해서 결정됩니다.
혼자서 개발한다면 마이그레이션 의존 관계는 선형 구조가 됩니다.
하지만 팀 단위도 개발하고 각 팀원이 각자 맡은 기능에 대한 마이그레이션 파일을 각자 생성한다면 의존 관계는 트리 구조가 됩니다.
임의로 4개의 빈 마이그레이션 파일을 생성합니다.
순서대로 의존성이 지정이 될 텐데요.
마지막 네 번째 파일인 0006 마이그레이션 파일의 의존성을 수정해서 0004 마이그레이션의 의존성을 갖도록 수정하여 마이그레이션 충돌 상황을 만들어 주겠습니다.
그럼 현재 마이그레이션 의존성 그래프에서 끝 노드가 0005와 0006 마이그레이션으로 2개가 됩니다.
python-manage-by-migrate-sharp 명령을 수행하면 마이그레이션 충돌이 발생해서 커맨드 에러가 발생하고요.
이는 마이그레이션의 마지막 상태가 0005 마이그레이션이 될지, 0006 마이그레이션이 될지 결정할 수 없기 때문입니다.
끝 노드가 1개가 되도록 의존성을 수정을 해줘야 합니다.
Make Migrations Merge 명령으로 새로운 마이그레이션 파일을 하나 생성할
수도 있겠고요.
0006 마이그레이션이 0005 마이그레이션 다음에 수행되어도 문제가 없다는 판단이 들면,
0006의 의존성을 직접 수정해서 다음에 수행되도록 수정합니다
그러면 이 충돌 상황이 해결됩니다
make-migrations-sharp-empty 명령을 4번 수행해서 빈 마이그레이션
파일을 4개를 만들었습니다
3번 마이그레이션 파일은 2번 마이그레이션의 의존성이 있고요 4번은 3번의 의존성이 있고
5번은 4번의, 6번은 5번의 의존성이 있죠
그럼 6번 마이그레이션을 수정해서 4번 마이그레이션의 의존성이 있도록 고쳐볼게요
그럼 4번 마이그레이션 이름을 6번 마이그레이션의 의존성으로 이렇게 지정을 하겠습니다
터미널에서 show migrations 샵 명령을 내려보시면 3456이, 3456
마이그레이션이 미적용으로 나오고요 migrate 샵 명령을 내려보시면 이렇게 커맨드 에러가 발생합니다 오류
메시지를 읽어보면 마이그레이션 충돌이 감지가 되었고요 마이그레이션 그래프 상에서 끝 노드가 여러 개라는 거죠
그 끝 노드는 0005와 0006이 있다는 겁니다
이 상황을 해결하기 위해서 python manage.py makemigrations Merge 명령, 새로운 마이그레이션 파일을 생성한다는 거죠
이 명령을 수행하면 5번과 6번 뒤에 새로운 마이그레이션을 하나 더 두는 겁니다
이 상황을 해결하기 위해서 6번 마이그레이션이 5번 다음에 수행이 되어도 된다라는 판단이 들면 6번의 의존성을 수정해서 5로 고쳐주는 거죠
이렇게 고쳐주고 나서 다시 마이그레이트 해보시면 오류 없이 잘 수행이 됩니다.
퍼스트 모델에 새로운 필드 작성자 author 필드를 추가하고 migration을 수행하려 합니다. 
author 필드는 필수 필드입니다.
필수 필드는 blank나 null 옵션이 모두 거짓인 필드입니다.
반드시 값이 있어야 하는 필드인 거죠.
모든 모델 필드는 blank와 null 옵션을 지원하며 default로 거짓입니다.
작성자 author 필드를 추가하고 나서 make migrations blog 명령을 실행하시면 어떤 긴 메시지가 출력됩니다
반드시 값이 있어야 하는 필수 필드가 기존 테이블에 추가될 테니 필드가 추가될 때 기존 행에 대해서 필드 값으로 어떤 값을 채워 넣을지 묻는 상황입니다
필수 필드가 초기 모델 설계부터 반영이 되어 있다면 이 선택지를 볼 일이 거의 없을 것인데요 
하지만 필수 필드가 나중에 추가될 수도 있죠
Make Migrations 에서 출력되는 이 메시지를 읽어 보겠습니다 포스트 모델의 author field는 null을 허용하지도 않고 default 값도 지정이 되어 있지 않다고 하죠 
그래서 기존 행에 컬럼을 추가할 때에 추가하는 어떤 작업이 필요하다는 거거든요
두 가지 선택지 중에 하나를 선택할 수 있습니다.
1번은 기존 행의 채울 값을 파이썬 코드로 입력하겠다고요.
두 번째는 현재 Make Migrations 작업을 중단시키고 모델 코드를 변경하고 다시 Make Migrations를 수행하겠다는 그런 의미가 됩니다.
모델 코드를 수정할 때에 blank나 true나 혹은 모델 필드에 디폴트 값을 지정해 줄 수도 있겠습니다
그런데 이 작성자 필드에는 blank 지정, null 지정, default 지정이 다 맞지 않습니다 
새로운 포스팅을 생성할 때에는 항상 작성자가 있어야 되고요 그 작성자 정보를 항상 입력받아서 저장을 할 것입니다
그러면 2번 선택지는 맞지 않고요 1번 선택지를 이렇게 지정하고요 1 하고 엔터 치시면 어떤 값으로 채워 넣을지를 입력을 받습니다
author 작성자 필드는 외래 키거든요 외래 키는 외래 키 관계에 있는 다른 모델의 기본
키 값입니다 여기에 지정한 모델은 장고 기본에서 지원해주는 유저 모델이거든요.
유저 모델의 기본 키를 지정을 할 텐데, 장고 모델에서 default 기본 키는 숫자
1부터 1씩 자동 증가하는 오토필드입니다.
유저 모델의 기본 키도 오토필드입니다.
작성자 외래 키 값으로 유효한 값은 1 이상의 숫자 값이어야 합니다.
작성자 필드 추가 시에 기존 레코드의 작성자 필드에는 외래 키 값으로 1이 입력되도록 1을 지정하겠습니다.
이를 지정했기에 이 마이그레이션을 수행할 때 유저 모델에도 기본키가 1인 데이터가 있어야 합니다. 
없다면 외래키 제약사항이 위반되어 마이그레이션에 실패하게 됩니다.
이 마이그레이션이 성공적으로 수행되려면 반드시 지정한 기본키의 유저 레코드가 현재 프로젝트가 바라보고 있는 데이터베이스에 있어야 합니다
블로그의 모델 스파이에 post 모델에다가 이렇게 작성자 필드를 추가하겠습니다
그리고 from django.conf import settings는 장고 conf의 settings를 import하도록 합니다 
이제 파이썬 매니지파이 make migrations 블로그 명령을 내려보시면 현재 추가하려는 포스트 모델의 authorField에 대해서 어떤 값을 채워 넣을지 묻고 있습니다 
1번을 선택해서 일회성 값을 지정해 주겠고요 유저 모델에 대한 외래키로써 1을 입력하겠습니다
그러면 새로운 마이그레이션 파일이 생성이 되었고요
해당 파일을 열어보시면 포스트 모델에 authorField 외래키가 추가되고요 디폴트 값으로서 1이라는 값이 지정되어 있습니다 의존하는 모델은 User 모델이에요
그러면 User 모델에 PK가 1인 레코드가 현재 프로젝트에서 바라보고 있는 데이터베이스에
필이 있어야 합니다
현재 장고 프로젝트가 바라보고 있는 데이터베이스는 이 PostgreSQL 데이터베이스입니다
이 데이터베이스에서 auth__user라는 이 테이블이 현재 장고 프로젝트에서 기본 제공해주는 유저 모델에 대한 데이터베이스거든요
이걸 열어보시면 현재 기본 키가 1인 유저가 있습니다
우리가 예전에 create super user라는 명령으로 유저 하나를 생성했어요
지금 python manage.py migrate blog 명령을 내려보시면 이 명령이 성공을 합니다 
이 데이터가 있기 때문이고요 다시 방금 수행한 2번을 롤백하겠습니다
1로 지정해 주시면 2번이 다시 롤백되었고요 이 행을 삭제하겠습니다
delete 하시고, submit 하시면 삭제가 되었어요.
현재 블로그 앱에서는 2번 마이그레이션은 아직 수행하기 전입니다.
이제 다시 2번을 수행해 보겠습니다.
Auth User 테이블에 PK가 1인 데이터가 없죠?
현재 이렇게 오류가 발생합니다.
외래키 제약사항을 위반했기 때문에 새로운 외래키 컬럼을 추가할 때에 데이터베이스 에러가 발생한 것입니다.
그러면 제가 create superuser 명령으로 새로운 유저를 추가했습니다
새로 고침해보시면 이제 PK 2번이 있죠
그럼 현재 데이터베이스에서는 1번이 없습니다
그러니까 이 마이그레이션 파일이 동작하려면 있는 레코드를 참조할 수 있어야겠죠
이렇게 2로 고치고 다시 마이그레이트 블로그 해보시면 이렇게 외래키를 추가하는 마이그레이션이 잘 수행되었음을 확인하실 수 있습니다



이 내용은 Django에서 마이그레이션을 수행하는 과정과 마이그레이션 파일을 다룰 때 발생할 수 있는 여러 상황을 설명하는 것입니다. 주된 내용은 모델 필드 변경, 마이그레이션 충돌, 필수 필드 추가와 같은 실제 개발 시에 직면할 수 있는 문제들을 다루고 있습니다. 아래에 주요 내용을 정리하겠습니다.

1. Make Migrations 명령어 수행 시기
모델 필드 변경 시: 모델에 대한 변경은 데이터베이스 스키마에 영향을 미치지 않더라도 모든 변경 사항을 추적하기 위해 make migrations 명령을 수행해야 합니다. 예를 들어, 필드에 verbose_name 인자를 추가하거나, 필드를 수정하더라도 make migrations를 실행해야 합니다. 이는 Django가 모든 모델 변경 사항을 마이그레이션 파일에 기록하여 추적할 수 있도록 하기 위함입니다.
모델의 Custom Method 변경 시: 반면, 모델 클래스에 있는 커스텀 메서드의 변경은 데이터베이스 스키마에 영향을 주지 않으므로 make migrations를 수행할 필요는 없습니다.
2. 마이그레이션 파일의 충돌
마이그레이션 파일은 파일명에 숫자를 포함하지만, 이 숫자가 동일한 경우에도 충돌하지 않습니다. 예를 들어, 0002_create_field.py와 0002_update_field.py라는 두 개의 마이그레이션 파일이 있을 수 있지만, Django는 마이그레이션의 실행 순서를 파일명 자체로 결정하지 않고, 마이그레이션의 의존 관계를 통해 순서를 정합니다.
만약 서로 의존 관계가 엇갈린 마이그레이션 파일들이 존재한다면, 마이그레이션 충돌이 발생할 수 있습니다. 이럴 때는 python manage.py makemigrations --merge 명령을 통해 충돌을 해결하는 새로운 마이그레이션 파일을 생성할 수 있습니다.
또한, 마이그레이션 파일의 의존성을 수정하거나, 충돌을 해결하기 위해 수동으로 의존성을 지정하는 방법도 있습니다.
3. 필수 필드 추가 (ForeignKey와 같은 경우)
필수 필드 추가: 모델에 필수 필드를 추가할 때, 기존 레코드에 대해 필수 값이 없어 오류가 발생할 수 있습니다. 예를 들어, author 필드와 같은 외래 키 필드를 추가하는 경우, 해당 필드가 필수 필드(null이나 blank가 False)인 경우 기존 테이블의 모든 행에 대해 이 필드의 값을 채워야 합니다.
make migrations를 실행하면, 기존 레코드에 대해 새로운 필드의 값을 어떻게 채울지 묻는 메시지가 표시됩니다. 이때 두 가지 선택지가 있습니다:
파이썬 코드로 기본 값을 지정하여 기존 레코드의 해당 필드를 채우는 방법.
모델 코드를 수정하여 null=True, blank=True 등을 설정하거나, 기본값을 설정하여 문제를 해결하는 방법.
4. ForeignKey 필드 추가 시 주의 사항
ForeignKey 필드를 추가할 때는 해당 외래키가 참조하는 모델의 기본 키 값이 반드시 존재해야 합니다. 예를 들어, author 필드가 User 모델을 참조하는 외래 키라면, 기본 키가 1인 User 레코드가 있어야 합니다.
만약 기본 키가 1인 레코드가 없으면, 마이그레이션을 수행할 때 외래키 제약 조건에 의해 오류가 발생합니다. 이 경우, make migrations 명령 실행 시 1번 레코드로 채울 값을 묻는 메시지가 나오며, 이를 통해 외래 키 값으로 유효한 레코드를 지정할 수 있습니다.
5. 마이그레이션 과정
마이그레이션 파일을 생성한 후에는 migrate 명령을 통해 데이터베이스에 변경 사항을 적용합니다. 이 과정에서 외래 키 제약 조건이나 필수 필드가 추가되는 등의 경우, 기존 데이터베이스의 레코드를 어떻게 처리할지에 대한 선택지가 나타납니다.
유효한 외래 키 값이 없는 경우, 마이그레이션을 진행할 수 없으며, create superuser 명령 등을 통해 필요한 레코드를 추가하고, 마이그레이션을 다시 시도해야 합니다.
요약
모델 필드 변경 시 make migrations 명령을 수행해야 하며, 필드에 verbose_name을 추가하는 등의 변경도 마이그레이션을 생성해야 합니다.
모델의 커스텀 메서드 수정은 마이그레이션을 생성할 필요가 없습니다.
마이그레이션 파일이 충돌하면 makemigrations --merge 명령으로 해결할 수 있으며, 마이그레이션 의존성은 수동으로 수정할 수 있습니다.
필수 필드(예: ForeignKey)를 추가할 때는 기존 데이터에 대한 값 설정이 필요하며, 기본 키 값을 지정하여 외래 키를 참조할 수 있어야 합니다.
마이그레이션 중 오류가 발생하면, 오류 메시지에 따라 필요한 값을 지정하거나 모델을 수정하여 문제를 해결합니다.
