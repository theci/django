두 번째 사례로 유니크 필드를 추가할 때 필드 추가 시에 기존 레코드에 같은 값으로
필드가 추가되어 유니크 제약사항 위배로 인해 마이그레이션이 실패하는 케이스입니다.
유니크 필드를 추가하고 Make Migration 명령 시에 일회성 디폴트 값으로 빈
문자열을 지정했습니다.
이 값은 기존 모든 레코드에 동일하게 채워질 값입니다
그런데 동일한 값으로 채워진다는 것은 유니크 제약사항을 위배하는 것이죠
즉, 포스트 테이블에 데이터가 없으면 마이그레이션이 성공하지만 포스트 테이블에 데이터가
2개 이상 있을 경우 여러 레코드에 같은 문자열 슬러그 값이 지정되어 유니크 제약사항이
위배되고 마이그레이션이 실패합니다
데이터 상황에 따라 마이그레이션이 실패해서는 안 됩니다
블로그 앱의 Post 모델에서 SlugField를 models의 SlugField 타입으로
생성해 주겠고요 SlugField의 기본 MaxLength는 50입니다
Slug의 소스가 될 제목은 MaxLength를 100으로 지정했기 때문에 이 값보다 좀
크도록 120 정도로 지정하겠고요 AllowUnitCode 참을 넣어주겠고 유니크 제약
조건도 추가하겠습니다
이제 python manage.py make-migrations-blog 명령으로
마이그레이션을 생성하겠고요 포스트 모델에 대한 slug, non-null 필드를
생성하겠습니다
일회성 default 값을 지정하기 위해서 1을 입력하고요 slug 필드는 문자열
필드입니다 문자열 필드이기 때문에 빈 문자열을 일회성 default 값으로 지정하겠습니다
블로그 앱에 4번 마이그레이션 파일이 생성되었고요 방금 생성된 4번 마이그레이션 파일을
열어보시면 포스트 모델에 Slug 필드를 추가하고 추가되는 필드는 Slug 필드이며 이
필드가 추가될 때에 기존 레코드에는 빈 문자 열로 일관되게 모든 값이 채워집니다
그리고 유니크 제약 사항이 추가가 되죠
현재 데이터베이스에서 블로그 포스트 테이블 열어보면 저는 현재 데이터가 2개가 들어
있습니다 슬라이드 설명에서 설명드렸듯이 이 유니크 제약사항을 통해서 포스트 테이블에
데이터가 없거나 한 개가 있을 때는 slug 컬럼이 추가가 되면은 값이 중복이 안 되기
때문에 migration이 성공하는데 두 개 이상이 있다면은 migration에 실패합니다
저는 현재 두 개이기 때문에 migrate 명령이 실패하는 걸 보여 드릴게요 해 주시면은
현재 slug 필드에 대해서 값이 중복이 되었기 때문에 유니크 인덱스 생성에 실패했다고
이런 에러가 보여지고 있죠
한 개의 레코드를 삭제해 보겠습니다
delete하고 저장을 하고 나서 현재 한계죠
한계일 때 다시 해보면 이렇게 마이그레이션이 성공을 하고요 데이터 새로 고침을 해보면
이렇게 슬러그 컬럼에 빈 문자 이들이 들어있음을 확인하실 수 있습니다
이에 대한 첫 번째 해결책으로 Slug 필드를 Non-Unique 필드로 운영하는 것입니다
추천하는 방법입니다
추천하는 방법이고요 Slug를 쓰는 이유는 URL에서 사람이 읽을 수 있는 문자를 쓰기
위함이죠 그런데 Slug를 쓴다고 해서 리소스 식별의 Slug만 써야 하는 것은 아닙니다
슬러그로만 리소스를 식별하려면 슬러그 값이 유일해야 하죠.
URL에 PK와 슬러그를 같이 노출하고 리소스 식별에 PK 값을 같이 쓴다면 슬러그 값은
유일하지 않아도 됩니다.
그리고 기본키로 조회하는 것이 일반적으로 더 빠릅니다.
기본키가 URL에 노출되는 것이 싫다면 장고 해시 ID, 필드 라이브러리를 통해 해싱된
기본키 노출도 가능합니다.
해싱을 위한 비밀 키를 임의로 지정할 수 있기에 해싱된 값만으로 원본 기본 키 값을
유추하는 것은 어렵습니다 포스트 모델의 슬러그 필드에서 유일 참 인자를 제거하고 타이틀
필드로부터 슬러그 값을 변환하여 지정합니다
슬러그 값은 유일하지 않아도 되기에 기존에 같은 값이 있는지 체크하지 않아도 됩니다
make migrations 명령으로 마이그레이션 파일을 생성하고 슬러그 필드에 대한
일회성 디폴트 값으로 빈 문자열을 지정합니다.
non-unique 설정이기에 값 중복이 허용되기 때문에 이대로 migrate로
가능합니다. migrate 명령 전에 0004 마이그레이션 파일을 수정하여 빈 슬러그 값을
가지는 레코드를 조회하여 슬러그 값을 채워줍니다.
마이그레이션에서는 모델의 커스텀 메서드에 접근할 수 없기에 slushify 함수를 직접
호출하여 slug 값을 채워주고요
마이그레이트 명령을 수행하면 잘 적용이 됩니다
포스터 디테일 뷰를 구현할 때 pk 값과 slug 값을 같이 받도록 구성했습니다
slug는 URL에만 표현할 뿐 조회에는 사용하지 않았고요 잘못된 slug 값으로 요청이
들어오면 올바른 slug 주소로 페이지 이동을 시키도록 했습니다
주소에 PK 값만 있어도 slug가 포함된 주소로 자동 이동이 됩니다
python manage.py showmigrations blog 명령을 내려보시면 현재
4번 마이그레이션이 적용이 되어 있고요 4번 마이그레이션 롤백을 위해서
migrate-blog-0003 명령을 내려주겠습니다
그러면 4번 마이그레이션이 롤백이 되었고요
Post 테이블에서 slug 컬럼이 제거된 것이죠
4번 마이그레이션 파일을 삭제하겠습니다
slug 필드에서 unique 인자를 제거하고요 Post 모델의 slugify 함수와
save 함수를 재정의해서 저장하기 전에 slug 값이 자동 지정되도록 호출도 해주겠습니다
slugify 함수도 이렇게 임포트를 해주겠고요 Make Migrations 블록 명령을
통해서 새로운 마이그레이션 파일을 생성하고요 Post 모델에 대한 slug 필드 not
null 필드를 추가하는 거죠
일회성 디폴트 값 지정을 위해서 1을 입력하고요 빈 문자열을 지정을 해줍니다
4번 마이그레이션 파일이 생성이 되었고 마이그레이션 파일을 열어보면 이제 유니크 설정은
없습니다 그냥 일반 문자열 필드예요
현재 Post 테이블에는 내 코드가 하나밖에 없지만 두 개 이상이 되더라도 이 마이그레이트
명령은 성공합니다
왜냐하면 슬러그 필드에서 유니크 설정이 없기 때문이죠
4번 마이그레이션 파일에다가 update slug if empty라는 함수를 하나 추가해
주겠습니다
slugify도 이렇게 import해 주고요
이 함수는 post 모델에 slug 필드가 추가되고 나서 함수 수행을 통해서 slug 값이
없는 모든 포스팅에 대해서 slug 값을 채워주고 slug 값에 대해서 일괄 업데이트하는
함수가 되겠습니다
이 함수 실행을 위해서 run python-operation 을 지정하고요 update
slug-if-empty 함수를 지정하고 그리고 두 번째 인자로는 no-operation
함수를 지정하겠습니다
python-manage-by-migrate-blog 명령을 수행해 보시면
migration이 정상적으로 수행이 되고요 포스트 테이블을 열어보시면 이렇게 slug
값이 채워져 있음을 확인하실 수 있습니다
현재 블로그 앱에 urls.py 파일이 없네요
추가를 해 주겠습니다
url 패턴 전 이름에 list를 하나 추가해 주고요 마이 사이트의 urls.py에서 블로그의
urls도 include해 줍니다
url 패턴들을 위한 함수들을 input해 주시고 pk 요청에서는 post-detail
함수를 호출하고요
pk와 slug 요청에서도 postDetail 함수를 호출하겠습니다
pk 값은 무조건 받고요 slug
인자는 있을 수도 있고, 없을 수도 있습니다
포스팅 조회에 대해서는 pk만 사용할 거예요
getObjectOr 404 함수를 통해서 pk를 통해서 포스팅을 조회하고요 그리고
slug 값이 포스팅이 있고 slug 인자의 값이 non이거나, 인자의 slug와 포스팅이
저장된 slug가 다를 때에는 return redirect, 그래서 slug가 있는 주소로
이동을 시키겠습니다
이때 url-reverse 사용을 위해서 blog-urspy에 app-name, blog
지정해 주고요 그리고 각각의 패턴마다 name도 지정을 해 주겠습니다
그러면 redirect 시에 namespace와 pattern_name을 쓰고요 그리고 PK
인자로 PK를 지정하고 slug 인자로 post의 slug를 지정합니다
이어서 permanent 인자로 참을 지정하겠습니다
Vue 응답으로서 템플릿 응답을 하시면 되겠고요 지금은 간단 구현을 위해서 HTTP
response로 이렇게 문자열을 반환하도록 하겠습니다
서버 구동 중지를 확인하시고요
현재 포스트 테이블에는 PK가 1인 레코드가 딱 하나가 있네요
웹브라우저를 여시고 블로그에 1로 접근해 보시면 이렇게 slug가 포함된 주소로 자동 이동을
하고 1번 글에 slug 제목 이렇게 보여지고 있음을 확인하실 수 있습니다



이번 내용은 유니크 필드를 추가할 때 마이그레이션 실패 문제를 해결하는 과정에 대해 다룹니다. 이 문제는 기존 데이터가 있을 경우 유니크 제약조건을 위배하면서 발생할 수 있습니다. 이를 해결하기 위한 다양한 방법을 설명하고, 어떻게 마이그레이션을 안전하게 수행할 수 있는지에 대해 안내합니다. 아래는 정리된 내용입니다.

문제 발생 시나리오: 유니크 필드 추가 시 마이그레이션 실패
문제 설명:
블로그 앱의 Post 모델에 slug 필드를 추가할 때, 기존 레코드가 있는 경우 유니크 제약조건을 위배하는 문제가 발생합니다.
slug 필드를 유니크하게 설정했지만, 이미 존재하는 레코드에 빈 문자열을 기본값으로 설정하면, 여러 레코드가 동일한 slug 값을 가질 수 있습니다. 
이로 인해 마이그레이션 시 유니크 제약조건 위반 오류가 발생합니다.
특히, Post 테이블에 2개 이상의 데이터가 있을 때, 마이그레이션은 실패합니다.

마이그레이션 실패:
Post 모델에 slug 필드를 추가하고 빈 문자열을 기본값으로 지정한 후, 유니크 제약 조건을 추가한 마이그레이션을 실행하면, 여러 레코드가 동일한 slug 값을 가지게 되어 마이그레이션이 실패합니다.
데이터베이스에 두 개 이상의 레코드가 있으면 slug 필드의 유니크 제약 조건을 위반하게 되어 migrate 명령이 실패합니다.


해결책 1: Slug 필드를 Non-Unique로 설정하기
Slug 필드 변경:
slug 필드를 Non-Unique 필드로 설정하여, 값 중복이 허용되도록 합니다.
Slug 필드는 URL에서 사람이 읽을 수 있는 값을 제공하기 위한 필드로, 반드시 유니크하지 않아도 됩니다.
URL에서 slug와 PK를 함께 사용하여 리소스를 식별할 수 있습니다. 이 방식은 slug 값이 유일하지 않아도 되며, URL에서 PK와 slug를 함께 노출하여 유니크성을 보장할 수 있습니다.

모델 수정:
Post 모델의 slug 필드에서 unique=True를 제거하고, slugify 함수로 제목을 slug로 변환하도록 설정합니다.
slug 값은 유니크하지 않아도 되기 때문에, 기존에 있는 동일한 값을 체크하지 않고 마이그레이션을 실행할 수 있습니다.

마이그레이션 수정:
슬러그 값이 비어 있는 레코드에 대해 일괄적으로 값을 채워주는 함수를 작성합니다. 이를 통해 마이그레이션이 실패하지 않도록 합니다.
RunPython operation을 사용하여 빈 슬러그 값이 있는 레코드에 대해 일괄 업데이트를 합니다.


해결책 2: 마이그레이션 파일 수정 및 데이터 채우기
빈 슬러그 값을 가진 레코드 업데이트:
마이그레이션 파일에 update_slug_if_empty 함수를 추가하여, 슬러그 값이 없는 레코드에 대해 값을 채워줍니다.
slugify 함수를 사용하여 제목(title)을 기반으로 slug 값을 생성합니다.

마이그레이션 수정:
4번 마이그레이션 파일을 수정하여, slug 필드를 Non-Unique로 설정하고, 데이터베이스에 빈 슬러그 값을 채우는 함수를 추가합니다.
이 함수는 RunPython operation을 통해 실행되며, 슬러그 값이 없는 레코드를 찾아 자동으로 값을 채워줍니다.

마이그레이션 파일 수정 후:
python manage.py migrate blog 명령을 통해 마이그레이션을 적용하면, 슬러그 값이 비어 있는 모든 레코드에 대해 slugify 함수를 통해 값이 채워지고, 마이그레이션이 성공적으로 적용됩니다.

해결책 3: Post 모델의 slug 값 자동 생성
save 메서드 재정의:
Post 모델에서 save 메서드를 오버라이드하여, 새로운 포스트가 저장될 때 자동으로 slug 값을 생성하도록 합니다.
slugify 함수를 사용하여 제목을 기반으로 slug 값을 자동으로 생성하고, 이를 모델에 저장하기 전에 설정합니다.

슬러그 자동화:
slugify 함수로 슬러그 값이 자동으로 생성되고, 모델의 저장 시점에 이 값이 자동으로 채워집니다.

해결책 4: URL 및 리디렉션 설정
URL 구성:
urls.py에서 Post 모델의 **slug**와 **pk**를 URL 패턴에 포함시킵니다.
Post의 상세 페이지를 구현할 때, **pk와 slug**를 URL로 사용합니다.
슬러그가 잘못된 경우, 자동으로 올바른 슬러그를 포함한 URL로 리디렉션합니다.

리디렉션 구현:
get_object_or_404 함수를 사용하여 pk를 통해 Post를 조회하고, slug 값이 잘못된 경우에는 **return redirect**를 통해 올바른 URL로 리디렉션을 구현합니다.
slug 값을 URL에 포함시키되, 실제 리소스 식별에는 pk 값을 사용하는 방식입니다.

요약
문제: Post 모델에 slug 필드를 추가할 때, 유니크 제약조건을 위배하여 마이그레이션이 실패하는 문제.

해결책:
Non-Unique 필드로 설정하여 유니크 제약조건을 제거하고, slugify 함수로 자동 생성된 slug 값을 사용.
마이그레이션 파일을 수정하여 빈 슬러그 값을 채우는 함수(update_slug_if_empty)를 추가하고 RunPython operation을 사용해 슬러그 값을 채움.
URL 패턴을 수정하여 pk와 slug를 함께 사용하고, 잘못된 슬러그 값이 있을 경우 자동 리디렉션 처리.
결과: slug 값이 중복되더라도 유니크 제약조건을 위배하지 않으며, 마이그레이션이 성공적으로 적용됩니다. Post 모델의 slug 필드는 이제 자동으로 생성되며, URL에서 slug와 pk를 함께 사용할 수 있습니다.


