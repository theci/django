이번 시간에는 장고의 핵심 기능을 빠르게 리뷰해 보겠습니다
웹 서비스의 기본 구조이고요 웹블라우저와 혹은 안드로이드 iOS에 비해 웹 요청의
클라이언트가 될 수 있겠고요 그리고 서버에서는 우리가 다양한 언어, 프레임워크로 개발을
해서 해당 웹 요청을 처리할 수 있겠습니다
우리는 Django로 개발을 할 것이고요
웹 요청을 처리할 때에 별도의 스토리지 서버, 데이터베이스 서버, 캐시 서버와 서로 통신을
하면서 웹 요청을 처리합니다 스토리지 서버는 파일들을 관리해주고요 데이터베이스 서버는
데이터를 관리해주고 캐시 서버도 데이터인데 데이터베이스 서버에서 어떤 데이터를 조회하는데
똑같은 데이터를 많이 조회해야 될 때에는 그 데이터를 캐시 서버에 넣어두고 조회하면
데이터베이스 서버의 부하도 줄일 수 있고 좀 더 빠른 조회가 가능해지거든요
이런 웹 서비스의 기본 구조가 있겠고요 장고에서도 똑같이 스토리지 서버와 데이터베이스
서버, 캐시 서버가 있을 수 있겠고 웹 브라우저가 요청을 보내면 그 요청을 어떤 뷰 함수에서
처리하는지 요청 분기를 해줘야 됩니다
요청 분기를 위해서 URL 패턴 리스트가 있습니다
그래서 어떤 주소로 요청이 들어오면 어떤 뷰 함수를 호출하겠다는 그 리스트가 있겠고요 그
리스트에 기반해서 이제 그 요청에 맞춰 뷰 함수를 호출해 주는 거고 그 뷰 함수는 요청을
처리하고 응답을 생성해 주는 함수고 그 뷰 함수가 응답을 반환하면 그 응답 내용이 웹
브라우저에게 그대로 전달이 되는 거고요 뷰함수가 요청을 처리하는 중에 데이터베이스 서버와
통신이 필요할 때, 즉 데이터베이스와 붙었던 데이터를 조회하거나 추가 수정을 삭제를 하고자
할 때에는 직접 SQL 코드를 작성해서 수행하셔도 되겠지만, Django의 모델을
활용하시면 모델은 데이터베이스에 대한 추상화를 제공해 줍니다.
그래서 SQLite, MySQL, MariaDB, PostgreSQL, Oracle,
SQL Server 등에 대한 추상화를 지원해 주기 때문에 똑같은 모델 코드로 여러
데이터베이스와 통신을 할 수 있고요
캐시 Server도 종류가 여러 가지가 있는데 장고도 캐시에 대한 추상화도
지원을 해주고 있습니다
그래서 PyCache, LocalMemoryCache, Memcached,
Redis 등에 대해서 똑같은 API로 접근할 수 있어요
어떤 Cache를 쓰겠다는 것도 장고 프로젝트의 Settings에다가 지적만 해주시면
우리가 실제 그 캐시를 사용하는 코드는 똑같은 코드로 사용을 하실 수 있겠고요 그리고
Django는 스토리지에 대한 API도 추상화를 지원해 줍니다
스토리지 API를 쓰는 Django 코드에서는 그 스토리지가 로컬 파일 시스템인지
FTP인지 아마존 웹 서비스의 S3인지 애저 스토리지인지 그러니까 중요하지 않아요
그냥 스토리지를 쓰는 거고요 어떤 스토리지를 사용하는지는 장고 프로젝트의 Settings
설정만 해주시면 돼요
해주시면 그 설정에 맞춰서 스토리지 서버에다가 파일을 저장하고 조회하고 파일의 상태도 보고
그리고 삭제도 하실 수 있게 됩니다
그리고 Django 뷰 함수가 긴 HTML 문자열 응답을 할 때에는 파이썬 코드에서
HTML 문자열도 조합하기보다 Django 템플릿 엔진을 활용하시면 복잡한 문자열을 보다
손쉽게 조합을 해서 응답을 줄 수 있게 되는 거죠.
장고 핵심 기능의 목록이고요.
하나씩 순서대로 살펴보겠습니다.
장고 뷰 함수입니다.
뷰 함수는 HTTP 요청을 처리하는 함수나 클래스입니다.
요청을 받아 처리한 후에 적절한 응답을 반환하는데요.
HTTP 리스펀스의 문자열을 반환하면 문자열 응답을 할 수도 있겠고요.
우리가 요청에 대한 어떤 인자를 받아서 적절히 처리한 후에 응답을 줄 수도 있겠고요.
HTML도 문자열이니까 이렇게 HTML 응답을 주면 웹브라우저가 HTML을 해석해서 화면에
뿌려줄 것이고요.
그리고 JSON 데이터 같은 것도 문자열이니까 그대로 응답을 줄 때에 문자열의 포맷이
JSON 포맷이다라고 이렇게 컨텐트 타입으로 응답을 줄 수 있습니다
문자열 성격에 맞춰서 컨텐트 타입을 적절히 지정을 하는 게 좋고요 여기에서는 JSON
문자열을 하드 코딩으로 직접 지정했지만 우리가 JSON response를 통해서 리스트나
사전이나 어떤 객체의 값을 JSON 문자열로 반환하실 때에는 JSON response를
활용하시면 내부적으로 JSON 직렬화가 수행이 되어서 HTTP response를 통해서
응답을 하게 됩니다
그리고 이미지 응답이 필요하다면 이와 같이 뷰 함수 내에서 이미지 데이터를 만들어낼 수
있어요 Pillow라고 하는 이미지 라이브러리가 있습니다
Pillow 라이브러리를 설치하시고 나서 from PIL을 통해서 사용하실 수 있겠고요
필러 5 버전 10부터 API 동작이 변경되는 부분이 있어서 버전을 받아오겠고요
버전 10 이상에서는 이런 코드를 쓰고 버전 10 미만에서는 아래 코드를 쓰도록 합니다
코드를 그대로 수행을 해주면 이미지 파일을 만드는 건 아니고요
메모리 상의 이미지 객체를 만든 다음에 이 객체에다가 폰트 로딩하고 텍스트로 쓴 다음에 이
메모리 객체를 응답에다가 저장할 수 있어요 응답에다 저장하고 리턴하게 되면 이와 같이
이미지 응답을 옵니다
코디 스트링으로 텍스트하는 인자가 없으면 안녕 장고 이렇게 되겠고요 텍스트로 파이썬 홀릭이
오면 이런 식의 이미지 응답을 줄 수 있습니다
이를 활용하면 사원증 같은 이미지 같은 것도 그런 이미지를 생성해주는 뷰함수 같은 거
만들어 볼 수 있겠죠 다양하게 활용을 할 수 있겠고요 뷰 함수는 문자열이나 이미지 뿐만
아니라 비디오나 어떤 포맷의 응답이든지 생성한 후에 HTTP 리스펀스를 통해서 응답을 줄
수 있습니다. 장고 모델은 파이썬 코드로 SQL을 자동 생성 수행을 해줍니다.
하나의 코드로 포스크 SQL, MySQL, MariaDB Oracle 등을 지원하고요
데이터베이스와 애플리케이션 간의 추상화를 지원해 주거든요
데이터베이스 테이블을 우리가 먼저 이렇게 만들 수 있죠
먼저 만들었다면 이 테이블 내역에 맞춰서 모델 클래스를 우리가 생성을 해줍니다
두 개 맞춰줘야 돼요.
Django의 모델은 모델 클래스 내역대로 SQL을 생성하기 때문에 모델 클래스 내역이
SQL가 틀리면 해당 데이터베이스에서 SQL이 동작할 때 SQL 오류가 발생할 거예요
이렇게 Post 모델과 Comment 모델을 만들었다면 이렇게
Model.Object.Or를 통해서 데이터베이스에서 셀렉트 조회를 하실 수 있겠고요 이런
쿼리가 자동으로 수행되겠고요 post.object.create를 통해서 인서트 쿼리도
수행할 수 있겠고요, object.allCount을 통해서 카운트 쿼리도 수행할 수
있겠고, post 모델과 코멘트, 즉, post 테이블과 코멘트는 외래키 관계예요
그래서 외래키 관계에도 우리가 코멘트, 댓글 생성할 때에 Post 클래스의의 인스턴스만
지정해주면 알아서 외래 키 값이 자동으로 할당이 되어서 인서트가 됩니다
두 개 외래 키 관계인데 댓글 목록을 출력하고자 할 때에 댓글에 포스팅 제목도 같이
출력하고 싶어요
그럴 때에는 보통 조인 쿼리를 직접 많이 만드는데요 조인 쿼리를 직접 이렇게 직접 만드시지 않아도
select-related라는 걸 붙여만 주면 알아서 조인 쿼리가 생성이 되어서 실행이
됩니다 참 편리하죠?
데이터베이스 테이블을 먼저 생성한 경우에는 이 테이블에 맞춰서 모델 코드를 정의를 해야
되는데요.
Django의 마이그레이션 기능이 있습니다.
이 마이그레이션 기능을 활용을 하면요.
데이터베이스 스키마의 변경을 혹은 생성을 손쉽게 관리해 줍니다.
모델 코드 변경만으로 변경 내역을 파악해서 데이터베이스에 반영할 수 있도록 도와주거든요.
자 데이터베이스 테이블 아직 안 만들었어요
만들기 전이고요 모델 코드를 먼저 정의합니다 장고에 makemigrations라는 명령을
주면은 이와 같은 파이썬 코드가 자동으로 생성이 돼요
자동으로 생성이 되고 물론 수정도 할 수 있어요 생성이 되고 이 자동 생성된 파일 기반에서
migrate라는 명령을 주면은 이렇게 create_table이라는 SQL이 자동으로
생성됩니다 그래서 장고의 마이그레이션 기능을 활용하면 모델 내역대로 테이블을 만들 수
있고요. 모델 필드가 바뀔 수 있죠.
특성이 바뀔 수 있습니다.
캐릭터 필드의 맥스 댕스가 100이었다가 200이 될 수 있어요.
필드가 추가될 수도 있잖아요.
그런 변경이 생기면 make migrations를 해주면 그런 변경을 테이블에 똑같이
반영을 해야 되잖아요
그래야만 모델 클래스로부터 생성된 SQL이 데이터베이스 서버에서 정상 동작할 테니까 당구의
migration은 이런 SQL이 정말 거의 정확하게 99.9% 정확하게 생성을 해주고요
그 나머지 부족한 일부로는 우리가 직접 마이그레이션 파일을 수정한다든지 혹은 파이썬
파일이나 혹은 SQL 코드를 추가해서 보완해서 데이터베이스 스키마에 대한 히스토리를 보다
안정적으로 관리할 수 있게 됩니다