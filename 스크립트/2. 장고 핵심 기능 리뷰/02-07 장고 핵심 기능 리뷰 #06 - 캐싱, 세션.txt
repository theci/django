동적 웹사이트의 근본적인 단점은 바로 동적이라는 점입니다.
사용자가 페이지를 요청할 때마다 웹서버는 데이터베이스 쿼리부터 템플릿 렌더링, 비즈니스
로직에 이르기까지 모든 종류의 계산을 수행하여 방문자에게 보여줄 페이지를 생성합니다.
이는 단순히 파일을 읽는 것보다 훨씬 비싼 작업이에요
대부분의 웹 애플리케이션들은 대형 사이트가 아니기에 이러한 오버헤드가 되게 큰 문제가 되지
않습니다 하지만 트래픽이 많은 중대형 사이트의 경우 오버헤드를 최대한 줄이는 작업이
필요합니다 이것이 바로 캐싱이 필요한 이유예요
캐싱은 값비싼 계산의 결과를 저장하여 다음에 계산을 수행할 필요가 없도록 하는 것입니다
데이터베이스 쿼리 결과나 복잡한 계산 값을 캐시에 임시로 저장하여 캐시로부터 빠르게
읽어드릴 수 있습니다 캐시 백엔드로는 memcached 서버, redis 서버 혹은 파일
시스템 등의 다양한 캐시 백엔드를 사용하실 수 있겠고요.
이를 통해 다양한 캐싱 전략을 구현할 수 있습니다.
세팅스의 Caches 설정을 통해서 여러 Cache 설정을 하실 수 있습니다
Report Cache로 현재 Local Memory Cache를 설정했고요 임의의
이름으로 추가로 Cache를 설정하실 수 있겠는데요
파일 기반의 Cache, 그리고 Memcached Caching, 그리고 Redis
Caching을 이렇게 추가할 수 있습니다
캐싱을 직접 처리하는 예시인데요.
Cache API를 직접 사용할 때에는 Cache나 Caches를 사용하는데요.
그냥 Cache를 쓰시면은 Default Cache를 사용하는 것이고요.
Caches를 쓰시면은 이렇게 Key 접근을 통해서 사용하는 Cache의 이름을 지정해서
사용을 합니다.
그러면 Cache와 Caches의 디폴트는 서로 같은 거예요
그러면 Cache.set과 Cache.get이 있는데 추가로 더 많은 API가 있습니다
그런 API들은 Cache 백엔드 종류에 상관없이 동일하게 사용을 할 수 있어요
Cache.set을 통해서 Cache에 저장하려는 키와 값을 입력하고 만료 시간을 입력할
수 있습니다 즉, 3초 후에 my-key라는 이름의 데이터가 만료가 되어서 자동으로 삭제가
되는 겁니다 값으로 hello world 입력했고요 그러면 Cache에 값을 저장하자마자
range 1, 4는 1, 2, 3이라는 값 3개를 생성하죠.
reverse를 통해서 값을 거꾸로 가져옵니다.
그러면 3 한번 가져오고 실행하고, 2 가져오고 실행하고, 1을 가져오고 실행할 거예요.
처음에는 countdown에 3이 저장이 되겠고요.
프린트 3, 그리고 이어서 점점점을 출력합니다.
제가 줄바꿈을 즉시 하지 않을 것이기 때문에 그냥 이렇게까지만 써주면 화면에 즉시 3,
점점점까지 출력이 안 돼요.
프린트 함수에서 내부 버퍼에 있는 값을 즉시 출력토록 해주면 화면에 즉시 여기까지 출력이
됩니다. 그리고 1초를 기다렸다가 캐시에 들어있는 값을 찍어보면 현재 1초가 지났죠.
그러니까 아직 값이 있고요 다음 루프에서 값을 2를 가져옵니다
그리고 2를 출력을 하고 1초 있다가 값을 읽어오면 아직 3초가 지나지 않았기 때문에 아직
값이 찍히고요 마지막 루프에서 1을 가져오고 1이 출력이 되고 1초 기다리면 이제 3초가
지났습니다 그렇기 때문에 해당 my-key의 값은 자동으로 만료가 되어서 삭제가 되었고,
조회된 값은 논이 됩니다.
이번에는 Vue에서의 캐싱 지원인데요.
Vue 함수에서는 cache-page하는 장식자를 활용해서 뷰 응답을 손쉽게 캐싱할 수
있어요 그래서 캐시 언더바 페이지에서 만료 시간을 지정할 수 있고 추가 인자로 사용할 캐시
종류를 지정할 수 있습니다 생략하면 디폴트 캐시를 사용하는 거예요
장고 템플릿에서도 캐싱을 쓸 수 있는데요 캐시란 이름의 템플릿 태그를 사용하고요 만료
시간과 그리고 추가 인자를 통해서 캐싱 키를 지정합니다
그러면 Cache와 End Cache란은 안에 있는 내용에 대해서 캐싱을 합니다
이 안에서 데이터베이스 조회나 다른 비싼 작업이 수행될 경우에 이렇게 템플릿 단에서 캐싱을
지원할 수 있겠고 Cache가 아닌 다른 영역의 코드들에 대해서는 캐싱 없이 수행이 되는
거죠 어떤 블로그 서비스가 있다고 했을 때 해당 포스팅의 내용을 보여주는 뷰함수가 있습니다
매번 같은 컨텐츠를 응답한다고 했을 때 매 요청마다 데이터베이스를 조회하고 템플릿을 통해
HTML을 지금 렌더링하는데요 매번 같은 컨텐츠를 응답하기 때문에 이 부분을 조금 최적화를
시켜 볼 수 있습니다
그때 이 view 함수에다가 cache-page라는 이름의 장식자를 적용하고 초단위로 만료
시간을 지정하잖아요
그러면 처음 1회만 이와 동일한 데이터베이스 조회를 하고 템플릿을 통해 html을 렌더링한
후에 응답을 주고 그때의 cache.set을 통해서 cache에 저장을 합니다
그러면은 이 만료 시간 전에는 캐시가 만료가 안되겠죠?
그 다음 요청부터는 데이터베이스를 조회하지 않고 그 즉시 캐시에서 바로 꺼내서 응답을
줍니다. 웹은 본래 스테이트리스한 특성을 가지고 있습니다.
이는 각 HTTP 요청이 독립적이라는 의미로 서버는 클라이언트의 이전 상태나 행동에 대한
정보를 기억하지 않아요.
Session이나 Cookie를 통해 스테이틀리스한 웹 환경에서도 사용자의 상태나 데이터를
일정 시간 동안 유지할 수 있습니다.
상고 Session은 서버 측의 데이터를 저장하고 쿠키에는 세션 아이디를 저장하는데요.
디폴트 세션 백엔드는 데이터베이스입니다.
즉, 별도의 서버죠.
그렇기에, Django 서버가 여러 대가 되더라도 같은 세션을 공유할 수 있고요.
데이터베이스 백엔드 외에도 Session IO 속도 향상을 위해서 memcached나
Redis를 Session 백엔드로 사용하실 수 있습니다.
즉, 사용자의 상태를 서버에 임시로 저장할 수 있는데요.
로그인을 유지하기 위한 필수 기술입니다.
그리고 Session은 웹 API에서도 널리 사용되는 인증 방식입니다.
이렇게 로그인 뷰를 간략하게 한번 구현해 보았습니다
이는 로그인 과정을 간략하게 구현했을 뿐 실제 로그인 과정은 보안에 대한 깊은 고려가
필요하고요 Django Auth 앱에 있는 Login 뷰를 사용하시면 됩니다 로그인
요청에서 유저 네임 데이터와 패스워드 데이터가 있습니다
그래서 멤버 모델에서 유저 네임으로 그 멤버가 있는지 찾아서 그 멤버에 대한 암호가
일치하는지 체크 패스워드 함수도 체크하고요 암호가 맞다면 세션에다가 그 멤버의 아이디를
저장을 하는 거예요
그리고 로그인 되었다는 응답을 주는 거고 암호 검증이 실패하면은 유저명이나 암호가 틀렸다고
응답을 줍니다
그러면 로그인 required 뷰, 즉 로그인이 필요한 뷰에서는 로그인 유무를 체크하기
위해서 request.session.get, 즉 session에서 member.id 값이
있으면 가져오고 없으면 논을 반환하는 것인데요
그 값이 없으면 로그인이 필요합니다라고 응답을 주고 그리고 값이 있으면 로그인 되었습니다
라고 주는 거죠
그리고 로그아웃에서는 멤버 아이디의 세션을 제거하는 거죠
이렇게 로그아웃을 합니다
여기까지 장고 핵심 기능에 대해서 빠르게 살펴보았습니다
이제 장고 개발을 함께 시작해 보시죠





Django의 주요 기능 정리
이번 내용은 Django에서 성능 최적화 및 사용자 상태 관리와 관련된 핵심 기능들, 특히 캐싱, 세션, 로그인/로그아웃 처리에 대해 다루었습니다. 각 기능에 대한 내용을 아래와 같이 정리했습니다.

1. 캐싱 (Caching)
캐싱은 값비싼 계산 결과를 임시로 저장하여 반복적인 계산을 피하는 기술로, 성능을 최적화하는 데 중요한 역할을 합니다. 특히, 트래픽이 많은 중대형 웹사이트에서 오버헤드를 줄이기 위해 필수적인 기능입니다.

캐시 백엔드:

Memcached, Redis, 파일 시스템 등 다양한 캐시 백엔드를 사용할 수 있습니다.
Caches 설정을 통해 여러 캐시 백엔드를 설정할 수 있습니다.
캐시 API 사용:

Cache.set(): 데이터를 캐시 저장. 저장할 키와 값, 만료 시간을 지정할 수 있습니다.
Cache.get(): 저장된 데이터를 캐시에서 읽어오기.
템플릿 캐싱:

cache 템플릿 태그를 사용하여 템플릿 단에서 캐시를 처리할 수 있습니다.
cache와 endcache 사이에 있는 내용이 캐싱됩니다.
뷰 캐싱:

cache_page 장식자를 사용하여 뷰 응답을 캐싱할 수 있습니다.
뷰 함수에 캐싱을 적용하면, 동일한 요청에 대해 데이터베이스 조회 없이 캐시에서 바로 응답을 줍니다.
2. 세션 (Session)
웹은 기본적으로 스테이트리스(stateless) 하므로, 각 HTTP 요청은 독립적입니다. 그러나 세션을 사용하면 사용자의 상태를 일정 기간 동안 유지할 수 있습니다. 세션은 로그인 상태 유지 등의 기능에 사용됩니다.

세션 저장소:
기본적으로 데이터베이스를 사용하여 세션 정보를 저장합니다.
성능 향상을 위해 Memcached나 Redis와 같은 서버 기반 세션 백엔드를 사용할 수 있습니다.
세션 사용 예시:
세션은 request.session을 통해 접근합니다.
request.session.get()으로 세션 데이터를 가져오거나, request.session['key']로 세션 값을 설정할 수 있습니다.
로그인 상태 관리:
로그인 후 세션에 사용자 ID를 저장하여 사용자의 로그인 상태를 관리합니다.
request.session['user_id']와 같은 방식으로 로그인 상태를 저장하고, 이를 기반으로 사용자 정보를 추적합니다.
3. 로그인/로그아웃 처리
Django에서는 로그인과 로그아웃을 쉽게 처리할 수 있으며, 세션을 활용하여 로그인 상태를 유지합니다.

로그인 과정:

사용자가 로그인 폼에서 아이디와 비밀번호를 입력하면, 서버에서 해당 사용자의 정보를 찾아 인증합니다.
인증이 성공하면, 세션에 사용자 정보를 저장하여 로그인 상태를 유지합니다.
로그인 성공 후, request.session['user_id']와 같은 값을 세션에 저장하여 사용자가 인증된 상태로 웹 애플리케이션을 이용할 수 있도록 합니다.
로그아웃 과정:

로그아웃 시에는 세션에서 사용자 정보를 삭제하여 로그아웃을 처리합니다. request.session.flush() 또는 del request.session['user_id']를 통해 세션을 삭제할 수 있습니다.
4. Django 핵심 기능의 빠른 구현 예시
로그인 뷰 예시:
사용자가 입력한 아이디와 비밀번호를 통해 사용자 인증을 수행하고, 인증 성공 시 세션에 사용자 ID를 저장합니다.
로그인 필요 뷰 예시:
request.session.get('user_id')로 세션에서 사용자의 로그인 상태를 확인하고, 로그인이 필요한 페이지에서는 로그인 여부를 체크합니다.
로그아웃 예시:
request.session.pop('user_id')로 로그아웃 후, 세션에 저장된 사용자 정보를 삭제합니다.
요약
캐싱:
값비싼 계산 결과나 데이터베이스 조회 결과를 캐시하여 성능을 최적화합니다.
cache_page 장식자나 템플릿 캐싱 태그를 사용하여 데이터를 효율적으로 캐싱할 수 있습니다.
세션:
사용자 상태를 서버에 저장하고, 이를 통해 로그인 상태를 관리할 수 있습니다.
request.session을 사용하여 세션 데이터를 저장하고 조회합니다.
로그인/로그아웃:
사용자의 로그인 상태를 세션을 통해 관리하고, 로그인 과정 및 로그아웃을 쉽게 처리할 수 있습니다.
이러한 Django의 기능들을 적절히 활용하면, 성능 최적화와 사용자 상태 관리를 효율적으로 구현할 수 있습니다.