안녕하세요. 이번 시간에는 Axios 라이브러리를 활용해서 HTTP API 요청 방법에
대해서 살펴보겠습니다.
Axios 라이브러리는 기본 패치 API보다 많은 기능과 편의성을 제공해 줍니다.
먼저, 간편한 정상 응답 처리인데요.
패치 API는 네트워크 오류가 아닌 한 모든 상태 코드를 성공으로 처리하기에 수동으로 상태
코드 확인이 필요합니다.
하지만 Axios에서는 디폴트 설정으로 상태 코드 200 이상 300 미만의 상태 코드만을
정상으로 처리하고요.
그 외의 상태 코드는 에러 상태로 처리합니다.
그래서 매번 일일이 응답 상태 코드를 확인할 필요가 없습니다.
두 번째로 보다 간결한 JSON 응답 변환입니다.
응답 객체의 데이터 속성으로 역직렬화된 자바스크립트 객체를 참조하실 수 있습니다.
세 번째로 패치에서는 타임아웃이 되기 전에는 처리 중인 요청을 취소할 수 없는데요.
Axios에서는 처리 중인 요청을 취소할 수 있습니다.
그래서 잘못된 요청이나 긴 요청을 타임아웃 전에 취소 가능합니다.
네 번째로 요청을 보내기 직전에 수행될 함수, 응답을 받은 직후에 수행될 함수를 지정할 수
있습니다. 이를 Interceptor라고 합니다.
이를 통해 일관된 로직으로 요청을 보내기 전에 헤더를 추가하거나 로깅을 하실 수 있고요.
응답 내역을 전처리하실 수도 있습니다.
마지막으로 업로드, 다운로드 진행률 추적을 지원합니다.
그래서 UI에 업로드, 다운로드 진행률을 표시할 수 있습니다.
2023년 11월 16일 멜론 차트 JSON 데이터가 있습니다.
Axios 라이브러리를 활용해서 HTTP GET 요청을 보내고 JSON 응답을 받아
객체화하여 상태 값에 반영하고 테이블로 렌더링하는 Melon Song List 컴포넌트
예시입니다. 아래 링크에서 복사해서 실습해 보겠습니다.
f7.jsx 파일을 생성하고요.
Melon Song List 컴포넌트 코드를 복사합니다.
동작을 확인해 보면 Axios 라이브러리가 없다고 하네요.
Axios 라이브러리 설치를 안 했었고요.
설치를 해줍니다.
F7.jsx 파일에서는 Bootstrap5 CSS를 임포트하지 않았음에도 이렇게
Bootstrap5 스타일로 보여지고 있습니다.
그 이유를 살펴보면 부트스텝 CSS는 f4.jsx 파일에서 임포트되어 있고 f4 컴포넌트를
사용하진 않지만 index.javascript 파일 내에서 임포트가 되어 있죠
CSS는 전역 스코프를를 가지기에 다른 컴포넌트에도 영향을 미친 상황입니다
멜론 Song List 컴포넌트에서는 송리스트 상태 값을 초기값 빔 배열로 설정했고요.
load송리스트 함수를 호출하면 액시오스를 통해 지정 URL로 GET 요청을 보내어 응답의
JSON 데이터를 송리스트 상태 값에 반영합니다.
load송리스트 함수는 useEffect hook을 활용하여 컴포넌트가 처음 마운트 될 때
1회 호출토록 하고요.
새로 고친 버튼 클릭 시에도 호출토록 합니다.
송리스트 상태값 배열을 순회하며 테이블 엘리먼트를 통해 렌더링합니다
그럼 페이지 새로고침 시에도 엑시오스를 통해 HTTP 요청이 잘 전달되고요 새로고침 버튼
클릭 시에도 HTTP 요청이 잘 전달되어 응답 데이터로 이렇게 멜론 차트가 잘 렌더링 되고
있습니다 Axios Hook 라이브러리가 있습니다.
이 라이브러리를 활용하시면 React 컴포넌트 내에서 데이터 요청과 상태 관리를 선언적으로
처리하실 수 있습니다.
그리고 내부에서 요청과 응답에 대한 상태 관리를 해줍니다.
관리해주는 상태 값은 응답 객체, 로딩 여부, 오류 상태입니다.
그리고 디폴트로 컴포넌트 초기 렌더링 시에 자동으로 요청이 전달됩니다.
그래서 매번 UseEffect Hook을 통해 요청 API를 수동으로 요청할 필요가
없습니다. 물론 수동 요청도 지원하고요.
재요청도 하실 수 있습니다.
그리고 Custom Axios Hook 생성을 지원합니다.
특정 API 요청에 특화된 Custom Axios Hook을 만드실 수 있습니다.
기존 멜론 Song List 컴포넌트의 Axios Hooks 라이버리에 Use
Axios Hook을 적용해 보겠습니다.
요청 주소를 지정하는 것만으로 컴포넌트 초기 렌더링 시에 자동으로 API 요청을 합니다.
그러니 따로 Use Effect Hook을 통해 수동으로 API를 요청하지 않아도 됩니다.
이렇게 hook 반환 값으로 요청 데이터, 상태 값, 로딩 여부 상태 값, 에러 객체 상태
값, 제 요청 함수를 받아서 활용하시면 됩니다.
새로고침 버튼을 클릭하면 repatch 함수를 호출만 하면 되고요.
응답 대기 중에는 중복에서 새로고침이 전달되지 않도록 disabled 속성의 loading
상태 값을 반영합니다.
로딩 상태 값은 참, 거짓, 불리한 값입니다.
로딩 중일 때에는 스피너 아이콘을 보여주고요.
로딩이 끝나면 새로고침 텍스트를 보여주도록 하겠습니다.
그리고 에러가 발생하면 에러 메시지를 Alert Danger 스타일로 노출시킵니다.
Axios Hooks 라이브러리를 설치합니다.
유즈 엑시오스 훅을 사용하고요 첫 번째 인자로 JSON 데이터 URL 문자열을 지정합니다
그럼 이제 유즈 이펙트 훅을 사용하지 않아도 컴포넌트 마운트 시에 자동으로 요청을
수행합니다 반환 값으로는 첫 번째가 상태 값이고요
두 번째가 제 요청 함수입니다
상태 값으로는 데이터 로딩 에러를 지원합니다
데이터 필드명은 너무 일반적이니까요 이름을 Songlist로 변경하겠고요 디폴트 값으로 빈
배열을 지정하겠습니다
디폴드 값을 지정하지 않으면 디폴드 값이 Undefined가 되고요.
요청에 대한 응답을 받기 전까지는 Undefined 상태가 유지됩니다.
그러면 Songlist 상태 값이 Undefined였다가 배열로 변경되는 상황이 발생하죠.
상태 값은 하나의 타입만 가지는 것이 좋습니다.
상태 값의 타입이 일관되지 않으면 이를 사용하는 컴포넌트에서 추가적인 타입 체크나 방어
코드를 작성해야 하거든요.
코드가 복잡해지죠.
그래서 초기 값을 빈 배열로 지정해 줍니다.
Songlist 변수 선언이 중복되어 빌드 에러가 발생했습니다.
useState 후 코드는 제거하고요.
이제 loadSongList 함수도 필요 없고 useEffect 코드도 필요 없습니다.
모두 제거합니다.
새로 고친 버튼을 클릭했을 때 repeat 함수를 호출하도록 합니다.
버튼 엘리먼트에서는 디세이블드 속성을 지원합니다.
참으로 지정하면 버튼을 클릭할 수 없도록 비활성화합니다.
디세이블드 속성에 로딩 상태 값을 적용하면 로딩 중에는 새로고침 버튼을 클릭할 수 없도록
막을 수 있습니다.
로딩 중에는 스피너 아이콘을 보여주고요.
로딩이 끝나면 새로고침 레이블을 보여줍니다.
로딩 에러가 발생하면 에러 메시지를 Alert Danger 스타일 스타일로 보여주도록 합니다
데이터 URL 주소를 변경해서 존재하지 않는 주소를 지정하시면 이렇게 에러 메시지가
렌더링됨을 확인하실 수 있습니다
데이터 URL 주소는 원복해 주세요
멜론 검색 UI를 구현해 보겠습니다 초기에는 검색어 폰만 보여주고요
검색어가 입력되고 엔터키가 눌러지면 그제서야 검색 API 요청을 할 것이거든요
그래서 자동 요청을 보내지 않고 수동 요청을 하도록 Use Axios Hook의 두 번째
인자로 Manual 참 설정을 합니다
그럼 Repatch 함수 호출을 하면 기본 설정으로 API 요청이 되고요 Repatch
함수 호출 시에 옵션을 추가하여 요청을 보낼 수 있습니다 검색어는 Query 상태 값에
저장했다가 엔터키가 눌러지면 API 요청을 보내도록 구성하겠습니다.
노래에 검색 결과가 있다면 MelonSongList 컴포넌트에 SongList 속성 값으로
노래 배열을 넘겨 렌더링하도록 합니다.
F7 컴포넌트에서 컴포넌트를 정의하고 MelonSongSearch 컴포넌트를
Export Default로 노출하겠습니다
그럼 Melon Song Search 컴포넌트가 렌더링됩니다
Bootstrap 5로 기본 스타일을 잡고요 검색어를 실시간으로 저장할 Query 상태
값을 추가합니다.
Query 상태 값이 인풋 엘리먼트에도 반영되도록 Value 속성 값으로 지정합니다.
그럼 인풋 요소에서 키보드 입력으로 글자를 입력해봐도 입력이 되지 않습니다.
이는 인풋 요소가 Query 상태 값으로 제어되기 때문이고요.
아직 Query 상태 값은 계속 빈 문자열입니다.
체인지 이벤트 핸들러를 추가하여 쿼리 상태 값에 인풋 요소의 값을 반영합니다.
그럼 이제 검색어 입력이 되고 코리 상태 값에도 입력된 문자열이 실시간으로 반영되고 있음을
확인하실 수 있습니다.
이제 엔터키를 입력하면 검색을 하고 싶은데요.
인풋 엘리먼트를 폼 엘리먼트로 감싸 썼다면 엔터키로 폼에 서브 및 이벤트를 발생시킬 수
있는데요. 지금은 폼 엘리먼트를 쓰지 않았으니 직접 엔터키 키 입력을 잡아 보겠습니다.
이벤트 객체의 키 속성으로 현재 입력된 키가 엔터키인지
식별하실 수 있습니다.
페이지 새로고침 후에
검색어 입력하고 엔터키 입력해 보시면 이렇게 콘솔 메시지가 출력되고 있습니다.
이때 코어디 상태 값을 참조해서 현재 검색어를 참조하실 수 있습니다.
이제 검색 요청을 보내기 위한 useAxios hook을 사용해 보겠습니다.
첫 번째 인자로 요청 주소를 문자열로 지정합니다.
객체로 지정하여 요청 주소와 요청 방식을 지정하실 수도 있습니다.
두 번째 인자로 요청 옵션을 객체로 지정합니다.
메뉴얼 참 설정을 해주시면 컴포넌트 Mount 시점에 자동 요청을 보내지 않습니다.
첫 번째 반환 값은 상태 값이고요 데이터 로딩 에러가 있습니다
두 번째 반항 값은 요청 함수입니다 응답 데이터의 이름은 searchResult로
변경하고요 default 값도 지정해 주겠습니다
이제 엔터키가 입력되면 search 함수를 호출하여 검색어 파라미터도 같이 넘겨서 검색
요청을 수행합니다
검색 결과는 JSON 직렬화해서 확인해 볼게요
검색어를 입력하고 엔터키를 치시면 잠시 후에 이렇게 검색 결과가 출력됨을 확인하실 수
있습니다 로딩 중 메시지를 Alert Info 스타일로도 보여주겠고요 검색 결과에서 노래
목록은 Song Content 필드에 있거든요
그러니 응답 데이터에서 Song Content 필드가 있다면 노래의 검색 결과가 있다는
것이고요 노래 목록을 Melon Song List 컴포넌트에 속성 값으로 넘겨서
렌더링하겠습니다.
Melon Song List 컴포넌트는 내부 상태나 네트워크 통신 없이 속성 값에만 의존하기
때문에 순수 컴포넌트라고 할 수 있습니다.
이제 Melon Songlist 컴포넌트에서는 속성 값을 제외하고 엘리먼트 코드만 남게
됩니다. BTS로 검색 결과는 4건 있는데요.
보여지는 텍스트가 없습니다.
Songlist 속성 값을 JSON 직렬화하여 데이터 구조를 파악해 보면요.
데이터의 필드와 참조하고 있는 필드명이 다르네요.
곡의 식별자, 앨범 이미지 주소, 곡명, 가수명 필드명을 응답 데이터에 맞게 수정하고요.
좋아요 수는 검색 결과에 없으니 제거하고, 노래 바로가기 링크를 제공하겠습니다.
곡의 식별자만 알면 해당 곡의 상세 페이지로 이동할 수 있는 URL을 만들 수 있습니다.
링크를 클릭하면 멜론 페이지가 열립니다.
그런데 URL에서 오타가 있었네요.
HTML이 아니라 HTM입니다.