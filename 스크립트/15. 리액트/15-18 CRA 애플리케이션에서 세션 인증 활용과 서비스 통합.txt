안녕하세요. 이번 시간에는 CRA 리액트 애플리케이션에서 장고의 세션 인증을 활용하여
HTTP 요청을 보내는 방법을 살펴보겠습니다.
현재 장고 개발 서버의 주소는 http://localhost:8000이고요.
리액트 CRA 개발 서버의 주소는 http://localhost:3000입니다.
localhost 호스트는 같은데 포트 번호만 다른 상황입니다.
http://localhost:8000의 session cookie는
http://localhost:3000 페이지에서 공유되지만 포트 번호가 달라
http://localhost:8000 서버로 http 요청 시에 쿠키가 자동 전송되지 않습니다.
Django 서버로 Axios 요청 시에 with credential 옵션을 참으로
지정하여 http 요청 시에 쿠키가 자동 전송될 수 있도록 합니다.
API.js 파일에서는 React 앱 API with Credentials
환경 변수를 활용하도록 이미 구현되어 있습니다.
참으로 지정해 줍니다.
http://localhost8000의 블로그의 Who Am I 페이지에서는 Session
인증 여부를 확인해서 이렇게 인증된 유저의 유저명을 응답하고 있죠.
Use API Axios Hook을 통해 요청을 하겠고요.
HTML 응답이니 요청에 Content Type 헤더는 Text HTML로 설정합니다.
응답으로 받은 HTML 문자열을 alert 컴포넌트를 통해 보여주겠습니다.
Django 템플릿에서도 cross-site scripting, 공격 방어를 목적으로
변수에 담긴 HTML 문자열을 escape하여 HTML 태그를 태그가 아닌 일반 문자열로
렌더링하는 보안 기능이 default 적용되어 있습니다.
만약 HTML 태그로서 동작 토로 하려면 safe 템플릿 필터를 통해 safe
string으로 변환을 합니다.
React 기본에서도 같은 목적으로 HTML 태그를 태그가 아닌 일반 문자열로
렌더링합니다.
HTML 태그로서 동작 토록하려면 Dangerously Set in a HTML 속성을
활용합니다. 개발자가 의도적으로 이 기능을 사용하고 있음을 인지하도록 하기 위해 속성명에
위험이라는 경고 단어를 붙인 듯 보입니다.
장고 서버가 구동 중이어야 하고요.
장고 서비스에서 로그아웃 상황에서는 이렇게 401 Unauthorized 응답을 받게 되고요.
로그인 상황에서는 세션 인증이 정상 처리되어 장고 서버에서의 인증 유저명을 이렇게 응답으로
받아왔습니다.
JSON 요청에서는 컨텐트 타입 헤더만 생략해 주시면 됩니다.
CRA 리액트 페이지에서 Django HTTP API 요청을 위한 설정은 이걸로 끝입니다.
클라이언트 사이드 렌더링 방식이기에 WhoMI 내용이 채워지는데 약간 딜레이가 있습니다.
장고 뷰 응답이나 Next.js 응답은 서버 사이드 렌더링 방식이기에 초기 응답부터
WhoMI 내용이 채워져 있을 것입니다.
먼저, 장고 서비스에서 HTTP 로컬 호스트 3000 페이지로부터의 HTTP 허용 및 쿠키
허용을 위해 두 개의 환경 변수를 설정합니다.
CRA 리액트 애플리케이션에서도 API 서버 주소 및 다른 호스트로의 쿠키 전송을 위해
환경 변수를 설정합니다.
탑 내비게이션 컴포넌트에서 http://localhost:8000에 블로그의 Whoami
페이지로의 HTML GET 요청을 보냅니다.
응답 데이터는 Whoami HTML 상태 값에 저장될 것이고요.
응답을 받기 전까지는 default 값은 null입니다.
브라우저 콘솔에 Whoami HTML 상태 값을 출력해 보겠습니다.
현재 장고 페이지에 로그인 상황이라서 이렇게 현재 로그인 유저명이 담긴 HTML 문자열
응답을 받았고요.
로그아웃 후에 다시 요청해 보시면 이렇게 401 unauthorized 응답을 받게
됩니다. 내비게이션 바 컴포넌트 아래에 후에마이 HTML alert 메시지를 출력하겠고요.
추가해 보시면 JSX 오류가 발생합니다.
모든 JSX 표현식은 단 하나의 루트 요소를 가져야 하는데요.
지금의 코드는 내비게이션 바와 2개의 루트 요소가 있습니다.
div 엘리먼트로 묶어서 하나의 루트 요소로 만들어 주셔도 되고요.
깊이를 늘리지 않고 논리적으로만 루트 요소로 묶어 주시려면 빈 태그를 사용해 주세요.
이를 fragment라고 합니다.
Fragment는 여러 요소를 그룹화할 때 추가적인 DOM 요소를 생성하지 않습니다.
Alert 컴포넌트 import해 주시고요.
로그아웃 상황에서는 이렇게 401 unauthorized 응답을 받아 엑시오스에서 에러
상태로 처리하기 때문에 응답 내역이 없습니다.
Django 로그인 페이지를 따로 방문하셔서 로그인 후에 페이지 새로 고침하시면 이렇게
Session 인증이 되었고 API 응답까지 잘 받아왔습니다.
CRA 리액트 페이지에서 엑시오스를 통한 HTTP 조작에서 401 응답을 받았을 경우
페이지 자동 이동을 하고 싶습니다.
Django의 로그인 리퀘어드 장식자 같은 거죠.
401 응답을 받으면 자동으로 Django 로그인 페이지로 이동을 하고 로그인을 하면
지금의 CRA 리액트 페이지로 자동 이동을 하는 겁니다.
CRA 리액트 페이지에서 로그인 URL, 로그아웃 URL, 사인업 URL, 프로필 URL
설정을 환경 변수를 통해 설정할 수 있도록 하고요.
디폴트 값으로 API 호스트 설정을 참조해서 장고 페이지에 맞게 URL을 만들어
주겠습니다.
api.javascript에 Axios 인스턴스에 응답에 대한 Interceptor 함수를
등록해서 401 응답을 받으면 로그인 할 주소로 페이지 이동을 하고 next query
파라메타로 현재 페이지 주소를 지정합니다.
constant.javascript 파일에서 환경 변수로부터 로그인 URL, 로그아웃
URL, 사인업 URL, 프로필 URL 상수 설정을 하고요.
외부에 노출도 시켜줍니다.
api.js 파일에서는 Axios 인스턴스를 통한 요청 이후에 받은 응답에
대해서 자동으로 수행될 함수를 등록합니다.
이를 Interceptor라고 합니다.
인자로 두 개의 함수를 등록하는데요.
첫 번째 함수는 응답이 성공일 때 호출되는 함수이고요.
두 번째 함수는 응답이 에러일 때 호출되는 함수입니다.
에러 상황에서 응답의 상태 코드가 401일 경우 로그인 페이지로 페이지 이동하도록 합니다.
로그인 후에 현재 페이지로 다시 돌아오도록 next query 파라미터로 현재 페이지
주소를 지정합니다.
페이지 새로고침해 보시면 현재는 로그인 상황이라 후에마이 호출에서 200 응답을 받은
상황이고요. 직접 로그아웃 하신 후에 페이지 새로고침해 보시면 이렇게 자동으로 로그인
페이지로 이동을 했고요.
Next.js query 파라메타에도 방금 전 CRA 리액트 페이지 주소가 지정되어 있음을
확인하실 수 있습니다.
로그인을 해주세요.
분명 Django 로그인 페이지에서 Next 인자로 React 페이지 주소가 지정되어 있었는데요
로그인을 해보면 로그인 성공 후에 React 페이지로 이동을 하는 것이 아니라 디폴트
로그인 이동 주소인 프로필 페이지로 이동을 해버립니다
이유가 무엇일까요?
Django 클래스 기반 뷰에서 로그인 뷰 클래스와 로그아웃 뷰 클래스는 니따이렉트 URL
믹싱 클래스를 상속받는데요.
로그인 뷰 클래스와 로그아웃 뷰 클래스에서만 사용되는 Auth 앱만의 믹싱 클래스입니다.
리다이렉트 URL 믹싱 클래스에서는 보안을 이유로 허용된 호스트로의 이동만을 허락합니다.
미리 허용되지 않은 호스트가 지정될 경우 해당 주소를 무시합니다.
로그인 후에 혹은 로그아웃 후에 Next 인자로 지정된 CrA React 페이지로의 이동을
허용하려면 LoginView, LogoutView 클래스에 SuccessURL,
AllowedHost 속성으로 집합 자료 구조로 허용할 호스트를 추가해 주셔야 합니다.
Django Settings의 커스텀 설정으로 SuccessURL, AllowedHost를
추가하고 환경 변수로부터 주입도 받도록 하고요.
LoginView, LogoutView 클래스에도 적용해 주겠습니다.
Django 환경 변수에 Success URL Allowed 호스트를 추가하고요 값은
React 호스트인 Localhost 3000을 지정합니다 프로토콜은 쓰지 않습니다
Django Settings.py 하단의 새로운 설정으로서 Success URL
Allowed 호스트를 추가하고요 같은 이름의 환경 변수를 참조하고 리스트로 가공해서
활용합니다 Auth 앱의 로그인 뷰 코드를 보시면 현재 요청을 받는 서버와 View 클래스에
SuccessURL의 AllowsHost 속성을 집합으로 묶어 AllowedHost
설정으로 사용하고 있습니다.
SuccessURL의 AllowsHost 속성은 디폴트로 빈 집합입니다.
Account 앱의 LoginView 클래스와 LogoutView 클래스의
SuccessURL AllowsHost 속성을 Settings에 SuccessURL
AllowsHost 값으로 추가해줍니다.
수동으로 로그아웃하시고 http://localhost3000 페이지에 방문하시면 자동으로
Django의 로그인 페이지로 이동을 하고요.
Next Query 파라메터로 방금 전 CRA 리액트 페이지 주소가 지정되어 있죠.
로그인에 성공하시면 이제 더 이상 프로필 페이지가 아닌 Next Query 파라메타에
지정된 CRA 리액트 페이지로 이동했음을 확인하실 수 있습니다.
CRA 리액트 페이지의 Top Navigation 컴포넌트에 로그인, 회원가입, 프로필,
로그아웃 링크가 있습니다.
WhoAmI HTML의 default 값이 NULL이니깐요.
NULL이 아니라면 서버로부터 뭔가 응답을 받은 상황이니 후에마이, HTML 값을 보고
링크를 만들어 주겠습니다.
그런데 블로그의 후에마이 페이지 응답에서는 401 응답에서도 응답 바디가 있으니 현재
코드는 적절하진 않습니다 탑 내비게이션 컴포넌트에서 로그인, 회원가입, 프로필, 로그아웃,
링크 부분을 복사해서 적용합니다
각 상수들을 임포트해 주시고요 로그인 URL과 로그아웃 URL에는 현재 페이지 주소를
next query 파라메타로 지정해서 로그인, 로그아웃 후에 현재 페이지 주소로
이동하도록 했습니다
프로필 페이지로도 잘 이동하고요.
로그아웃을 해보시면 로그아웃 후에 CRA 리액트 페이지로 이동했는데 후에 마이 페이지에서
401 응답을 받아 자동으로 로그인 페이지까지 이동했습니다.
Accounts 앱에 Status API를 만들어서 인증 여부에 상관없이 요청하면 인증
여부, 유저명 메시지를 JSON 포맷으로 응답하도록 하겠습니다.
장고 뷰에서 요청을 처리 중에 메시지 프레임워크를 통해 메시지를 쌓아뒀을 때 바로 CRA
리액트 페이지로 이동하면 메시지 소비가 안 되잖아요
그러니 Status API에서 누적된 메시지 목록도 같이 응답으로 주도록 합니다 장고
템플릿 응답에서는 매 뷰 응답마다 하던 거죠.
이렇게 요청해보면 이처럼 인증 여부, 유저명, 등록된 메세지 목록을 응답으로 받습니다.
누적된 메세지는 한번 소비되면 자동으로 제거됩니다.
Account 앱에 api.py 파일을 생성하고요.
미리 제공해 드린 코드를 복사해서 적용합니다.
Status API에서는 GET 요청만을 받고요.
인증이나 권한 체크는 하지 않고요.
JSON 포맷으로만 응답합니다.
응답 내역으로 인증 여부, 유저명, 메시지 목록이 있습니다.
Account 앱의 urls.py 파일에는 API URL 패턴도 등록해 줍니다.
방금 등록한 Status API 주소는 Account API의 Status가 됩니다
웹브라우저로 직접 요청해 보시면 이렇게 응답을 받습니다
CRA 리액트 페이지에서 HTML 포맷의 Whoami 요청 코드를 JSON 포맷의
Status API 요청 코드로 변경합니다.
API 엔드포인트 주소를 변경하시고요.
JSON 응답이니 Content Type, Text, HTML 헤더는 제거하고요.
그럼 기본적으로 Application JSON으로 요청이 전달되고, 엑시오스에서 자동으로
JSON 역직렬화를 수행해 줍니다.
그럼 응답으로 받은 객체에서 인증 여부, 유저명, 메시지 목록이 있을 것이고요.
이제 인증 여부 플래그를 통해 로그인 여부를 확실히 판단할 수 있습니다.
유저명을 참조해서 React 딴에서 메시지도 만들고요.
메시지 목록에 대해서도 alert 컴포넌트를 통해 보여주겠습니다.
이는 보여주기 나름이니까요.
토스트 방식으로도 보여줄 수 있겠죠.
Django의 메시지 시스템에서는 default 태그로 탑 내비게이션 컴포넌트에서 요청
주소를 account의 api의 status로 변경하고요.
json 요청이니 Content-Type, Text, HTML 헤더 지정은 제거합니다.
응답 객체의 이름을 지정하고 응답을 받기 전까지 디폴트로 빈 객체를 지정합니다
디폴트 값을 지정하지 않으면 응답을 받기 전까지는 Status Object 상태 값은
Undefined가 되어 컴포넌트 내에서 Undefined 값에 대한 방어 코드가 더
필요하게 됩니다
응답 객체에서 유저명, 메시지 목록을 추출하고요 JSX 코드의 상태 값을 반영합니다
메시지 목록은 항상 배열이니깐요.
메시지가 있을 때에만 렌더링토록 하고요.
메시지 태그에 대한 맵핑 객체를 통해 alert에서 지원하는 variant 문자열로
변환해서 지정합니다.
그럼 5가지 타입의 모든 메시지를 지원하게 됩니다.
로그아웃하시면 로그아웃 되셨고, 로그아웃 뷰에서 지정한 메시지가 이렇게 CRA 리액트
페이지를 통해 보여짐을 확인하실 수 있습니다.
파이썬에서는 일반적으로 변수 네이밍은 snake 케이스를 사용하고 자바스크립트에서는
camel 케이스를 사용하는 경우가 많습니다
그래서 Django REST 프레임워크 API 응답에서도 파이썬의 변수 네이밍을 따라
snake 케이스로 응답을 하게 되고요 리액트 코드에서 서버로부터 받은 데이터 객체는
snake 케이스이고 그 외 변수는 camel 케이스가 있고 변수 네이밍이 뒤섞이게 됩니다
이때, Django REST 프레임워크 카멜 케이스 라이버리를 설치하시고, Default
Renderer 클래스와 Passer 클래스를 모두 카멜 케이스로 변경하시면 이렇게 API
응답과 요청에서 카멜 케이스를 사용하실 수 있습니다.




이 글은 리액트(CRA) 애플리케이션에서 Django 세션 인증을 활용하여 HTTP 요청을 보내고 처리하는 방법을 설명하고 있습니다. 여러 단계를 통해 쿠키 설정, 인증 처리, 로그인 후 리다이렉트, 메시지 처리 등을 다루고 있습니다. 주요 내용을 정리하면 다음과 같습니다:

1. 리액트와 Django 간의 쿠키 공유 문제 해결
Django 서버와 리액트 개발 서버는 각각 localhost:8000과 localhost:3000에서 실행되고 있으므로, 쿠키 공유에 문제가 발생합니다.
리액트 애플리케이션에서 Axios를 사용하여 HTTP 요청을 보낼 때, withCredentials: true 옵션을 설정해 세션 쿠키를 Django 서버로 자동 전송하도록 합니다.
2. Who Am I 페이지와 세션 인증
Django 서버에서는 /whoami 페이지에서 로그인 여부에 따라 유저명을 반환합니다.
React에서는 이를 HTML 응답으로 처리하고, 이를 dangerouslySetInnerHTML로 렌더링합니다.
401 Unauthorized 상태일 경우 로그인 페이지로 이동하도록 설정합니다.
3. Django 서버 설정: CORS 및 세션 관리
Django에서 CORS를 허용하려면, CORS_ALLOWED_ORIGINS와 CORS_ALLOW_CREDENTIALS 설정을 추가해야 합니다.
세션 인증을 위한 설정으로, Django에서 SESSION_COOKIE_SAMESITE 값을 None으로 설정하여 다른 포트에서 요청을 받을 수 있도록 합니다.
4. React에서 HTTP 요청 및 응답 처리
React에서는 Axios 인스턴스를 활용하여 HTTP 요청을 보냅니다. 요청 시, withCredentials: true 옵션을 설정하고, 응답이 401인 경우 자동으로 로그인 페이지로 리다이렉트하는 로직을 추가합니다.
이를 위해 Interceptor를 사용하여 Axios 응답을 처리하고, 상태 코드가 401일 경우 로그인 페이지로 리다이렉트합니다.
5. Django 로그인 후 리다이렉트 문제 해결
Django에서는 로그인 후 리다이렉트 URL을 설정할 때, 보안상의 이유로 허용된 호스트로만 리다이렉트를 허용합니다.
Success URL과 Allowed Host를 Django 설정에 추가하여, React 페이지(localhost:3000)로 리다이렉션을 허용합니다.
6. React에서 로그인, 로그아웃, 회원가입 링크 관리
React 애플리케이션에서 로그인 상태에 따라 네비게이션 바의 링크를 다르게 표시합니다. 인증된 경우 유저명을 표시하고, 인증되지 않은 경우 로그인 링크를 제공합니다.
로그아웃 후에는 로그인 페이지로 자동으로 리다이렉트되며, 로그인 후에는 원래 페이지로 돌아가게 설정합니다.
7. Django에서 메시지 시스템 활용
Django의 메시지 시스템을 통해 로그인 및 로그아웃 시 발생하는 메시지를 React로 전달합니다.
React에서 Status API를 호출하여 인증 여부, 유저명, 메시지 목록 등을 JSON 형식으로 받아 처리합니다.
8. Django에서 API 응답 포맷을 변경
Django에서 JSON 응답의 변수명 포맷을 snake_case로 설정하는 대신, camelCase를 사용하고 싶을 경우 Django REST Framework의 카멜 케이스 라이브러리를 활용합니다.
이를 통해 Django에서 JSON 응답을 보낼 때 camelCase로 일관되게 처리할 수 있습니다.
핵심 단계 요약
쿠키 설정: 리액트 앱에서 withCredentials: true 설정하여 Django 서버와 쿠키 공유.
세션 인증 처리: Django에서 세션 인증을 사용하여 로그인된 유저 정보 반환.
401 응답 처리: 리액트에서 401 응답을 처리하고 로그인 페이지로 자동 리다이렉트.
리다이렉트 URL 설정: Django에서 리다이렉트 URL 및 허용된 호스트를 설정하여 React 페이지로 리다이렉트.
상태 관리: 로그인/로그아웃 후 상태에 맞는 링크 및 메시지를 React 컴포넌트에 표시.
메시지 시스템: Django 메시지 시스템을 React에서 사용할 수 있도록 JSON 형식으로 전달.
카멜 케이스 응답: Django에서 카멜 케이스 응답을 보내기 위해 DRF 라이브러리 사용.
결론
이 과정에서는 리액트와 Django 간의 세션 인증 및 HTTP 요청/응답을 처리하는 방법을 다뤘습니다. 이를 통해, 리액트 애플리케이션에서 Django의 세션을 안전하게 처리하고, 로그인 및 로그아웃 흐름을 효과적으로 관리할 수 있습니다.