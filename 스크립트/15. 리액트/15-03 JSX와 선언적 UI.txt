안녕하세요. 이번 시간에는 JSX와 선언적 UI에 대해서 살펴보겠습니다.
React에서는 H1, DIV 등의 엘리먼트를 조합하여 컴포넌트를 구성합니다.
이때 JSX 문법을 활용하면 HTML 마크업을 작성하듯이 직관적으로 각 엘리먼트를 조합할
수 있습니다.
JSX 코드는 웹브라우저에서 바로 실행할 순 없고요.
아래와 같은 자바스크립트 코드로 변환된 후에 실행할 수 있습니다.
생성된 엘리먼트는 지정된 HTML 요소에 렌더링되어 화면에 표시됩니다.
JSX에서 각 엘리먼트의 속성 값을 지정할 때 중괄호를 통해 값이나 표현식을 지정하거나
따옴표로 문자열로 값을 지정해야만 합니다.
값을 지정할 때 숫자 값을 지정한다고 해서 쌍따옴표나 중관로를 사용하지 않고 숫자만
지정하시면 이렇게 신텐스 에러 문법 오류가 발생합니다.
JSX 문법은 리턴문 내에서만 사용할 수 있는 것은 아니고요.
React Element 생성이 필요한 어느 지점에서나 사용할 수 있습니다.
또한 속성 값을 지정할 때 중관로 두 개를 자주 보실 텐데요.
바깥 중관로는 표현식을 의미하며 안에 중괄호는 자바스크립트 객체를 나타냅니다.
HTML에서의 class 속성을 JSX에서는 className 속성으로 지원합니다.
JSX는 HTML이 아니라 자바스크립트 코드이거든요.
그래서 자바스크립트 언어에서 예약어인 class는 속성 이름으로 사용할 수 없습니다.
myreact01 CRA 프로젝트에서 npm run start 명령으로 개발 서버를
구동합니다. CRA 프로젝트의 시작 페이지는 public의 index.html 파일입니다.
이 파일에서 id가 root인 요소의 react 애플리케이션이 렌더링됩니다.
src 폴더의 index.js 파일에서 react 컴포넌트 렌더링 코드를
확인하실 수 있고요.
앱 컴포넌트를 임포트해서 id가 root인 요소에 렌더링하고 있습니다.
src 폴더에 App.js 파일의 앱 컴포넌트가 구현되어 있습니다.
기본 구현은 모두 제거하고요.
hello world 문자열만 남기고 저장하시면 저장 즉시 웹페이지가 자동 새로고침
됩니다. 웹소켓을 통한 HMR 기능이 동작했습니다.
타일 속성에 오브젝트를 지정해서 CSS 스타일을 하드코딩 하실 수 있습니다
혹은 별도 변수의 오브젝트를 생성하고 그 변수를 지정하는 방식도 가능합니다
키 속성에는 숫자 1을 지정해 보려 합니다 숫자 값이기에 중괄호 없이 지정해 보려 하는데요
지정하시면 이렇게 신텐스 에러가 발생합니다
에러 메세지를 읽어 보시면 jsx 값은 중괄로를 사용한 표현식이거나 다운표를 사용한
문자열이어야 한다고 합니다.
숫자 1을 중괄호로 묶어주시면 오류 없이 렌더링이 잘 됩니다.
HTML에서처럼 div 엘리먼트 안에 여러 엘리먼트를 중첩하실 수 있고요.
JSX 문법으로 따로 생성한 엘리먼트를 변수에 저장한 후에 이를 활용해서 동일하게 렌더링
하실 수도 있습니다.
React Element에서는 className 속성이 지원되는데요
웹브라우저에서 렌더링된 요소를 확인해 보시면 class 속성으로 렌더링 되었음을 확인하실
수 있습니다
자바스크립트 코드에서는 class는 예약어이기 때문에 속성명으로 사용할 수 없기 때문입니다
선언적 UI는 UI의 최종 상태를 선언하고 렌더링 수행은 라이브러리에 위임하는
패러다임입니다
UI에 영향을 미치는 여러 값을 정의합니다
이를 상태값, state라고 부르며 useState Hook을 통해 정의합니다
useStateHook의 첫 번째 인자는 상태값의 초기값이고 생성된 상태값에 대한
getter와 setter 함수를 반환합니다
상태값을 참조하여 UI의 레이아웃을 선언적으로 구성합니다
한 번 구성된 레이아웃은 프로그램 실행 중에 변경되지 않습니다
상태값의 Getter는 불변 객체로 취급하여 절대 직접 변경해서는 안 되고요 상태값의
Set 함수를 통해서만 상태값을 변경할 수 있습니다
상태값의 set 함수를 호출하여 상태값이 변경되면 React가 자동으로 재렌더링을
수행합니다 이 과정에서 변경된 상태값에 맞춰 화면이 다시 그려집니다
함수가 다시 호출되더라도 각 컴포넌트의 상태값은 계속 유지됩니다.
앱 컴포넌트에서 카운트 코드가 3번 반복되고 있는데요.
이를 별도의 컴포넌트로 분리하여 리액트 애플리케이션의 성능, 코드 가독성 및 유지 보수성을
모두 개선할 수 있습니다.
부모 컴포넌트로부터 내려받은 값을 속성 값, props라고 부릅니다.
속성 값을 UI에 직접 반영하기도 하고요.
상태 값의 초기 값으로 사용하기도 합니다.
상태 값과 마찬가지로 속성 값이 변경되면 해당 컴포넌트와 그 컴포넌트의 모든 자식
컴포넌트는 자동으로 재렌더링 됩니다.
자식 컴포넌트는 부모로부터 전달받은 속성값을 참조만 할 뿐 변경할 수는 없습니다.
변경할 수 있는 방법도 있는데요.
이는 뒤에서 살펴보겠습니다.
컴포넌트 UI에 반영하는 내부 데이터를 상태값, state라고 부릅니다.
useState 훅을 통해 생성하고요.
컴포넌트의 여러 상태값 중 어느 하나라도 변경되면 해당 컴포넌트와 모든 자식 컴포넌트는
자동으로 재렌더링을 수행합니다.
앱 컴포넌트에 3개의 버튼 엘리먼트를 추가합니다.
3개의 상태값 count1, count2, count3도 추가하고요.
초기값은 0입니다.
각 버튼 엘리먼트의 레이블로는 count1, count2, count3 상태값을
적용하고요. 3버튼 모두 0으로 보여지고 있습니다.
클릭해도 현재는 값의 변화는 없습니다.
이 중 첫 번째 버튼을 클릭하면 콘솔 창에 클릭트 카운트 원 메시지를 출력하도록
해보겠습니다. 첫 번째 버튼을 클릭하면 해당 메시지가 잘 출력됩니다.
각 카운트 상태 값의 Setter 함수를 통해 각 버튼을 클릭할 때마다 각 상태 값을 일식 증가
증가시키도록 해보겠습니다.
클릭해보면 첫 번째 버튼은 클릭할 때마다 일식 증가하는데 두 번째, 세 번째 버튼을
클릭해도 값이 변경되지 않습니다.
두 번째 버튼, 세 번째 버튼의 클릭 이벤트 리스너에서 setCount1 함수를 호출하고
있었네요.
count2 상태값, count3 상태값은 변화가 없어 0이었을 테니, 버튼을 클릭할
때마다 count1 상태값을 1로 설정하고 있는 상황이었습니다.
두 번째 버튼, 세 번째 버튼의 ClickEventListener에서 호출하는 함수를
setCount1과 setCount2로 수정해 줍니다.
그러면 각 버튼을 클릭할 때마다 값이 각각 1씩 증가됨을 확인하실 수 있습니다.
현재 세 개의 카운터가 있고요.
같은 패턴의 코드가 세 번 반복되고 있습니다.
카운터 컴포넌트를 새롭게 구현해 보겠습니다.
함수 컴포넌트의 첫 글자는 반드시 대문자여야 합니다.
대문자가 아니라면 함수 컴포넌트로서 동작하지 않습니다.
카운트 상태 값을 추가하고요.
초기 값은 0입니다.
버튼 엘리먼트로 렌더링하고 버튼을 클릭할 때마다 상태 값을 일씩 증가시킵니다.
앱 컴포넌트에서 카운터 컴포넌트를 활용해 보겠습니다.
이제 앱 컴포넌트에서 카운트 상태 값을 관리할 필요가 없어졌습니다.
모두 제거하고요.
카운터 컴포넌트를 그냥 3번 렌더링 하시면 됩니다.
그럼 동일하게 잘 동작합니다.
각 카운터 컴포넌트에서 초기 값을 지정해 주겠습니다.
React에서는 부모 컴포넌트에서 자식 컴포넌트의 속성 값으로서 값을 내려줄 수 있습니다.
initialCount라는 속성으로서 값을 내려줬고요.
카운터 컴포넌트에서는 함수에서 인자를 전달하듯이 같은 이름으로 속성 값을 받을 수
있습니다. 컴포넌트에서 속성 값을 받지 않더라도 오류가 발생하진 않고요.
단지 그 값은 무시될 뿐입니다.
이니셜 카운트 속성 값을 카운트 속성 값의 초기 값으로 지정합니다.
그러면 부모로부터 전달받은 속성 값에 기반해서 각 버튼의 초기 값이 설정되어 동작함을
확인하실 수 있습니다.



이번 시간에는 JSX와 선언적 UI에 대해 살펴보았습니다. 아래는 주요 개념과 내용을 간단히 정리한 내용입니다.

1. JSX (JavaScript XML)
JSX는 자바스크립트 내에서 HTML 구조를 작성할 수 있는 문법입니다. React에서 UI를 구성할 때 JSX를 사용하면 직관적으로 엘리먼트를 작성할 수 있습니다.

JSX 문법 특징:

JSX는 웹 브라우저에서 바로 실행될 수 없으며, 자바스크립트 코드로 변환된 후 실행됩니다.
JSX에서는 속성 값을 중괄호 {}를 사용하여 자바스크립트 표현식이나 변수 값을 지정할 수 있습니다.
따옴표 ""는 문자열 값에 사용됩니다.
속성 이름: HTML에서는 class 속성을 사용하지만, JSX에서는 className을 사용합니다. (자바스크립트의 예약어인 class와 충돌을 피하기 위해)
예시:

jsx
코드 복사
const element = <div className="container">Hello, World!</div>;
문법 오류:

JSX에서 속성 값을 숫자 등으로 지정할 때는 반드시 중괄호 {}를 사용해야 합니다.
예를 들어 1을 직접 지정하면 오류가 발생하며, 1을 {1}로 작성해야 정상 작동합니다.
2. React 컴포넌트와 렌더링
리액트 컴포넌트는 UI를 정의하는 함수입니다. 컴포넌트는 JSX를 반환하여 UI를 렌더링합니다.

예시:

jsx
코드 복사
const App = () => {
  return <h1>Hello, World!</h1>;
};
컴포넌트 렌더링: React는 컴포넌트를 HTML 요소에 렌더링하여 화면에 표시합니다. React는 ReactDOM.render()를 사용하여 컴포넌트를 특정 DOM 요소에 렌더링합니다.

HMR(핫 모듈 리플레이스먼트): 개발 서버에서 코드 수정 시 자동으로 화면이 새로 고침됩니다.

3. 선언적 UI (Declarative UI)
선언적 UI는 UI의 최종 상태를 선언하고, 그 상태에 맞는 화면을 자동으로 렌더링하는 패러다임입니다. React는 이를 상태 관리를 통해 처리합니다.

상태(State): UI에 영향을 미치는 값들을 상태 값으로 관리합니다. 상태 값은 useState 훅을 사용하여 정의됩니다.

useState는 상태값의 초기값을 인자로 받고, 상태 값의 getter와 setter 함수를 반환합니다.
상태 값의 변경:

상태 값은 직접 변경하지 않고, setter 함수를 통해 변경합니다.
상태 값이 변경되면 React는 자동으로 재렌더링을 수행하여 UI를 업데이트합니다.
불변성: 상태 값은 불변 객체로 취급되어야 하며, 직접 수정하지 않고 setState를 통해 상태를 업데이트해야 합니다.

4. 컴포넌트 분리와 Props 사용
React에서는 컴포넌트를 분리하여 재사용성과 가독성을 높일 수 있습니다.

Props: 부모 컴포넌트에서 자식 컴포넌트로 값을 전달할 때 사용합니다. props는 읽기 전용이며, 자식 컴포넌트에서 변경할 수 없습니다.

부모 컴포넌트는 자식 컴포넌트에 값을 props로 전달하고, 자식 컴포넌트는 그 값을 읽기만 합니다.
예시:

jsx
코드 복사
const Counter = ({ initialCount }) => {
  const [count, setCount] = useState(initialCount);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
};

const App = () => {
  return (
    <div>
      <Counter initialCount={0} />
      <Counter initialCount={5} />
      <Counter initialCount={10} />
    </div>
  );
};
5. 상태 관리 및 성능 최적화
상태 관리: useState 훅을 사용하여 각 컴포넌트에서 독립적인 상태를 관리합니다. 상태 값이 변경되면 React가 자동으로 해당 컴포넌트 및 자식 컴포넌트를 재렌더링합니다.

컴포넌트 분리: 여러 번 반복되는 코드(예: 카운터)를 별도의 컴포넌트로 분리하여 코드의 재사용성을 높이고, 가독성과 유지보수성을 개선할 수 있습니다.

컴포넌트 최적화: 상태 관리 및 렌더링 최적화를 통해 리액트 애플리케이션의 성능을 향상시킬 수 있습니다.

6. 최종 예시: 카운터 컴포넌트
상태 값을 useState로 관리하고, 버튼 클릭 시 카운트 값을 증가시키는 카운터 컴포넌트를 분리하여 구현할 수 있습니다.

부모 컴포넌트에서 초기값을 props로 전달하고, 자식 컴포넌트는 이를 받아서 상태를 관리합니다.

예시:

jsx
코드 복사
const Counter = ({ initialCount }) => {
  const [count, setCount] = useState(initialCount);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
};

const App = () => {
  return (
    <div>
      <Counter initialCount={0} />
      <Counter initialCount={5} />
      <Counter initialCount={10} />
    </div>
  );
};
이와 같이 JSX와 선언적 UI를 통해 리액트 애플리케이션을 구조화하고, 상태 관리와 컴포넌트 분리를 통해 더 깔끔하고 유지보수하기 좋은 코드를 작성할 수 있습니다.

