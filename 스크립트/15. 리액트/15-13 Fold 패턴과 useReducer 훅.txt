안녕하세요 이번 시간에는 폴드 패턴과 useReducer 훅에 대해서
살펴보겠습니다 폴드 패턴이란 컬렉션의 각 값을 순회하며 누적하여 하나의 값을 만드는 과정을
말합니다 리액트 개발에서 많이 사용되는 패턴입니다
1부터 5까지의 수를 더하고 싶습니다
폴드 패턴을 적용해서 구현하면요.
일단 초기 값을 0으로 두고요.
첫 번째 값 1과 초기 값 0을 더해 누적 값 1을 계산합니다.
이렇게 더해주는 함수를 reduce라고 하겠습니다.
이어서 누적 값 1과 두 번째 값 2를 더해서 누적 값 3을 계산하고요.
이어서 누적 값 3과 세 번째 값 3을 더해서 누적 값 6을 계산합니다.
이어서 누적 값 6과 네 번째 값 4를 더해서 누적 값 10을 계산합니다.
이어서 누적 값 10과 값 5를 더해서 누적 값 15를 계산합니다.
각 항목들을 살펴보면요.
reduce 함수는 누적 값과 현재 값, 그 두 개의 인자를 받아 두 값을 계산하여 새로운
누적 값을 반환합니다.
순수 함수로서 구현하고요.
초기 값은 폴드 작업마다 다양한 값을 둘 수 있겠는데요.
누적 합에서는 0을, 누적 곱에서는 1을 사용할 것이고요.
누적에서 통계치를 쌓아갈 때에는 빈 객체를 지정합니다.
현재 값은 배열에서 순서대로 함수 호출 인자로 전달되는 각 요소를 의미하고요.
누적 값은 매 호출마다 연산 결과가 누적되는 값입니다.
파이썬과 자바스크립트, 리액트에서 지원되는 reducer 함수 함수에서는 reducer 함수의
첫 번째 인자로 전달되고요.
호출 시마다 값이 자동 업데이트 됩니다.
결과 값은 최종 누적된 값을 의미합니다.
파이썬에서는 reduce 함수를 통해 폴드 패턴을 구현합니다.
첫 번째 인자로 reducer 함수를 전달받고, 두 번째 인자로 순회를 돌 리스트, 세
번째 인자로 초기 값을 전달받습니다.
Reducer 함수의 첫 번째 인자는 누적 값, 두 번째 인자는 현재 값을 전달받습니다.
자바스크립트에서는 배열의 Reduce 메서드를 통해 Fold 패턴을 구현합니다.
첫 번째 인자로 Reducer 함수를 전달받고, 두 번째 인자로 초기 값을 전달받습니다.
파이썬과 마찬가지로 리듀서 함수의 첫 번째 인자는 누적 값, 두 번째 인자는 현재 값을
전달 받습니다.
리듀서 함수를 어떻게 구현하느냐에 따라 리스트나 배열의 요소를 합산, 곱셈, 연결 등
다양한 방식으로 누적하여 최종 결과를 생성할 수 있습니다.
이를 통해 복잡한 데이터를 간단하게 처리하고 변환할 수 있습니다.
Node.js 기본에서는 Common.js 모듈로 동작하는데요.
Common.js 모듈에서는 await 키워드를 코드의 최상위 수준에서 사용할 수
없습니다.
Node.js에서 Common.js 모듈이 아닌 ESM, 즉 ECMAScript 모듈로
동작하려면 소스 파일의 확장자를 MJS로 사용하시면 됩니다.
그러면 Node.js에서는 해당 파일을 ECMAScript 모듈로 인식합니다.
지정 URL의 JSON 파일 로딩에서 배열로 변환하고요.
배열에는 100개의 객체가 저장되어 있습니다.
각 객체마다 좋아요
필드가 있습니다.
이 좋아요 필드만 합산하려 합니다.
합산이니 초기 값은 0으로 두겠고요.
함수에서는 좋아요
수와 누적 값을 더한 값을 반환합니다.
수행하면 이처럼 좋아요 수의
총합이 계산됩니다.
이어서 리스트업된 가수의 수를 계산해 보려 합니다.
먼저 가수 필드만 뽑아서 배열을 만들고요.
그럼 탑 100에 여러 곡이 올라간 가수들은 배열에 중복해서 이름이 등록이 되겠죠.
집합을 활용해서 중복을 배제하고 카운트합니다.
그러면 이렇게 52명의 가수가 차트에 올라있음을 계산할 수 있습니다.
배열에서 각 항목의 값을 변환하는 것이니 reduce 메서드 대신에 map 메서드로도 구현
가능합니다. 이번에는 가수별 곡수를 통계를 내보려 합니다.
초기 값은 빈 객체로 지정하고요.
누적 값에 해당 가수 정보가 없으면 0으로 초기화하고요.
곡수에 맞춰 일시 카운트합니다.
그럼 이렇게 가수별로 곡수 통계를 낼 수 있습니다.
노래 곡수가 많은 가수부터 Top5를 출력하려 합니다
위 통계 객체를 Key Value 배열로 변환하고 곡수를 기준으로 내림차순으로 정렬한
새로운 배열을 생성하고요 상위 5개만 슬라이싱하시면 이렇게 Top5를 출력하실 수 있습니다
앞에서 현재 값은 숫자였는데요
현재 값을 일정한 패턴의 객체로 다루면 다양한 복잡한 연산을 처리할 수 있습니다
보통 타입 필드로 연산의 종류를 지정하고 다른 필드에는 추가적인 데이터를 포함합니다
타입에 따라 추가적인 데이터는 달라질 수 있습니다
이 객체를 액션 객체라고 부르는데요.
이 객체가 상태를 변경하기 위해 수행할 동작 또는 행동을 기술하기 때문입니다.
초기 상태 값을 0으로 두고요.
첫 번째 액션 객체와 초기 값 0으로 계산하는데요.
타입이 플러스니까 서로 더해서 누적 값 1을 계산합니다.
이어서 누적값 1과 두 번째 액션 객체로 계산하는데요.
type이 plus니까 서로 더해서 누적값 3을 계산하고요.
이어서 누적값 3과 세 번째 액션 객체로 계산하고 type이 minus니까 뺄셈으로 해서
누적값 0을 계산합니다.
이어서 누적값 0과 네 번째 액션 객체로 계산하고요.
type이 minus니까 뺄셈으로 해서 누적값 minus 1을 계산합니다.
이어서 누적값 –1과 다섯 번째 액션 객체로 계산하고요.
타입이 마이너스니까 뺄셈을 해서 누적값 –1을 계산합니다.
이를 Reducer 함수에서는 이렇게 액션 객체에서 타입을 추출하고요.
타입에 맞춰 계산을 다르게 수행합니다.
Reducer 함수에서 반환값이 없다면 누적값이 Undefined로 변경되니 지원하지 않는
타입일 경우에는 반드시 현재 값을 유지하도록 인자의 누적값을 반환해 주세요.
UseReducer, Hook을 통해 Reducer의 개념을 컴포넌트 상태 관리에 접목할
수 있습니다. 다른 개념들은 이미 살펴본 개념들인데요.
Dispatch 함수가 하나 새로운 개념입니다.
UseReducer, Hook은 상태 값을 관리하고 있고요.
관련 Dispatch 함수를 통해 액션 객체를 전달하면 그 액션 객체를 반영해서 상태 값이
변경됩니다.
UseReducer, Hook은 인자로 Reducer 함수의 초기 값을 전달받아 상태값
Getter와 Dispatch 함수를 반환합니다.
상태값을 직접 변경할 수 있는 Set 함수는 반환하지 않으며, 대신 Dispatch 함수와
Action 객체를 통해 상태를 누적해가며 상태를 변경합니다.
세트 함수와 비교해서 Reducer를 활용하면 두 가지 장점이 있습니다
첫 번째로 상태 변경은 항상 액션 객체를 통해 이루어지기 때문에 액션 객체의 변경의 의도를
명확하게 나타낼 수 있고요 상태 변경의 원인을 추적하기 쉽습니다
두 번째로 상태 변경 로직이 흩어져 있지 않고 하나의 함수로 중앙 집중화됩니다
이는 상태가 어떻게 변경되는지를 명확하게 정의하고 추적할 수 있습니다.
StateReducer 패턴은 React 컴포넌트에서 상태와 그 상태를 업데이트하는 로직을
분리하여 코드의 가독성, 유지보수성, 재사용성을 높이는 데 도움을 줍니다.
Count 상태값과 Color 상태값 예시를 하나 더 살펴보겠습니다.
카운트와 컬러 상태값은 독립적인 상태값이 아닌 서로 의존 관계이기에 하나의 객체로 만들어서
한 번에 변경하시면 불필요한 재렌더링을 줄일 수 있습니다.
H1 엘리먼트의 글자색에 컬러 상태값을 반영하고요.
레이블로 카운트 상태값을 반영합니다.
버튼을 클릭하시면 인크리먼트 함수를 호출하여 1만큼 증가시키고 짝수 여부에 따라 색상을
변경하구요 버튼을 클릭하면 디크리먼트 함수를 호출하여 1만큼 감소시키고 짝수 여부에 따라
색상을 변경합니다
useState Hook을 활용한 상태관리는 간단하고 직관적인 코드이지만 상태 변경 로직이
분산되어 있기에 로직이 복잡해지면 관리에 어려움이 생기고요 의존관계 상태값을 동시에
업데이트해야 할 경우 구현이 복잡해집니다
컴포넌트가 작거나 각 상태값들이 서로 의존관계가 없을 경우에 유용합니다
src의 컴포넌트 폴더에 Counter 컴포넌트를 생성합니다
f6.jsx 파일을 생성하시고 카운터 컴포넌트를 사용하겠고요 index.js
파일에서도 f6 컴포넌트만을 사용하도록 합니다
카운터 컴포넌트에서는 상태 값으로써 count와 color 이 두 개의 상태 값이
필요한데요 카운트 상태 값에 의존해서 컬러 상태 값을 변경할 것이거든요.
그러니 이때에는 이 두 개의 값을 하나의 객체로서 상태 값으로 관리하시면 상태 값 변경
로식도 간단해지고 제 렌더링 횟수도 줄이실 수 있습니다.
디버깅 목적으로 상태 값 내역을 손쉽게 확인하기 위해 JSON 문자열로 변환을 한 뒤에
렌더링토록 플러스 1 버튼을 클릭하면 인크리먼트 함수를 호출하도록 하고요.
마이너스 1 버튼을 클릭하면 디크리먼트 함수를 호출하도록 합니다.
각 함수에서는 임허의 produce 함수를 사용하여 변환 함수를 생성하고 생성된 변환
함수를 상태값 set 함수에 넘겨 상태값 변환을 처리합니다.
임허를 사용했으니 불변성을 신경 쓰지 않고 count 값도 변경하고 count 값에 맞춰
color 값도 변경합니다.
동작을 확인해 보시면 count 값이 변경되고 그에 맞춰 count 값 짝수일 때는
green, 홀수에서는 red로 잘 변경되고 있습니다.
Color 상태 값은 글자색 스타일에 적용하겠고요.
Count 상태 값은 Label로 보여주도록 합니다.
State Reducer 패턴을 적용하여 동일하게 동작하는 Counter Component를
이렇게 만들어 볼 수 있습니다.
UseReducer 후계는 첫 번째 인자로 Reducer 함수를 지정하고 두 번째 인자로
초기 상태 값을 지정합니다.
그럼 반환 값으로 상태 값과 Dispatch 함수를 받게 됩니다.
리듀서 함수 내에서도 불변성을 지켜줘야 하기에 immer를 활용해서 상태 변경을 하시면
편리하고요.
increment 함수와 decrement 함수 호출에서 dispatch를 통해 통해 액션
객체를 적용하면 그에 맞춰 상태 값이 변경됩니다.
상태 값 초기 값은 고정 값이니깐요.
전역 변수로 빼서 관리하겠습니다.
useReducer 훅으로 변경하고요.
useReducer 훅의 첫 번째 인자는 리듀서 함수이고, 두 번째 인자는 상태값 초기값이며, 세
번째 인자는 초기값을 반환하는 함수입니다.
리듀서 함수는 인자 두 개를 받고요.
첫 번째 인자는 현재 상태값, 두 번째 인자는 액션 객체입니다.
액션 객체는 Dispatch 함수 호출 시의 인자가 그대로 전달됩니다.
useReducer hook의 반환 값은 상태 값 getter와 Dispatch
함수입니다.
increment 함수와 decrement 함수 내 코드는 제거하고요.
Reducer 함수를 구현해 주겠습니다.
모든 액션 객체에서는 파이필드가 있을 것이고요
파이필드 값이 플러스 문자열이면 카운트 값을 1 증가시키고요 마이너스 문자열이면 카운트
값을 1 감소시킵니다
그리고 카운트 값에 맞춰 컬러 값도 변경합니다
이전에는 인크리먼트 함수와 디크리먼트 함수에 나눠 구현되어 있던 로직이 리듀서 함수 하나에
모여 구현되었습니다
increment 함수에서는 type이 plus인 액션 객체를 하나 만들고,
dispatch 함수를 호출하여 상태값에 반영합니다.
decrement 함수에서는 type이 minus인 액션 객체를 하나 만들고,
dispatch 함수를 호출하여 상태값에 반영합니다.
그럼 리듀서가 수행되고 반환값이 새로운 상태값으로 반영이 됩니다.
리듀서 함수 내에서 프로듀스를 통해 값을 변환했는데요.
리듀서 함수를 이렇게 이머를 통해 생성해서 사용하실 수도 있습니다.
그리고 초기 상태값과 변환 함수를 하나의 객체로 묶어서 관리성을 더 높여 보실 수도
있습니다. 이렇게 활용한 상태관리는 모든 상태 변경 로직이 리듀서 함수에 집중되어 관리가
용이하고요. 이 상태값이 여러 컴포넌트에 걸쳐 공유될 때 일관된 상태관리 방식을 제공할 수
있다는 장점이 있습니다.
하지만 한 번에 다루는 상태값의 개수가 많아지고 의존 관계가 복잡해질 경우 리듀서 함수가
매우 길어지고 복잡해집니다.
각 상태값의 의존관계는 최소화하고 리듀서를 분리하여 각 리듀서가 특정 상태나 특정 로직만을
담당하시길 권장드립니다.



1. 폴드 패턴 (Fold Pattern)
정의: 컬렉션의 각 값을 순회하면서 하나의 값으로 누적하는 과정입니다.
사용: JavaScript에서는 Array.reduce(), Python에서는 functools.reduce()로 폴드 패턴을 구현합니다.
예시: [1, 2, 3, 4, 5]의 합계는 초기값 0에 각 요소를 더하며 reduce 함수를 사용하여 최종값 15를 만듭니다.
다양한 초기값: 누적 합은 0, 누적 곱은 1, 통계치는 {} 등으로 설정할 수 있습니다.

2. 리듀서 함수 (Reducer Function)
역할: 누적값과 현재 값을 받아 연산 후 새로운 누적값을 반환하는 순수 함수입니다.
예시: 특정 JSON 파일의 좋아요 수를 합산하거나, 가수의 수를 중복 제거하여 계산, 가수별 곡 수를 통계내는 데 활용됩니다.

3. Node.js 모듈 시스템
CommonJS vs ESM: Node.js 기본 모듈 시스템인 CommonJS는 최상위 수준에서 await 사용이 불가능하므로, ESM 방식으로 실행하려면 파일 확장자를 .mjs로 변경합니다.

4. 가수별 곡수 통계 예시
목표: 좋아요 수를 합산하고, 중복 제거한 가수 수를 계산하며, 가수별 곡 수를 통계화합니다.
Top 5 출력: 곡 수 기준으로 내림차순 정렬 후 상위 5개의 가수를 보여줍니다.

5. 액션 객체 (Action Object)와 상태 누적
개념: 누적 연산에 필요한 정보를 담고 있으며, 타입에 따라 다른 연산을 수행합니다.
예시: 초기 상태값 0에 대해 액션 객체를 통해 plus나 minus 연산을 수행해 최종 누적값을 계산합니다.

6. useReducer Hook 개요
정의: React에서 상태 관리에 리듀서 패턴을 접목시킵니다.
Dispatch 함수: 액션 객체를 전달해 상태 값을 변경하는 역할을 합니다.
장점: 상태 변경의 의도를 명확히 하며, 중앙 집중화를 통해 상태 변경 원인을 추적하기 쉽습니다.

7. 상태와 의존 관계 관리
상태 의존 관리: 의존 관계가 있는 상태값은 하나의 객체로 관리해 불필요한 재렌더링을 줄입니다.
예시: count와 color 상태를 하나의 객체로 묶어 관리하여 count가 짝수일 때는 green, 홀수일 때는 red로 색상을 변경합니다.

8. useReducer 활용 예시
구현: useReducer에 리듀서 함수와 초기 상태값을 전달해 상태값과 Dispatch 함수를 반환받아 관리합니다.
코드 구성: increment/decrement 함수에서 type에 따라 dispatch 호출 시 상태가 변경됩니다.
상태 관리 최적화: 리듀서 함수에 모든 상태 변경 로직을 집중하여 유지보수성을 높입니다.

9. 주의 사항
리듀서 복잡성: 상태값이 많거나 의존 관계가 복잡하면 리듀서가 길어질 수 있으므로, 리듀서를 분리하여 각 리듀서가 특정 로직만 담당하도록 설계하는 것이 좋습니다.