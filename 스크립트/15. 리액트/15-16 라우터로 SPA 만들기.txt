안녕하세요 이번 시간에는 라우터를 활용해서 싱글 페이지 애플리케이션을 만드는 방법을
살펴보겠습니다 싱글
페이지 애플리케이션이란 단일 웹 페이지 내에서 자바스크립트로 직접 URL 라우팅을 처리하는
자바스크립트 애플리케이션을 말합니다
싱글 페이지 애플리케이션은 자바스크립트로 화면과 URL을 변경해서 사용자가 페이지 이동을
한 것처럼 느끼도록 합니다.
브라우저에게 화면 제어를 맡기지 않고 자바스크립트로 화면 플로우 전체를 컨트롤할 수 있기에
지도 애플리케이션이나 워드 프로세서 등을 구현하기에 적합합니다.
전통적인 웹서버는 SSR 방식으로 각 URL로의 페이지 요청마다 웹서버로 요청을 보내고 그
HTML 응답을 웹브라우저가 받아서 브라우저가 직접 화면을 새로 그립니다.
A 링크를 클릭한 페이지 이동에서도 동일한 방식으로 동작합니다.
하지만 싱글 페이지 애플리케이션은 CSR 방식으로 동작합니다.
빈 페이지에서 해당 주소로 처음 요청을 하면 싱글 페이지 애플리케이션 전체 코드를 다운로드
받고요. 다운받은 자바스크립트 애플리케이션에서는 여러 페이지를 보여주는 기능이 이미
구현되어 있습니다.
전체 애플리케이션을 다운받은 뒤에 현재 페이지 주소에 맞는 화면을 자바스크립트를 통해서
그립니다 그리고 그 화면을 그리는 데에 필요한 데이터가 있다면 API 서버로 API를
요청하고 받은 응답으로 화면을 갱신합니다
또한 싱글 페이지 애플리케이션에서 다른 페이지로 이동하는 전용 링크를 클릭하시면
브라우저에게 페이지 이동을 맡기지 않고 애플리케이션 자체적으로 페이지 전환을 처리합니다.
자바스크립트를 사용하여 화면과 URL을 변경하고 변경된 화면을 그리는 데 필요한 API를
호출해서 응답을 받아 화면을 갱신합니다.
물론 싱글 페이지 애플리케이션에서도 태그를 사용하여 페이지 이동을 하면 브라우저를 통해
페이지 이동이 처리됩니다.
이 경우 전체 싱글 페이지 애플리케이션 코드 다운로드를 시도하지만, 브라우저 캐시에 의해
실제 다운로드가 발생하진 않습니다.
React Router DOM 라이브러리를 활용하여 클라이언트 사이드 렌더링에서의 라우팅을
구현해 보겠습니다.
이 라이버리는 메이저 버전마다 사용법이 크게 달라집니다.
2024년 5월 기준으로 최신 버전인 버전 6을 기준으로 구현해 보겠습니다.
Create Browser Router를 활용하여 브라우저 주소에 맞게 렌더링 될
컴포넌트들을 맵핑합니다.
생성된 라우터 객체를 라우터 프로바이더의 라우터 속성으로 지정하시면 이 위치에 현재
브라우저 주소에 맞는 컴포넌트가 자동으로 렌더링됩니다 각 메뉴 링크를 클릭하시면
브라우저에서 새로고침 아이콘이 잠시 X로 변경됨을 확인할 수 있는데요 이는 페이지 로딩
중을 의미하는 거죠
즉, 브라우저에서 페이지 로딩을 직접 처리하고 있다는 의미입니다
현재 React 단에서 라우터를 통해 현재 페이지 주소에 맞는 화면을 보여주고 있지만
링크가 태그의 href 속성으로 브라우저 기본 링크라서 그렇습니다.
앱 8.0 자바스크립트 파일을 생성하고 기본 컴포넌트 구성을 하고요.
인덱스 점 자바스크립트 파일에서는 앱 8 컴포넌트만 사용합니다.
버전 6에 react-router-dom 라이브러리를 설치합니다.
element를 사용하여 홈 블로그 소개 링크를 생성합니다.
생성된 링크를 클릭하면 페이지 주소는 변경되지만 보여지는 내용은 모두 동일합니다.
이는 URL이 변경되더라도 동일한 React 애플리케이션 코드로 응답하기 때문이고요.
React 애플리케이션은 URL을 기반으로 어떤 컴포넌트를 보여줄지 결정해야 합니다.
그러나 현재 코드에는 URL에 따라 다른 컴포넌트를 렌더링하는 로직은 없습니다.
그래서 같은 컴포넌트로 계속 렌더링되고 있습니다.
라우터 프로바이더 컴포넌트를 사용하고 라우터 속성 값을 지정합니다.
라우터 객체는 CreateBrowserRouter 함수 호출을 통해 생성합니다.
url 외로 렌더링 될 컴포넌트를 지정하고요.
이제 각 링크를 클릭해보면 해당 링크에 맞춰 아래에 컴포넌트가 렌더링되고 있습니다
그런데 클릭할 때마다 브라우저 새로고침 아이콘이 바뀌고 있죠
매번 페이지 새로고침이 발생하고 있고요 이는 브라우저에서 페이지 전환을 처리하고 있다는
뜻입니다
자바스크립트에서는 브라우저 히스토릭 API를 사용해서 페이지 이동을 한 것처럼 브라우저
URL을 변경할 수 있습니다.
이를 활용할 수 있도록 React 라우터 룸의 내비 링크 컴포넌트로 링크를 변경합니다.
그러면 브라우저에 개입 없이 라우터만으로 브라우저 URL이 변경되고 컴포넌트로 브라우저
URL에 맞게 변경됩니다.
아울렛 컴포넌트 위치에 Element 속성으로 지정한 컴포넌트가 렌더링됩니다.
A 요소를 NaviLink 컴포넌트로 변경합니다.
NaviLink 컴포넌트는 React Bootstrap 라이브러리가 아닌 React
RouterDOM 라이브러리의 NavLink 컴포넌트를 사용하셔야 링크가 동작합니다.
그런데 타이배러 오류가 발생했습니다.
라우터 프로바이더 컴포넌트는 컨텍스트 API 기반에서 동작하는데요.
NavLink 컴포넌트가 라우터 프로바이더 외부에 있기 때문에 라우터 프로바이더의 컨텍스트를
참조할 수 없어 발생한 오류입니다.
NavLink 컴포넌트는 라우터 프로바이더 안에서만 사용할 수 있습니다.
상단 네비게이션 코드를 라우터 안으로 옮깁니다.
그리고 Children으로 앞서 생성했던 URL 맵핑을 옮겨주세요.
페이지 주소는 루트 주소로 다시 열고요.
그럼 오류 없이 렌더링은 되었는데, 자식 컴포넌트가 렌더링되지 않았습니다.
Element에 지정한 컴포넌트가 Layout 컴포넌트거든요.
Outlet 컴포넌트로 자식 컴포넌트가 렌더링될 지점을 지정해 주시면 그 위치에 자식
컴포넌트가 렌더링됩니다.
Django 템플릿의 Block과 비슷합니다.
내비 링크 컴포넌트에서는 현재 활성화된 링크에는 디폴트로 액티브 클래스가 적용됩니다 그러니
활성화된 링크에 CSS 스타일을 적용하려면 이렇게 CSS 스타일을 추가해 주시면 됩니다
클릭된 내비 링크는 이처럼 액티브 클래스가 적용되어 있습니다
앱 8.css 파일을 생성하고요 액티브 클래스에 대한 기본 스타일을 정의하고요 액티브
이름은 너무 일반적인 이름이니까 이미의 부모 클래스명도 추가합니다.
부모 엘리먼트에 클래스명 적용하고 CSS를 임포트해 주시면 활성화된 내비 링크가 지정된
스타일로 동작함을 확인하실 수 있습니다.
너무 많은 로직이나 엘리먼트가 함
컴포넌트에 집중되면 가독성도 떨어지고 관리하기 어려워집니다.
그리고 React는 컴포넌트 단위로 재렌더링이 이루어지기에 컴포넌트를 적절히 나누면
재렌더링을 효과적으로 수행할 수 있습니다.
Top Navigation 컴포넌트와 Footer 컴포넌트로 나누어 구현하겠습니다.
Top Navigation 컴포넌트에서는 React Router Step 라이브러리의
NavigationBar 컴포넌트를 활용합니다.
네비 링크 컴포넌트 코드들을 잘라내서 TopNavi 컴포넌트로 옮기고요.
이제 간결하게 TopNavi 컴포넌트만 이렇게 적용하시면 되죠.
React Bootstrap에 Container 컴포넌트로 기본 레이아웃을 잡고요.
Footer 컴포넌트로 정의한 뒤에 활용합니다.
그럼 화면이 이렇게부터까지 잘 렌더링 되었습니다
탑 내비게이션 컴포넌트의 코드는 미리 제공해 드린 코드를 복사해서 적용합니다
그럼 이렇게 부터 Step 5 스타일로 페이지가 렌더링 되고요 불필요한 라우터 텍스트는
제거합니다 / 블로그 / 주소에 하위 URL을 등록하고 레이아웃 및
컴포넌트로 맵핑해 보겠습니다.
블로그 주소에 대해 레이아웃 컴포넌트에서를 지정하고요.
레이아웃 컴포넌트에서는 outlet 컴포넌트로 자식 컴포넌트가 렌더링 될 위치를
지정합니다.
children 속성으로 하위 URL 패턴을 맵핑합니다.
인덱스 참 설정은 슬러시 블로그 주소에 맵핑되고요.
패스 설정에서 콜론으로 시작하면 다이나믹 세그먼트로서 컴포넌트에서 해당 값을
useParams 훅로 조회할 수 있습니다.
Django에서는 URL 패턴에서 URLCapturedValue의 역할입니다.
IndexPage 컴포넌트에서는 포스팅 목록을, PostDetailPage 컴포넌트에서는
지정 포스트 아이디의 포스팅을 보여주려고 하는데요.
API를 호출하진 않고요.
dummy 데이터 파일에서 조회하는 방식으로 구현해 보겠습니다.
장고 템플릿에서 최상위 부모 레이아웃 템플릿을 정의하고 각 장고 앱의 레이아웃 템플릿에서
최상위 부모 레이아웃 템플릿을 상속 받도록 구현하여 여러 번의 상속을 받잖아요.
이와 마찬가지로 React 라우터 DOM에서도 계층 구조를 가집니다.
최상위의 엘리먼트가 최상위 부모 레이아웃이 되는 것이고요.
각 자식 라우터에서도 계층적으로 레이아웃을 두고 자식을 가질 수 있습니다.
블로그 레이아웃 컴포넌트를 만들어서 적용하겠습니다
이 컴포넌트는 src 폴더, pages 폴더, 블로그의 layout.jsx 경로에
생성하겠습니다
임포트해서 적용하면 블로그 주소에서 이렇게 블로그 레이아웃 컴포넌트가 잘 렌더링됩니다
이제 블로그 주소의 하위 주소를 맵핑하겠고요 인덱스 주소에서는 블로그 인덱스 페이지
컴포넌트를 렌더링하고요 블로그 주소 아래에 포스팅 아이디를 맵핑합니다
그 아이디를 post id 이름으로
blog-post-detail-page-component에서 활용하도록 하겠습니다.
pages에 blog에 index-page.js 경로에 컴포넌트를
생성하고요.
pages에 blog에 post-detail-page.js 경로에도
컴포넌트를 생성합니다.
app-file-component에서 각 컴포넌트를 임포트해 주시고요.
그럼 슬러시 블로그 주소와 슬러시 블로그 슬러시 10 등의 주소에서 오류 없이 렌더링은
되지만 블로그 레이아웃만 렌더링 되고 인덱스 페이지 컴포넌트와 포스트 디테일 페이지
컴포넌트는 렌더링 되지 않았습니다
그 이유는 블로그 레이아웃 컴포넌트에서 아웃렛 컴포넌트로 자식 컴포넌트가 렌더링 될 위치를
지정하지 않았기 때문입니다
위치를 지정해 주시면 해당 위치에 자식 컴포넌트가 렌더링 됩니다 포스팅 데이터는 API
없이 로컬 배열 데이터를 활용하겠습니다.
미리 제공해 드린 코드를 복사하셔서 페이지스의 블로그의 데이터 점 자바스크립트 경로에
복사합니다. 이 방식은 정적 방식의 블로그 서비스에 활용하실 수 있습니다.
인덱스 페이지 컴포넌트에서 포스트 리스트 배열을 임포트하고요.
순회하며 네비 링크 컴포넌트로 렌더링합니다.
그럼 이렇게 포스팅 목록이 잘 렌더링 되었습니다.
포스팅 제목을 클릭하면 페이지가 변경되고요.
PostDetailPage 컴포넌트가 렌더링됩니다.
PostDetailPage 컴포넌트에서 지정 포스팅 아이디에 포스팅을 조회해야겠죠.
useParams Hook을 통해 앞서 지정했던 DynamicSegments 값을
조회하고요. 포스트 리스트 배열에서 해당 아이디의 포스팅 데이터를 찾아보고 없다면 404
페이지나 파운드 의미로 alert 컴포넌트로 렌더링하고 포스팅 데이터가 있다면 제목과
내용을 렌더링합니다.
웹서버에서는 존재하지 않는 혹은 서비스할 수 없는 주소로 클라이언트가 요청하면 404
페이지 Not Found 응답을 하는데요.
React 라우터 DOM 라이브러리에서는 등록되지 않은 URL에 대해서 렌더링을 요청받게
되면 이렇게 Unexpected Application Error 페이지 응답을 합니다.
이 에러 페이지를 이처럼 원하는 컴포넌트로 렌더링 하실 수 있습니다.
최상위 패스에서 에러 엘리먼트 속성으로 라우팅 에러 내역을 보여줄 컴포넌트를 지정합니다.
지원하지 않는 URL로 접근하면 이렇게 Create React 앱의 기본 404 Not
Found 화면을 확인하실 수 있습니다.
최상위 라우터에서 에러 엘리먼트 설정으로 에러가 발생했을 때 보여질 컴포넌트를 지정하실 수
있습니다. 지정한 대로 잘 동작하고요.
라우터 에러 페이지 점 JSX 코드를 복사해서 파일을 생성하고요.
에러 엘리먼트 설정을 변경하시면 이렇게 지정된 컴포넌트로 에러 내역이 보여지고 있습니다.
보다 상세한 에러 내역은 Use Router Error Hook을 통해 조회하실 수
있습니다.